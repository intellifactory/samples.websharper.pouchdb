try{Object.defineProperty(Error.prototype,"message",{enumerable:!0})}catch(e){}var IntelliFactory={Runtime:{Class:function(n,t){function i(){}i.prototype=n;for(var r in t)i[r]=t[r];return i},Define:function(n,t){function i(n,t){var u,f,e;for(u in t)if(f=typeof n[u],e=typeof t[u],f=="object"&&e=="object")i(n[u],t[u]);else if(f=="undefined"||r)n[u]=t[u];else throw new Error("Name conflict: "+u);}var r=!!this.overwrite;i(n,t)},Field:function(n){var t,i=!1;return function(){return i||(i=!0,t=n()),t}},For:function(n,t,i){for(var r=n;r<=t;r++)i(r)},ForEach:function(n,t){for(var i in n)t(i)},New:function(n,t){var i=new n;for(var r in t)r in i||(i[r]=t[r]);return i},OnInit:function(n){"init"in this||(this.init=[]);this.init.push(n)},OnLoad:function(n){"load"in this||(this.load=[]);this.load.push(n)},Inherit:function(n,t){var r=n.prototype,i;n.prototype=new t;for(i in r)n.prototype[i]=r[i]},Safe:function(n){return n===undefined?{}:n},Start:function(){function n(n){for(var t=0;t<n.length;t++)n[t]()}"init"in this&&(n(this.init),this.init=[]);"load"in this&&(n(this.load),this.load=[])},Throw:function(n){throw n;},Tupled:function(n){return function(t){return arguments.length>1?n(arguments):n(t)}},Try:function(n,t){try{return n()}catch(i){return t(i)}},TryFinally:function(n,t){try{return n()}finally{t()}},While:function(n,t){while(n())t()}}};Date.now||(Date.now=function(){return(new Date).getTime()});
var JSON;JSON||(JSON={}),function(){"use strict";function i(n){return n<10?"0"+n:n}function f(n){return o.lastIndex=0,o.test(n)?'"'+n.replace(o,function(n){var t=s[n];return typeof t=="string"?t:"\\u"+("0000"+n.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+n+'"'}function r(i,e){var s,l,h,a,v=n,c,o=e[i];o&&typeof o=="object"&&typeof o.toJSON=="function"&&(o=o.toJSON(i));typeof t=="function"&&(o=t.call(e,i,o));switch(typeof o){case"string":return f(o);case"number":return isFinite(o)?String(o):"null";case"boolean":case"null":return String(o);case"object":if(!o)return"null";if(n+=u,c=[],Object.prototype.toString.apply(o)==="[object Array]"){for(a=o.length,s=0;s<a;s+=1)c[s]=r(s,o)||"null";return h=c.length===0?"[]":n?"[\n"+n+c.join(",\n"+n)+"\n"+v+"]":"["+c.join(",")+"]",n=v,h}if(t&&typeof t=="object")for(a=t.length,s=0;s<a;s+=1)typeof t[s]=="string"&&(l=t[s],h=r(l,o),h&&c.push(f(l)+(n?": ":":")+h));else for(l in o)Object.prototype.hasOwnProperty.call(o,l)&&(h=r(l,o),h&&c.push(f(l)+(n?": ":":")+h));return h=c.length===0?"{}":n?"{\n"+n+c.join(",\n"+n)+"\n"+v+"}":"{"+c.join(",")+"}",n=v,h}}typeof Date.prototype.toJSON!="function"&&(Date.prototype.toJSON=function(){return isFinite(this.valueOf())?this.getUTCFullYear()+"-"+i(this.getUTCMonth()+1)+"-"+i(this.getUTCDate())+"T"+i(this.getUTCHours())+":"+i(this.getUTCMinutes())+":"+i(this.getUTCSeconds())+"Z":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(){return this.valueOf()});var e=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,o=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,n,u,s={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},t;typeof JSON.stringify!="function"&&(JSON.stringify=function(i,f,e){var o;if(n="",u="",typeof e=="number")for(o=0;o<e;o+=1)u+=" ";else typeof e=="string"&&(u=e);if(t=f,f&&typeof f!="function"&&(typeof f!="object"||typeof f.length!="number"))throw new Error("JSON.stringify");return r("",{"":i})});typeof JSON.parse!="function"&&(JSON.parse=function(n,t){function r(n,i){var f,e,u=n[i];if(u&&typeof u=="object")for(f in u)Object.prototype.hasOwnProperty.call(u,f)&&(e=r(u,f),e!==undefined?u[f]=e:delete u[f]);return t.call(n,i,u)}var i;if(n=String(n),e.lastIndex=0,e.test(n)&&(n=n.replace(e,function(n){return"\\u"+("0000"+n.charCodeAt(0).toString(16)).slice(-4)})),/^[\],:{}\s]*$/.test(n.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,"")))return i=eval("("+n+")"),typeof t=="function"?r({"":i},""):i;throw new SyntaxError("JSON.parse");})}();
(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T;$.Define($$,{IntelliFactory:{WebSharper:{AggregateException:$.Class({},{New:function($innerExceptions){var $0=this,$this=this;return $$.e=new $$.Error("AggregateException"),$$.e.InnerExceptions=$innerExceptions,$$.e;}}),Arrays:{Find:function(U,V){var W,X,Y;W=b.tryFind(U,V);if(W.$==0){X=c.FailWith("KeyNotFoundException");}else{Y=W.$0;X=Y;}return X;},FindIndex:function(Z,_0){var _1,_2,_3;_1=b.tryFindIndex(Z,_0);if(_1.$==0){_2=c.FailWith("KeyNotFoundException");}else{_3=_1.$0;_2=_3;}return _2;},Pick:function(_4,_5){var _6,_7,_8;_6=b.tryPick(_4,_5);if(_6.$==0){_7=c.FailWith("KeyNotFoundException");}else{_8=_6.$0;_7=_8;}return _7;},average:function(_9){return d(b.sum(_9))/d(e.GetLength(_9));},averageBy:function(_,ba){return d(b.sumBy(_,ba))/d(e.GetLength(ba));},blit:function(ba,bb,bc,bd,be){var bf;b.checkRange(ba,bb,be);b.checkRange(bc,bd,be);for(bf=0;bf<=be-1;bf++){e.SetArray(bc,bd+bf,e.GetArray(ba,bb+bf));}return;},checkLength:function(bg,bh){return e.GetLength(bg)!==e.GetLength(bh)?c.FailWith("Arrays differ in length."):null;},checkRange:function(bi,bj,bk){return((bk<0?true:bj<0)?true:e.GetLength(bi)<bj+bk)?c.FailWith("Index was outside the bounds of the array."):null;},choose:function(bl,bm){var bn,bo,bp,bq,br;bn=[];for(bo=0;bo<=e.GetLength(bm)-1;bo++){bp=bl(e.GetArray(bm,bo));if(bp.$==0){bq=null;}else{br=bp.$0;bq=bn.push(br);}}return bn;},collect:function(bs,bt){return f.prototype.concat.apply([],b.map(bs,bt));},concat:function(bu){return f.prototype.concat.apply([],b.ofSeq(bu));},create:function(bv,bw){var bx,by;bx=f(bv);for(by=0;by<=bv-1;by++){e.SetArray(bx,by,bw);}return bx;},exists2:function(bz,bA,bB){b.checkLength(bA,bB);return g.exists2(bz,bA,bB);},fill:function(bC,bD,bE,bF){var bG;b.checkRange(bC,bD,bE);for(bG=bD;bG<=bD+bE-1;bG++){e.SetArray(bC,bG,bF);}return;},filter:function(bH,bI){var bJ,bK;bJ=[];for(bK=0;bK<=e.GetLength(bI)-1;bK++){bH(e.GetArray(bI,bK))?bJ.push(e.GetArray(bI,bK)):null;}return bJ;},fold:function(bL,bM,bN){var bO,bP;bO=bM;for(bP=0;bP<=e.GetLength(bN)-1;bP++){bO=(bL(bO))(e.GetArray(bN,bP));}return bO;},fold2:function(bQ,bR,bS,bT){var bU,bV;b.checkLength(bS,bT);bU=bR;for(bV=0;bV<=bS.length-1;bV++){bU=((bQ(bU))(e.GetArray(bS,bV)))(e.GetArray(bT,bV));}return bU;},foldBack:function(bW,bX,bY){var bZ,b0,b1;bZ=bY;b0=e.GetLength(bX);for(b1=1;b1<=b0;b1++){bZ=(bW(e.GetArray(bX,b0-b1)))(bZ);}return bZ;},foldBack2:function(b2,b3,b4,b5){var b6,b7,b8;b.checkLength(b3,b4);b6=e.GetLength(b3);b7=b5;for(b8=1;b8<=b6;b8++){b7=((b2(e.GetArray(b3,b6-b8)))(e.GetArray(b4,b6-b8)))(b7);}return b7;},forall2:function(b9,b_,b$){b.checkLength(b_,b$);return g.forall2(b9,b_,b$);},init:function(ca,cb){var cc,cd;ca<0?c.FailWith("Negative size given."):null;cc=f(ca);for(cd=0;cd<=ca-1;cd++){e.SetArray(cc,cd,cb(cd));}return cc;},iter:function(ce,cf){var cg;for(cg=0;cg<=e.GetLength(cf)-1;cg++){ce(e.GetArray(cf,cg));}return;},iter2:function(ch,ci,cj){var ck;b.checkLength(ci,cj);for(ck=0;ck<=e.GetLength(ci)-1;ck++){(ch(e.GetArray(ci,ck)))(e.GetArray(cj,ck));}return;},iteri:function(cl,cm){var cn;for(cn=0;cn<=e.GetLength(cm)-1;cn++){(cl(cn))(e.GetArray(cm,cn));}return;},iteri2:function(co,cp,cq){var cr;b.checkLength(cp,cq);for(cr=0;cr<=e.GetLength(cp)-1;cr++){((co(cr))(e.GetArray(cp,cr)))(e.GetArray(cq,cr));}return;},map:function(cs,ct){var cu,cv;cu=f(e.GetLength(ct));for(cv=0;cv<=e.GetLength(ct)-1;cv++){e.SetArray(cu,cv,cs(e.GetArray(ct,cv)));}return cu;},map2:function(cw,cx,cy){var cz,cA;b.checkLength(cx,cy);cz=f(e.GetLength(cy));for(cA=0;cA<=e.GetLength(cy)-1;cA++){e.SetArray(cz,cA,(cw(e.GetArray(cx,cA)))(e.GetArray(cy,cA)));}return cz;},mapi:function(cB,cC){var cD,cE;cD=f(e.GetLength(cC));for(cE=0;cE<=e.GetLength(cC)-1;cE++){e.SetArray(cD,cE,(cB(cE))(e.GetArray(cC,cE)));}return cD;},mapi2:function(cF,cG,cH){var cI,cJ;b.checkLength(cG,cH);cI=f(e.GetLength(cG));for(cJ=0;cJ<=e.GetLength(cG)-1;cJ++){e.SetArray(cI,cJ,((cF(cJ))(e.GetArray(cG,cJ)))(e.GetArray(cH,cJ)));}return cI;},max:function(cK){return b.reduce(function(cL){return function(cM){return c.Max(cL,cM);};},cK);},maxBy:function(cN,cO){return b.reduce(function(cP){return function(cQ){return h.Compare(cN(cP),cN(cQ))===1?cP:cQ;};},cO);},min:function(cR){return b.reduce(function(cS){return function(cT){return c.Min(cS,cT);};},cR);},minBy:function(cU,cV){return b.reduce(function(cW){return function(cX){return h.Compare(cU(cW),cU(cX))===-1?cW:cX;};},cV);},nonEmpty:function(cY){return e.GetLength(cY)===0?c.FailWith("The input array was empty."):null;},ofSeq:function(cZ){var c0,c1;c0=[];c1=i.Get(cZ);while(c1.MoveNext()){c0.push(c1.get_Current());}return c0;},partition:function(c2,c3){var c4,c5,c6;c4=[];c5=[];for(c6=0;c6<=e.GetLength(c3)-1;c6++){c2(e.GetArray(c3,c6))?c4.push(e.GetArray(c3,c6)):c5.push(e.GetArray(c3,c6));}return[c4,c5];},permute:function(c7,c8){var c9,c_;c9=f(e.GetLength(c8));for(c_=0;c_<=e.GetLength(c8)-1;c_++){e.SetArray(c9,c7(c_),e.GetArray(c8,c_));}return c9;},reduce:function(c$,da){var db,dc;b.nonEmpty(da);db=e.GetArray(da,0);for(dc=1;dc<=e.GetLength(da)-1;dc++){db=(c$(db))(e.GetArray(da,dc));}return db;},reduceBack:function(dd,de){var df,dg,dh;b.nonEmpty(de);df=e.GetLength(de);dg=e.GetArray(de,df-1);for(dh=2;dh<=df;dh++){dg=(dd(e.GetArray(de,df-dh)))(dg);}return dg;},reverse:function(di,dj,dk){var dl;dl=b.sub(di,dj,dk).slice().reverse();return b.blit(dl,0,di,dj,e.GetLength(dl));},scan:function(dm,dn,_do){var dp,dq;dp=f(1+e.GetLength(_do));e.SetArray(dp,0,dn);for(dq=0;dq<=e.GetLength(_do)-1;dq++){e.SetArray(dp,dq+1,(dm(e.GetArray(dp,dq)))(e.GetArray(_do,dq)));}return dp;},scanBack:function(dr,ds,dt){var du,dv,dw;du=e.GetLength(ds);dv=f(1+du);e.SetArray(dv,du,dt);for(dw=0;dw<=du-1;dw++){e.SetArray(dv,du-dw-1,(dr(e.GetArray(ds,du-dw-1)))(e.GetArray(dv,du-dw)));}return dv;},sort:function(dx){return b.sortBy(function(dy){return dy;},dx);},sortBy:function(dz,dA){var dB;dB=$.Tupled(function(dC){var dD,dE;dD=dC[0];dE=dC[1];return c.Compare(dz(dD),dz(dE));});return dA.slice().sort(dB);},sortInPlace:function(dF){return b.sortInPlaceBy(function(dG){return dG;},dF);},sortInPlaceBy:function(dH,dI){var dJ;dJ=$.Tupled(function(dK){var dL,dM;dL=dK[0];dM=dK[1];return c.Compare(dH(dL),dH(dM));});return dI.sort(dJ);},sortInPlaceWith:function(dN,dO){var dP;dP=$.Tupled(function(dQ){var dR,dS;dR=dQ[0];dS=dQ[1];return(dN(dR))(dS);});return dO.sort(dP);},sortWith:function(dT,dU){var dV;dV=$.Tupled(function(dW){var dX,dY;dX=dW[0];dY=dW[1];return(dT(dX))(dY);});return dU.slice().sort(dV);},sub:function(dZ,d0,d1){b.checkRange(dZ,d0,d1);return dZ.slice(d0,d0+d1);},sum:function($arr){var $0=this,$this=this;var sum=0;for(var i=0;i<$arr.length;i++)sum+=$arr[i];return sum;},sumBy:function($f,$arr){var $0=this,$this=this;var sum=0;for(var i=0;i<$arr.length;i++)sum+=$f($arr[i]);return sum;},tryFind:function(d2,d3){var d4,d5;d4={$:0};d5=0;while(d5<e.GetLength(d3)?d4.$==0:false){d2(e.GetArray(d3,d5))?d4={$:1,$0:e.GetArray(d3,d5)}:null;d5=d5+1;}return d4;},tryFindIndex:function(d6,d7){var d8,d9;d8={$:0};d9=0;while(d9<e.GetLength(d7)?d8.$==0:false){d6(e.GetArray(d7,d9))?d8={$:1,$0:d9}:null;d9=d9+1;}return d8;},tryPick:function(d_,d$){var ea,eb,ec;ea={$:0};eb=0;while(eb<e.GetLength(d$)?ea.$==0:false){ec=d_(e.GetArray(d$,eb));ec.$==1?ea=ec:null;eb=eb+1;}return ea;},unzip:function(ed){var ee,ef,eg,eh,ei,ej;ee=[];ef=[];for(eg=0;eg<=e.GetLength(ed)-1;eg++){eh=e.GetArray(ed,eg);ei=eh[1];ej=eh[0];ee.push(ej);ef.push(ei);}return[ee,ef];},unzip3:function(ek){var el,em,en,eo,ep,eq,er,es;el=[];em=[];en=[];for(eo=0;eo<=e.GetLength(ek)-1;eo++){ep=e.GetArray(ek,eo);eq=ep[2];er=ep[1];es=ep[0];el.push(es);em.push(er);en.push(eq);}return[el,em,en];},zip:function(et,eu){var ev,ew;b.checkLength(et,eu);ev=f(et.length);for(ew=0;ew<=e.GetLength(et)-1;ew++){e.SetArray(ev,ew,[e.GetArray(et,ew),e.GetArray(eu,ew)]);}return ev;},zip3:function(ex,ey,ez){var eA,eB;b.checkLength(ex,ey);b.checkLength(ey,ez);eA=f(ex.length);for(eB=0;eB<=e.GetLength(ex)-1;eB++){e.SetArray(eA,eB,[e.GetArray(ex,eB),e.GetArray(ey,eB),e.GetArray(ez,eB)]);}return eA;}},Arrays2D:{copy:function(eC){return j.init(eC.length,eC.length?eC[0].length:0,function(eD){return function(eE){return e.GetArray2D(eC,eD,eE);};});},init:function(eF,eG,eH){var eI,eJ,eK;eI=j.zeroCreate(eF,eG);for(eJ=0;eJ<=eF-1;eJ++){for(eK=0;eK<=eG-1;eK++){e.SetArray2D(eI,eJ,eK,(eH(eJ))(eK));}}return eI;},iter:function(eL,eM){var eN,eO,eP,eQ;eN=eM.length;eO=eM.length?eM[0].length:0;for(eP=0;eP<=eN-1;eP++){for(eQ=0;eQ<=eO-1;eQ++){eL(e.GetArray2D(eM,eP,eQ));}}return;},iteri:function(eR,eS){var eT,eU,eV,eW;eT=eS.length;eU=eS.length?eS[0].length:0;for(eV=0;eV<=eT-1;eV++){for(eW=0;eW<=eU-1;eW++){((eR(eV))(eW))(e.GetArray2D(eS,eV,eW));}}return;},map:function(eX,eY){return j.init(eY.length,eY.length?eY[0].length:0,function(eZ){return function(e0){return eX(e.GetArray2D(eY,eZ,e0));};});},mapi:function(e1,e2){return j.init(e2.length,e2.length?e2[0].length:0,function(e3){return function(e4){return((e1(e3))(e4))(e.GetArray2D(e2,e3,e4));};});},zeroCreate:function(e5,e6){return e.Array2DZeroCreate(e5,e6);}},AsyncProxy:$.Class({},{get_CancellationToken:function(){return k.GetCT();},get_DefaultCancellationToken:function(){return k.defCTS().contents;}}),CancellationTokenSource:$.Class({Cancel:function(){var e7,e8,fa,fb;if(!this.c){this.c=true;e8=function(e9){var e_,e$;try{e9(null);e_={$:0};}catch(e$){e_={$:1,$0:e$};}return e_;};fa=this.r;fb=b.choose(e8,fa);e7=e.GetLength(fb)>0?c.Raise(l.New(fb)):null;}else{e7=null;}return e7;},Cancel1:function(fc){var fd,fe,ff,fh;if(!fc){fd=this.Cancel();}else{if(!this.c){this.c=true;ff=function(fg){return fg(null);};fh=this.r;fe=b.iter(ff,fh);}else{fe=null;}fd=fe;}return fd;},CancelAfter:function(fi){var fj,fk,fm,fo=this;if(!this.c){fk=this.pending;m.iter(function(fl){return n(fl);},fk);fm=o(function(){return fo.Cancel();},fi);fj=void(this.pending={$:1,$0:fm});}else{fj=null;}return fj;},get_IsCancellationRequested:function(){return this.c;}},{CreateLinkedTokenSource:function(fp,fq){return p.CreateLinkedTokenSource1([fp,fq]);},CreateLinkedTokenSource1:function(fr){var fs,ft;fs=p.New();ft=function(fu){var fv,fx;fv=function(){return fs.Cancel();};fx=k.Register(fu,function(){return fv();});return;};return b.iter(ft,fr);},New:function(){var fz;fz=$.New(this,{});fz.c=false;fz.pending={$:0};fz.r=[];return fz;}}),Char:$.Class({},{GetNumericValue:function(fA){return(fA>=48?fA<=57:false)?d(fA)-d(48):-1;},IsControl:function(fB){return(fB>=0?fB<=31:false)?true:fB>=128?fB<=159:false;},IsDigit:function(fC){return fC>=48?fC<=57:false;},IsLetter:function(fD){return(fD>=65?fD<=90:false)?true:fD>=97?fD<=122:false;},IsLetterOrDigit:function(fE){return q.IsLetter(fE)?true:q.IsDigit(fE);},IsLower:function(fF){return fF>=97?fF<=122:false;},IsUpper:function(fG){return fG>=65?fG<=90:false;},IsWhiteSpace:function($c){var $0=this,$this=this;return $$.String.fromCharCode($c).match(/\s/)!==null;},Parse:function(fH){return fH.length===1?fH.charCodeAt(0):c.FailWith("String must be exactly one character long.");}}),Concurrency:{AwaitEvent:function(fI){var fJ;fJ=function(fK){var fL,fM,fN,fO,fP,fQ;fL=function(){return r.subscribeTo(fI,function(fS){var fT;s.Force(fM).Dispose();s.Force(fO).Dispose();fT=function(){return fK.k.call(null,{$:0,$0:fS});};return k.scheduler().Fork(fT);});};fM=s.Create(fL);fN=function(){return k.Register(fK.ct,function(){var fX;s.Force(fM).Dispose();fX=function(){return fK.k.call(null,{$:2,$0:new t("OperationCanceledException")});};return k.scheduler().Fork(fX);});};fO=s.Create(fN);fP=s.Force(fM);fQ=s.Force(fO);return null;};return k.checkCancel(fJ);},Bind:function(fZ,f0){var f1;f1=function(f2){return fZ({k:function(f3){var f4,f5,f6,f_;if(f3.$==0){f5=f3.$0;f6=function(){var f8,f9;try{f8=(f0(f5))(f2);}catch(f9){f8=f2.k.call(null,{$:1,$0:f9});}return f8;};f4=k.scheduler().Fork(f6);}else{f_=function(){return f2.k.call(null,f3);};f4=k.scheduler().Fork(f_);}return f4;},ct:f2.ct});};return k.checkCancel(f1);},Catch:function(ga){var gb;gb=function(gc){var gd,gi;try{gd=ga({k:function(ge){var gf,gg,gh;if(ge.$==0){gg=ge.$0;gf=gc.k.call(null,{$:0,$0:{$:0,$0:gg}});}else{if(ge.$==1){gh=ge.$0;gf=gc.k.call(null,{$:0,$0:{$:1,$0:gh}});}else{gf=gc.k.call(null,ge);}}return gf;},ct:gc.ct});}catch(gi){gd=gc.k.call(null,{$:0,$0:{$:1,$0:gi}});}return gd;};return k.checkCancel(gb);},Combine:function(gj,gk){return k.Bind(gj,function(){return gk;});},Delay:function(gm){var gn;gn=function(go){var gp,gq;try{gp=(gm(null))(go);}catch(gq){gp=go.k.call(null,{$:1,$0:gq});}return gp;};return k.checkCancel(gn);},For:function(gr,gs){var gt;gt=i.Get(gr);return k.While(function(){return gt.MoveNext();},k.Delay(function(){return gs(gt.get_Current());}));},FromContinuations:function(gw){var gx;gx=function(gy){var gz,gA;gz={contents:false};gA=function(gB){var gC;if(gz.contents){gC=c.FailWith("A continuation provided by Async.FromContinuations was invoked multiple times");}else{gz.contents=true;gC=k.scheduler().Fork(gB);}return gC;};return gw([function(gD){return gA(function(){return gy.k.call(null,{$:0,$0:gD});});},function(gF){return gA(function(){return gy.k.call(null,{$:1,$0:gF});});},function(gH){return gA(function(){return gy.k.call(null,{$:2,$0:gH});});}]);};return k.checkCancel(gx);},GetCT:$.Field(function(){var gJ;gJ=function(gK){return gK.k.call(null,{$:0,$0:gK.ct});};return k.checkCancel(gJ);}),Ignore:function(gL){return k.Bind(gL,function(){return k.Return(null);});},OnCancel:function(gN){var gO;gO=function(gP){return gP.k.call(null,{$:0,$0:k.Register(gP.ct,gN)});};return k.checkCancel(gO);},Parallel:function(gQ){var gR,gS,gT;gR=b.ofSeq(gQ);if(e.GetLength(gR)===0){gS=k.Return([]);}else{gT=function(gU){var gV,gW,gX,gY;gV=gR.length;gW={contents:gV};gX=b.create(gV,undefined);gY=function(gZ){return function(g0){var g1,g2,g3,g4,g5,g6,g7,g8,g9;g1=[gW.contents,g0];if(g1[0]===0){g2=null;}else{if(g1[0]===1){if(g1[1].$==0){g4=g1[1].$0;e.SetArray(gX,gZ,g4);gW.contents=0;g3=gU.k.call(null,{$:0,$0:gX});}else{g1[0];g5=g1[1];gW.contents=0;g3=gU.k.call(null,g5);}g2=g3;}else{if(g1[1].$==0){g7=g1[1].$0;g8=g1[0];e.SetArray(gX,gZ,g7);g6=void(gW.contents=g8-1);}else{g1[0];g9=g1[1];gW.contents=0;g6=gU.k.call(null,g9);}g2=g6;}}return g2;};};return b.iteri(function(g_){return function(g$){var ha;ha=function(){return g$({k:gY(g_),ct:gU.ct});};return k.scheduler().Fork(ha);};},gR);};gS=k.checkCancel(gT);}return gS;},Register:function(hc,hd){var he;he=hc.r.push(hd)-1;return{Dispose:function(){return e.SetArray(hc.r,he,function(){});}};},Return:function(hh){var hi;hi=function(hj){return hj.k.call(null,{$:0,$0:hh});};return k.checkCancel(hi);},Scheduler:$.Class({Fork:function(hk){var hl,hm,ho=this;this.robin.push(hk);if(this.idle){this.idle=false;hm=o(function(){return ho.tick();},0);hl=void hm;}else{hl=null;}return hl;},tick:function(){var hp,hq,hr,hs,ht,hu,hw=this;hp=u.now();hq=true;while(hq){hr=this.robin.length;if(hr===0){this.idle=true;hs=hq=false;}else{(this.robin.shift())(null);if(u.now()-hp>40){hu=o(function(){return hw.tick();},0);ht=hq=false;}else{ht=null;}hs=ht;}}return;}},{New:function(){var hx;hx=$.New(this,{});hx.idle=true;hx.robin=[];return hx;}}),Sleep:function(hy){var hz;hz=function(hA){var hB,hC,hD,hE,hF,hG;hB=function(){return o(function(){var hJ;s.Force(hE).Dispose();hJ=function(){return hA.k.call(null,{$:0,$0:null});};return k.scheduler().Fork(hJ);},hy);};hC=s.Create(hB);hD=function(){return k.Register(hA.ct,function(){var hN;n(s.Force(hC));hN=function(){return hA.k.call(null,{$:2,$0:new t("OperationCanceledException")});};return k.scheduler().Fork(hN);});};hE=s.Create(hD);hF=s.Force(hC);hG=s.Force(hE);return null;};return k.checkCancel(hz);},Start:function(hP,hQ){return k.StartWithContinuations(hP,function(){},function(hS){var hT;hT=["WebSharper: Uncaught asynchronous exception",hS];return v?v.log.apply(v,hT):undefined;},function(){},hQ);},StartChild:function(hV){var hW;hW=function(hX){var hY,hZ,h0,h3,h8;hY={contents:{$:0}};hZ=[];h0=function(){return hV({k:function(h2){hY.contents={$:1,$0:h2};while(hZ.length>0){(hZ.shift())(h2);}return;},ct:hX.ct});};k.scheduler().Fork(h0);h3=function(h4){var h5,h6,h7;h5=hY.contents;if(h5.$==0){h6=hZ.push(h4.k);}else{h7=h5.$0;h6=h4.k.call(null,h7);}return h6;};h8=k.checkCancel(h3);return hX.k.call(null,{$:0,$0:h8});};return k.checkCancel(hW);},StartWithContinuations:function(h9,h_,h$,ia,ib){var ic,id;ic=c.DefaultArg(ib,k.defCTS().contents);id=function(){return h9({k:function(_if){var ig,ih,ii,ij;if(_if.$==1){ih=_if.$0;ig=h$(ih);}else{if(_if.$==2){ii=_if.$0;ig=ia(ii);}else{ij=_if.$0;ig=h_(ij);}}return ig;},ct:ic});};return k.scheduler().Fork(id);},TryCancelled:function(ik,il){var im;im=function(_in){return ik({k:function(io){var ip,iq;if(io.$==2){iq=io.$0;il(iq);ip=_in.k.call(null,io);}else{ip=_in.k.call(null,io);}return ip;},ct:_in.ct});};return k.checkCancel(im);},TryFinally:function(ir,is){var it;it=function(iu){return ir({k:function(iv){var iw,ix;try{is(null);iw=iu.k.call(null,iv);}catch(ix){iw=iu.k.call(null,{$:1,$0:ix});}return iw;},ct:iu.ct});};return k.checkCancel(it);},TryWith:function(iy,iz){var iA;iA=function(iB){return iy({k:function(iC){var iD,iE,iF,iG,iH;if(iC.$==0){iE=iC.$0;iD=iB.k.call(null,{$:0,$0:iE});}else{if(iC.$==1){iF=iC.$0;try{iG=(iz(iF))(iB);}catch(iH){iG=iB.k.call(null,iC);}iD=iG;}else{iD=iB.k.call(null,iC);}}return iD;},ct:iB.ct});};return k.checkCancel(iA);},Using:function(iI,iJ){return k.TryFinally(iJ(iI),function(){return iI.Dispose();});},While:function(iL,iM){return iL(null)?k.Bind(iM,function(){return k.While(iL,iM);}):k.Return(null);},checkCancel:function(iO){return function(iP){return iP.ct.c?iP.k.call(null,{$:2,$0:new t("OperationCanceledException")}):iO(iP);};},defCTS:$.Field(function(){return{contents:p.New()};}),scheduler:$.Field(function(){return w.New();})},Control:{createEvent:function(iQ,iR,iS){return{AddHandler:iQ,RemoveHandler:iR,Subscribe:function(iT){var iU;iU=iS(function(){return function(iW){return iT.OnNext.call(null,iW);};});iQ(iU);return{Dispose:function(){return iR(iU);}};}};}},DateTimeHelpers:{AddMonths:function(iY,iZ){var i0;i0=new u(iY);return(new u(i0.getFullYear(),i0.getMonth()+iZ,i0.getDate(),i0.getHours(),i0.getMinutes(),i0.getSeconds(),i0.getMilliseconds())).getTime();},AddYears:function(i1,i2){var i3;i3=new u(i1);return(new u(i3.getFullYear()+i2,i3.getMonth(),i3.getDate(),i3.getHours(),i3.getMinutes(),i3.getSeconds(),i3.getMilliseconds())).getTime();},DatePortion:function(i4){var i5;i5=new u(i4);return(new u(i5.getFullYear(),i5.getMonth(),i5.getDate())).getTime();},TimePortion:function(i6){var i7;i7=new u(i6);return(((24*0+i7.getHours())*60+i7.getMinutes())*60+i7.getSeconds())*1000+i7.getMilliseconds();}},Enumerable:{Of:function(i8){return{GetEnumerator:i8};}},Enumerator:{Get:function(i9){var i_,i$,jf,jg;if(i9 instanceof $$.Array){i$=function(ja){var jb,jc,jd,je;jb=ja.s;if(jb<e.GetLength(i9)){jd=e.GetArray(i9,jb);ja.c=jd;je=jb+1;ja.s=je;jc=true;}else{jc=false;}return jc;};i_=x.New(0,null,i$);}else{if(h.Equals(typeof i9,"string")){jg=function(jh){var ji,jj,jk,jl;ji=jh.s;if(ji<i9.length){jk=i9.charCodeAt(ji);jh.c=jk;jl=ji+1;jh.s=jl;jj=true;}else{jj=false;}return jj;};jf=x.New(0,null,jg);}else{jf=i9.GetEnumerator();}i_=jf;}return i_;},T:$.Class({MoveNext:function(){return this.n.call(null,this);},get_Current:function(){return this.c;}},{New:function(jm,jn,jo){var jp;jp=$.New(this,{});jp.s=jm;jp.c=jn;jp.n=jo;return jp;}})},ExtraTopLevelOperatorsProxy:{array2D:function(jq){var jr,jt,ju;jr=function(js){return b.ofSeq(js);};jt=g.map(jr,jq);ju=b.ofSeq(jt);ju.dims=2;return ju;}},Html:{Client:{Activator:{Activate:$.Field(function(){var jv,jw;if(A.hasDocument()){jw=B.getElementById("websharper-data");jv=jw?C(B).ready(function(){var jy,jz,jA,jB;jy=jw.getAttribute("content");jz=D.Activate(E.parse(jy));jA=G.GetFields(jz);jB=$.Tupled(function(jC){var jD,jE,jF,jG;jD=jC[0];jE=jC[1];jF=jE.get_Body();jG=B.getElementById(jD);return jF.ReplaceInDom(jG);});return b.iter(jB,jA);}):null;}else{jv=null;}return jv;}),hasDocument:function(){var $0=this,$this=this;return typeof $$.document!=="undefined";}},HtmlContentExtensions:{"IControlBody.SingleNode.Static":function(jH){return I.New(jH);},SingleNode:$.Class({ReplaceInDom:function(jI){var jJ;jJ=this.node.parentNode.replaceChild(this.node,jI);return;}},{New:function(jK){var jL;jL=$.New(this,{});jL.node=jK;return jL;}})}}},IntrinsicFunctionProxy:{Array2DZeroCreate:function(jM,jN){var jO;jO=b.init(jM,function(){return f(jN);});jO.dims=2;return jO;},BoundsCheck:function(jQ,jR){return(jR<0?true:jR>=e.GetLength(jQ))?c.Raise(new t("IndexOutOfRangeException")):null;},BoundsCheck2D:function(jS,jT,jU){return(((jT<0?true:jU<0)?true:jT>=jS.length)?true:jU>=(jS.length?jS[0].length:0))?c.Raise(new t("IndexOutOfRangeException")):null;},GetArray:function(jV,jW){e.BoundsCheck(jV,jW);return jV[jW];},GetArray2D:function(jX,jY,jZ){e.BoundsCheck2D(jX,jY,jZ);return jX[jY][jZ];},GetArray2DSub:function(j0,j1,j2,j3,j4){var j5,j6,j7,j8,j9;j5=j3<0?0:j3;j6=j4<0?0:j4;j7=e.Array2DZeroCreate(j5,j6);for(j8=0;j8<=j5-1;j8++){for(j9=0;j9<=j6-1;j9++){e.SetArray2D(j7,j8,j9,e.GetArray2D(j0,j1+j8,j2+j9));}}return j7;},GetArraySub:function(j_,j$,ka){var kb,kc;kb=f(ka);for(kc=0;kc<=ka-1;kc++){e.SetArray(kb,kc,e.GetArray(j_,j$+1));}return kb;},GetLength:function(kd){var ke;ke=kd.dims;return ke===2?kd.length*kd.length:kd.length;},SetArray:function(kf,kg,kh){e.BoundsCheck(kf,kg);kf[kg]=kh;return;},SetArray2D:function(ki,kj,kk,kl){e.BoundsCheck2D(ki,kj,kk);ki[kj][kk]=kl;return;},SetArray2DSub:function(km,kn,ko,kp,kq,kr){var ks,kt;for(ks=0;ks<=kp-1;ks++){for(kt=0;kt<=kq-1;kt++){e.SetArray2D(km,kn+ks,ko+kt,e.GetArray2D(kr,ks,kt));}}return;},SetArraySub:function(ku,kv,kw,kx){var ky;for(ky=0;ky<=kw-1;ky++){e.SetArray(ku,kv+ky,e.GetArray(kx,ky));}return;}},JavaScript:{JS:{Delete:function($x,$field){var $0=this,$this=this;return delete $x[$field];},ForEach:function($x,$iter){var $0=this,$this=this;for(var k in $x){if($iter(k))break;}},GetFieldNames:function($o){var $0=this,$this=this;var r=[];for(var k in $o)r.push(k);return r;},GetFieldValues:function($o){var $0=this,$this=this;var r=[];for(var k in $o)r.push($o[k]);return r;},GetFields:function($o){var $0=this,$this=this;var r=[];for(var k in $o)r.push([k,$o[k]]);return r;},Log:function($x){var $0=this,$this=this;if($$.console)$$.console.log($x);},LogMore:function($args){var $0=this,$this=this;if($$.console)$$.console.log.apply($$.console,$args);}},Pervasives:{NewFromList:function(kz){var kA,kB,kC,kD,kE;kA={};kB=i.Get(kz);while(kB.MoveNext()){kC=kB.get_Current();kD=kC[1];kE=kC[0];kA[kE]=kD;}return kA;}}},Json:{Activate:function(kF){var kG,kH,kI;kG=kF.$TYPES;for(kH=0;kH<=e.GetLength(kG)-1;kH++){e.SetArray(kG,kH,D.lookup(e.GetArray(kG,kH)));}kI=function(kJ){var kK,kL,kM,kN,kO,kP;if(h.Equals(kJ,null)){kK=kJ;}else{kL=typeof kJ;if(kL==="object"){if(kJ instanceof $$.Array){kN=D.shallowMap(kI,kJ);}else{kO=D.shallowMap(kI,kJ.$V);kP=kJ.$T;kN=h.Equals(typeof kP,"undefined")?kO:D.restore(e.GetArray(kG,kP),kO);}kM=kN;}else{kM=kJ;}kK=kM;}return kK;};return kI(kF.$DATA);},lookup:function(kQ){var kR,kS,kT,kU,kV,kW;kR=e.GetLength(kQ);kS=$$;kT=0;while(kT<kR){kU=e.GetArray(kQ,kT);kV=kS[kU];if(!h.Equals(typeof kV,undefined)){kS=kV;kW=kT=kT+1;}else{kW=c.FailWith("Invalid server reply. Failed to find type: "+kU);}}return kS;},restore:function(kX,kY){var kZ;kZ=new kX();G.ForEach(kY,function(k0){kZ[k0]=kY[k0];return false;});return kZ;},shallowMap:function(k1,k2){var k3,k4,k5,k6;if(k2 instanceof $$.Array){k3=b.map(k1,k2);}else{k4=typeof k2;if(k4==="object"){k6={};G.ForEach(k2,function(k7){k6[k7]=k1(k2[k7]);return false;});k5=k6;}else{k5=k2;}k3=k5;}return k3;}},Lazy:{Create:function(k8){var k9,k_;k9={value:undefined,created:false,eval:k8};k_=function(){var la;if(k9.created){la=k9.value;}else{k9.created=true;k9.value=k8(null);la=k9.value;}return la;};k9.eval=k_;return k9;},CreateFromValue:function(lb){return{value:lb,created:true,eval:function(){return lb;},eval:function(){return lb;}};},Force:function(le){return le.eval.call(null,null);}},List:{T:$.Class({GetEnumerator:function(){var lf;lf=function(lg){var lh,li,lj,lk;lh=lg.s;if(lh.$==0){li=false;}else{lj=lh.$1;lk=lh.$0;lg.c=lk;lg.s=lj;li=true;}return li;};return x.New(this,null,lf);},get_Item:function(ll){return g.nth(ll,this);},get_Length:function(){return g.length(this);}},{Construct:function(lm,ln){return $.New(K,{$:1,$0:lm,$1:ln});},get_Nil:function(){return $.New(K,{$:0});}}),append:function(lo,lp){return J.ofSeq(g.append(lo,lp));},choose:function(lq,lr){return J.ofSeq(g.choose(lq,lr));},collect:function(ls,lt){return J.ofSeq(g.collect(ls,lt));},concat:function(lu){return J.ofSeq(g.concat(lu));},exists2:function(lv,lw,lx){return b.exists2(lv,b.ofSeq(lw),b.ofSeq(lx));},filter:function(ly,lz){return J.ofSeq(g.filter(ly,lz));},fold2:function(lA,lB,lC,lD){return b.fold2(lA,lB,b.ofSeq(lC),b.ofSeq(lD));},foldBack:function(lE,lF,lG){return b.foldBack(lE,b.ofSeq(lF),lG);},foldBack2:function(lH,lI,lJ,lK){return b.foldBack2(lH,b.ofSeq(lI),b.ofSeq(lJ),lK);},forall2:function(lL,lM,lN){return b.forall2(lL,b.ofSeq(lM),b.ofSeq(lN));},head:function(lO){var lP,lQ;if(lO.$==1){lQ=lO.$0;lP=lQ;}else{lP=c.FailWith("The input list was empty.");}return lP;},init:function(lR,lS){return J.ofArray(b.init(lR,lS));},iter2:function(lT,lU,lV){return b.iter2(lT,b.ofSeq(lU),b.ofSeq(lV));},iteri2:function(lW,lX,lY){return b.iteri2(lW,b.ofSeq(lX),b.ofSeq(lY));},map:function(lZ,l0){return J.ofSeq(g.map(lZ,l0));},map2:function(l1,l2,l3){return J.ofArray(b.map2(l1,b.ofSeq(l2),b.ofSeq(l3)));},map3:function(l4,l5,l6,l7){var l8;l8=b.map2(function(l9){return function(l_){return l9(l_);};},b.map2(l4,b.ofSeq(l5),b.ofSeq(l6)),b.ofSeq(l7));return J.ofArray(l8);},mapi:function(l$,ma){return J.ofSeq(g.mapi(l$,ma));},mapi2:function(mb,mc,md){return J.ofArray(b.mapi2(mb,b.ofSeq(mc),b.ofSeq(md)));},max:function(me){return g.reduce(function(mf){return function(mg){return c.Max(mf,mg);};},me);},maxBy:function(mh,mi){return g.reduce(function(mj){return function(mk){return h.Compare(mh(mj),mh(mk))===1?mj:mk;};},mi);},min:function(ml){return g.reduce(function(mm){return function(mn){return c.Min(mm,mn);};},ml);},minBy:function(mo,mp){return g.reduce(function(mq){return function(mr){return h.Compare(mo(mq),mo(mr))===-1?mq:mr;};},mp);},ofArray:function(ms){var mt,mu;mt=$.New(K,{$:0});for(mu=0;mu<=e.GetLength(ms)-1;mu++){mt=$.New(K,{$:1,$0:e.GetArray(ms,e.GetLength(ms)-mu-1),$1:mt});}return mt;},ofSeq:function(mv){var mw,mx,my;mw=[];mx=i.Get(mv);while(mx.MoveNext()){mw.unshift(mx.get_Current());}my=mw.slice(0);my.reverse();return J.ofArray(my);},partition:function(mz,mA){var mB,mC,mD;mB=b.partition(mz,b.ofSeq(mA));mC=mB[1];mD=mB[0];return[J.ofArray(mD),J.ofArray(mC)];},permute:function(mE,mF){return J.ofArray(b.permute(mE,b.ofSeq(mF)));},reduceBack:function(mG,mH){return b.reduceBack(mG,b.ofSeq(mH));},replicate:function(mI,mJ){return J.ofArray(b.create(mI,mJ));},rev:function(mK){var mL;mL=b.ofSeq(mK);mL.reverse();return J.ofArray(mL);},scan:function(mM,mN,mO){return J.ofSeq(g.scan(mM,mN,mO));},scanBack:function(mP,mQ,mR){return J.ofArray(b.scanBack(mP,b.ofSeq(mQ),mR));},sort:function(mS){var mT;mT=b.ofSeq(mS);b.sortInPlace(mT);return J.ofArray(mT);},sortBy:function(mU,mV){return J.sortWith(function(mW){return function(mX){return c.Compare(mU(mW),mU(mX));};},mV);},sortWith:function(mY,mZ){var m0;m0=b.ofSeq(mZ);b.sortInPlaceWith(mY,m0);return J.ofArray(m0);},tail:function(m1){var m2,m3;if(m1.$==1){m3=m1.$1;m2=m3;}else{m2=c.FailWith("The input list was empty.");}return m2;},unzip:function(m4){var m5,m6,m7,m8,m9,m_;m5=[];m6=[];m7=i.Get(m4);while(m7.MoveNext()){m8=m7.get_Current();m9=m8[1];m_=m8[0];m5.push(m_);m6.push(m9);}return[J.ofArray(m5.slice(0)),J.ofArray(m6.slice(0))];},unzip3:function(m$){var na,nb,nc,nd,ne,nf,ng,nh;na=[];nb=[];nc=[];nd=i.Get(m$);while(nd.MoveNext()){ne=nd.get_Current();nf=ne[2];ng=ne[1];nh=ne[0];na.push(nh);nb.push(ng);nc.push(nf);}return[J.ofArray(na.slice(0)),J.ofArray(nb.slice(0)),J.ofArray(nc.slice(0))];},zip:function(ni,nj){return J.ofArray(b.zip(b.ofSeq(ni),b.ofSeq(nj)));},zip3:function(nk,nl,nm){return J.ofArray(b.zip3(b.ofSeq(nk),b.ofSeq(nl),b.ofSeq(nm)));}},OperatorIntrinsics:{GetArraySlice:function(nn,no,np){var nq,nr,ns,nt,nu,nv,nw,nx;nq=[no,np];if(nq[0].$==0){if(nq[1].$==1){nt=nq[1].$0;ns=nn.slice(0,nt+1);}else{ns=[];}nr=ns;}else{if(nq[1].$==0){nv=nq[0].$0;nu=nn.slice(nv);}else{nw=nq[1].$0;nx=nq[0].$0;nu=nn.slice(nx,nw+1);}nr=nu;}return nr;},GetArraySlice2D:function(ny,nz,nA,nB,nC){var nD,nE,nF,nG,nH,nI,nJ,nK,nL,nM,nN,nO,nP,nQ;if(nz.$==1){nF=nz.$0;nE=nF;}else{nE=0;}nD=nE;if(nB.$==1){nI=nB.$0;nH=nI;}else{nH=0;}nG=nH;if(nA.$==1){nL=nA.$0;nK=nL;}else{nK=ny.length-1;}nJ=nK;if(nC.$==1){nO=nC.$0;nN=nO;}else{nN=(ny.length?ny[0].length:0)-1;}nM=nN;nP=nJ-nD+1;nQ=nM-nG+1;return e.GetArray2DSub(ny,nD,nG,nP,nQ);},GetArraySlice2DFixed1:function(nR,nS,nT,nU){var nV,nW,nX,nY,nZ,n0,n1,n2,n3;if(nT.$==1){nX=nT.$0;nW=nX;}else{nW=0;}nV=nW;if(nU.$==1){n0=nU.$0;nZ=n0;}else{nZ=(nR.length?nR[0].length:0)-1;}nY=nZ;n1=nY-nV+1;n2=f(n1);for(n3=0;n3<=n1-1;n3++){e.SetArray(n2,n3,e.GetArray2D(nR,nS,nV+n3));}return n2;},GetArraySlice2DFixed2:function(n4,n5,n6,n7){var n8,n9,n_,n$,oa,ob,oc,od,oe;if(n5.$==1){n_=n5.$0;n9=n_;}else{n9=0;}n8=n9;if(n6.$==1){ob=n6.$0;oa=ob;}else{oa=n4.length-1;}n$=oa;oc=n$-n8+1;od=f(oc);for(oe=0;oe<=oc-1;oe++){e.SetArray(od,oe,e.GetArray2D(n4,n8+oe,n7));}return od;},GetStringSlice:function(of,og,oh){var oi,oj,ok,ol,om,on,oo,op;oi=[og,oh];if(oi[0].$==0){if(oi[1].$==1){ol=oi[1].$0;ok=of.slice(0,ol+1);}else{ok="";}oj=ok;}else{if(oi[1].$==0){on=oi[0].$0;om=of.slice(on);}else{oo=oi[1].$0;op=oi[0].$0;om=of.slice(op,oo+1);}oj=om;}return oj;},SetArraySlice:function(oq,or,os,ot){var ou,ov,ow,ox,oy,oz;if(or.$==1){ow=or.$0;ov=ow;}else{ov=0;}ou=ov;if(os.$==1){oz=os.$0;oy=oz;}else{oy=e.GetLength(oq)-1;}ox=oy;return e.SetArraySub(oq,ou,ox-ou+1,ot);},SetArraySlice2D:function(oA,oB,oC,oD,oE,oF){var oG,oH,oI,oJ,oK,oL,oM,oN,oO,oP,oQ,oR;if(oB.$==1){oI=oB.$0;oH=oI;}else{oH=0;}oG=oH;if(oD.$==1){oL=oD.$0;oK=oL;}else{oK=0;}oJ=oK;if(oC.$==1){oO=oC.$0;oN=oO;}else{oN=oA.length-1;}oM=oN;if(oE.$==1){oR=oE.$0;oQ=oR;}else{oQ=(oA.length?oA[0].length:0)-1;}oP=oQ;return e.SetArray2DSub(oA,oG,oJ,oM-oG+1,oP-oJ+1,oF);},SetArraySlice2DFixed1:function(oS,oT,oU,oV,oW){var oX,oY,oZ,o0,o1,o2,o3,o4;if(oU.$==1){oZ=oU.$0;oY=oZ;}else{oY=0;}oX=oY;if(oV.$==1){o2=oV.$0;o1=o2;}else{o1=(oS.length?oS[0].length:0)-1;}o0=o1;o3=o0-oX+1;for(o4=0;o4<=o3-1;o4++){e.SetArray2D(oS,oT,oX+o4,e.GetArray(oW,o4));}return;},SetArraySlice2DFixed2:function(o5,o6,o7,o8,o9){var o_,o$,pa,pb,pc,pd,pe,pf;if(o6.$==1){pa=o6.$0;o$=pa;}else{o$=0;}o_=o$;if(o7.$==1){pd=o7.$0;pc=pd;}else{pc=o5.length-1;}pb=pc;pe=pb-o_+1;for(pf=0;pf<=pe-1;pf++){e.SetArray2D(o5,o_+pf,o8,e.GetArray(o9,pf));}return;}},Operators:{Compare:function(pg,ph){return h.Compare(pg,ph);},Decrement:function(pi){pi.contents=pi.contents-1;},DefaultArg:function(pj,pk){var pl,pm;if(pj.$==0){pl=pk;}else{pm=pj.$0;pl=pm;}return pl;},FailWith:function(pn){return c.Raise(new t(pn));},Increment:function(po){po.contents=po.contents+1;},KeyValue:function(pp){return[pp.K,pp.V];},Max:function(pq,pr){return h.Compare(pq,pr)===1?pq:pr;},Min:function(ps,pt){return h.Compare(ps,pt)===-1?ps:pt;},Pown:function(pu,pv){var pw;pw=function(px){var py,pz,pA;if(px===1){py=pu;}else{if(px%2===0){pA=pw(px/2>>0);pz=pA*pA;}else{pz=pu*pw(px-1);}py=pz;}return py;};return pw(pv);},Raise:function($e){var $0=this,$this=this;throw $e;},Sign:function(pB){return pB===0?0:pB<0?-1:1;},Truncate:function(pC){return pC<0?L.ceil(pC):L.floor(pC);},Using:function(pD,pE){var pF;try{pF=pE(pD);}finally{pD.Dispose();}return pF;},range:function(pG,pH){return g.init(1+pH-pG,function(pI){return pI+pG;});},step:function(pJ,pK,pL){var pM,pN,pP,pR;pM=c.Sign(pK);pN=function(pO){return pM*(pL-pO)>=0;};pP=g.initInfinite(function(pQ){return pJ+pQ*pK;});pR=g.takeWhile(pN,pP);return pR;}},Option:{bind:function(pS,pT){var pU,pV;if(pT.$==0){pU={$:0};}else{pV=pT.$0;pU=pS(pV);}return pU;},exists:function(pW,pX){var pY,pZ;if(pX.$==0){pY=false;}else{pZ=pX.$0;pY=pW(pZ);}return pY;},fold:function(p0,p1,p2){var p3,p4;if(p2.$==0){p3=p1;}else{p4=p2.$0;p3=(p0(p1))(p4);}return p3;},foldBack:function(p5,p6,p7){var p8,p9;if(p6.$==0){p8=p7;}else{p9=p6.$0;p8=(p5(p9))(p7);}return p8;},forall:function(p_,p$){var qa,qb;if(p$.$==0){qa=true;}else{qb=p$.$0;qa=p_(qb);}return qa;},iter:function(qc,qd){var qe,qf;if(qd.$==0){qe=null;}else{qf=qd.$0;qe=qc(qf);}return qe;},map:function(qg,qh){var qi,qj;if(qh.$==0){qi={$:0};}else{qj=qh.$0;qi={$:1,$0:qg(qj)};}return qi;},toArray:function(qk){var ql,qm;if(qk.$==0){ql=[];}else{qm=qk.$0;ql=[qm];}return ql;},toList:function(qn){var qo,qp;if(qn.$==0){qo=$.New(K,{$:0});}else{qp=qn.$0;qo=J.ofArray([qp]);}return qo;}},PrintfHelpers:{padNumLeft:function(qq,qr){var qs,qt,qu,qv;qs=e.GetArray(qq,0);if((qs===" "?true:qs==="+")?true:qs==="-"){qu=qq.substr(1);qv=qr-1;qt=qs+M.PadLeftWith(qu,qv,48);}else{qt=M.PadLeftWith(qq,qr,48);}return qt;},plusForPos:function(qw,qx){return 0<=qw?"+"+qx:qx;},plusForPos0:function(qy,qz){return 0<=qy?"+"+qz:qz;},prettyPrint:function(qB){var qC,qM,qN,qO,qP,qQ,qS;qC=function(qD){var qE,qF,qG,qH,qL;qE=$$.String(qD);if(qE==="[object Object]"){qG=G.GetFields(qD);qH=$.Tupled(function(qI){var qJ,qK;qJ=qI[0];qK=qI[1];return qJ+" = "+N.prettyPrint(qK);});qL=b.map(qH,qG);qF="{"+M.concat("; ",qL)+"}";}else{qF=qE;}return qF;};qM=typeof qB;if(qM=="string"){qN="\""+qB+"\"";}else{if(qM=="object"){if(qB instanceof $$.Array){qQ=function(qR){return N.prettyPrint(qR);};qS=b.map(qQ,qB);qP="[|"+M.concat("; ",qS)+"|]";}else{qP=qC(qB);}qO=qP;}else{qO=$$.String(qB);}qN=qO;}return qN;},printArray:function(qT,qU){var qV;qV=b.map(qT,qU);return"[|"+M.concat("; ",qV)+"|]";},printArray2D:function(qW,qX){var qY;qY=g.delay(function(){var q0;q0=qX.length?qX[0].length:0;return g.map(function(q1){var q2;q2=g.delay(function(){return g.map(function(q4){return qW(e.GetArray2D(qX,q1,q4));},c.range(0,q0-1));});return M.concat("; ",q2);},c.range(0,qX.length-1));});return"[["+M.concat("][",qY)+"]]";},printList:function(q5,q6){var q7;q7=g.map(q5,q6);return"["+M.concat("; ",q7)+"]";},spaceForPos:function(q8,q9){return 0<=q8?" "+q9:q9;},toSafe:function(q_){return q_==null?"":q_;}},Queue:{Clear:function(q$){return q$.splice(0,e.GetLength(q$));},Contains:function(ra,rb){return g.exists(function(rc){return h.Equals(rb,rc);},ra);},CopyTo:function(rd,re,rf){return b.blit(rd,0,re,rf,e.GetLength(rd));}},Remoting:{AjaxProvider:$.Field(function(){return P.New();}),Async:function(rg,rh){var ri,rj,rk;ri=O.makeHeaders(rg);rj=O.makePayload(rh);rk=function(){var rm,rn;rm=Q.get_CancellationToken();rn=function(ro){var rp,rH;rp=$.Tupled(function(rq){var rr,rs,rt,ru,rv,ry,rA,rD,rG;rr=rq[0];rs=rq[1];rt=rq[2];ru={contents:true};rv=function(){var rx;if(ru.contents){ru.contents=false;rx=rt(new t("OperationCanceledException"));}else{rx=null;}return rx;};ry=k.Register(ro,function(){return rv();});rA=function(rB){var rC;if(ru.contents){ru.contents=false;ry.Dispose();rC=rr(D.Activate(E.parse(rB)));}else{rC=null;}return rC;};rD=function(rE){var rF;if(ru.contents){ru.contents=false;ry.Dispose();rF=rs(rE);}else{rF=null;}return rF;};rG=O.EndPoint();return O.AjaxProvider().Async(rG,ri,rj,rA,rD);});rH=k.FromContinuations(rp);return rH;};return k.Bind(rm,rn);};return k.Delay(rk);},Call:function(rI,rJ){var rK,rL,rM,rN;rK=O.EndPoint();rL=O.makeHeaders(rI);rM=O.makePayload(rJ);rN=O.AjaxProvider().Sync(rK,rL,rM);return D.Activate(E.parse(rN));},EndPoint:$.Field(function(){return"?";}),Send:function(rO,rP){var rQ,rR,rS;rQ=O.Async(rO,rP);rR=k.Ignore(rQ);rS={$:0};return k.Start(rR,rS);},XhrProvider:$.Class({Async:function(rT,rU,rV,rW,rX){return O.ajax(true,rT,rU,rV,rW,rX);},Sync:function(rY,rZ,r0){var r1;r1={contents:undefined};O.ajax(false,rY,rZ,r0,function(r2){r1.contents=r2;},function(r3){return c.Raise(r3);});return r1.contents;}},{New:function(){return $.New(this,{});}}),ajax:function($async,$url,$headers,$data,$ok,$err){var $0=this,$this=this;var xhr=new $$.XMLHttpRequest();xhr.open("POST",$url,$async);for(var h in $headers){xhr.setRequestHeader(h,$headers[h]);}function k(){if(xhr.status==200){$ok(xhr.responseText);}else{var msg="Response status is not 200: ";$err(new $$.Error(msg+xhr.status));}}if("onload"in xhr){xhr.onload=xhr.onerror=xhr.onabort=k;}else{xhr.onreadystatechange=function(){if(xhr.readyState==4){k();}};}xhr.send($data);},makeHeaders:function(r4){var r5;r5={};r5["content-type"]="application/json";r5["x-websharper-rpc"]=r4;return r5;},makePayload:function(r6){return E.stringify(r6);}},Seq:{append:function(r7,r8){return R.Of(function(){var r_,r$;r_=i.Get(r7);r$=function(sa){var sb,sc,sd,se,sf,sg;if(sa.s.MoveNext()){sc=sa.s.get_Current();sa.c=sc;sb=true;}else{if(sa.s===r_){se=i.Get(r8);sa.s=se;if(se.MoveNext()){sg=se.get_Current();sa.c=sg;sf=true;}else{sf=false;}sd=sf;}else{sd=false;}sb=sd;}return sb;};return x.New(r_,null,r$);});},average:function(sh){var si,sn,so;si=g.fold($.Tupled(function(sj){var sk,sl;sk=sj[0];sl=sj[1];return function(sm){return[sk+1,sl+sm];};}),[0,0],sh);sn=si[1];so=si[0];return sn/so;},averageBy:function(sp,sq){var sr,sw,sx;sr=g.fold($.Tupled(function(ss){var st,su;st=ss[0];su=ss[1];return function(sv){return[st+1,su+sp(sv)];};}),[0,0],sq);sw=sr[1];sx=sr[0];return sw/sx;},cache:function(sy){var sz,sA,sB;sz=[];sA=i.Get(sy);sB=function(){var sD;sD=function(sE){var sF,sG,sH,sI,sJ,sK;if(sE.s+1<sz.length){sG=sE.s+1;sE.s=sG;sH=sz[sE.s];sE.c=sH;sF=true;}else{if(sA.MoveNext()){sJ=sE.s+1;sE.s=sJ;sK=sA.get_Current();sE.c=sK;sz.push(sE.get_Current());sI=true;}else{sI=false;}sF=sI;}return sF;};return x.New(0,null,sD);};return R.Of(sB);},choose:function(sL,sM){var sN;sN=function(sO){var sP,sQ,sR;sP=sL(sO);if(sP.$==0){sQ=$.New(K,{$:0});}else{sR=sP.$0;sQ=J.ofArray([sR]);}return sQ;};return g.collect(sN,sM);},collect:function(sS,sT){return g.concat(g.map(sS,sT));},compareWith:function(sU,sV,sW){var sX,sY,sZ,s0,s1;sX=i.Get(sV);sY=i.Get(sW);sZ=0;s0=true;while(s0?sZ===0:false){s1=[sX.MoveNext(),sY.MoveNext()];s1[0]?s1[1]?sZ=(sU(sX.get_Current()))(sY.get_Current()):sZ=1:s1[1]?sZ=-1:s0=false;}return sZ;},concat:function(s2){return R.Of(function(){var s4,s5;s4=i.Get(s2);s5=function(s6){var s7,s8,s9,s_,s$,ta;s7=s6.s;if(h.Equals(s7,null)){if(s4.MoveNext()){s_=i.Get(s4.get_Current());s6.s=s_;s9=s5(s6);}else{s9=false;}s8=s9;}else{if(s7.MoveNext()){ta=s7.get_Current();s6.c=ta;s$=true;}else{s6.s=null;s$=s5(s6);}s8=s$;}return s8;};return x.New(null,null,s5);});},countBy:function(tb,tc){var td;td=function(){var tf,tg,th,ti,tj,tk,tl,tn,to;tf={};tg=i.Get(tc);th=[];while(tg.MoveNext()){ti=tb(tg.get_Current());tj=h.Hash(ti);if(tf.hasOwnProperty(tj)){tk=void(tf[tj]=tf[tj]+1);}else{th.push(ti);tk=void(tf[tj]=1);}}tl=function(tm){return[tm,tf[h.Hash(tm)]];};tn=th.slice(0);to=b.map(tl,tn);return to;};return g.delay(td);},delay:function(tp){return R.Of(function(){return i.Get(tp(null));});},distinct:function(tr){return g.distinctBy(function(ts){return ts;},tr);},distinctBy:function(tt,tu){var tv;tv=function(){var tx,ty,tz;tx=i.Get(tu);ty={};tz=function(tA){var tB,tC,tD,tG,tI,tJ,tK;if(tx.MoveNext()){tC=tx.get_Current();tD=function(tE){var tF;tF=tt(tE);return h.Hash(tF);};tG=function(tH){return ty.hasOwnProperty(tD(tH));};tI=tG(tC);while(tI?tx.MoveNext():false){tC=tx.get_Current();tI=tG(tC);}if(tI){tJ=false;}else{ty[tD(tC)]=null;tK=tC;tA.c=tK;tJ=true;}tB=tJ;}else{tB=false;}return tB;};return x.New(null,null,tz);};return R.Of(tv);},empty:function(){return[];},enumFinally:function(tL,tM){return R.Of(function(){var tO,tP,tQ,tR;try{tP=i.Get(tL);}catch(tQ){tM(null);tP=c.Raise(tQ);}tO=tP;tR=function(tS){var tT,tU,tV,tW;try{if(tO.MoveNext()){tV=tO.get_Current();tS.c=tV;tU=true;}else{tM(null);tU=false;}tT=tU;}catch(tW){tM(null);tT=c.Raise(tW);}return tT;};return x.New(null,null,tR);});},enumUsing:function(tX,tY){return tY(tX);},enumWhile:function(tZ,t0){return R.Of(function(){var t2,ua;t2=function(t3){var t4,t5,t6,t7,t8,t9,t_,t$;t4=t3.s;if(t4.$==1){t6=t4.$0;if(t6.MoveNext()){t8=t6.get_Current();t3.c=t8;t7=true;}else{t9={$:0};t3.s=t9;t7=t2(t3);}t5=t7;}else{if(tZ(null)){t$={$:1,$0:i.Get(t0)};t3.s=t$;t_=t2(t3);}else{t_=false;}t5=t_;}return t5;};ua={$:0};return x.New(ua,null,t2);});},exists:function(ub,uc){var ud,ue;ud=i.Get(uc);ue=false;while(!ue?ud.MoveNext():false){ue=ub(ud.get_Current());}return ue;},exists2:function(uf,ug,uh){var ui,uj,uk;ui=i.Get(ug);uj=i.Get(uh);uk=false;while((!uk?ui.MoveNext():false)?uj.MoveNext():false){uk=(uf(ui.get_Current()))(uj.get_Current());}return uk;},filter:function(ul,um){var un;un=function(){var up,uq;up=i.Get(um);uq=function(ur){var us,ut,uu,uv,uw;us=up.MoveNext();ut=up.get_Current();uu=false;while(us){if(ul(ut)){uw=ut;ur.c=uw;uu=true;uv=us=false;}else{uv=up.MoveNext()?ut=up.get_Current():us=false;}}return uu;};return x.New(null,null,uq);};return R.Of(un);},find:function(ux,uy){var uz,uA,uB;uz=g.tryFind(ux,uy);if(uz.$==0){uA=c.FailWith("KeyNotFoundException");}else{uB=uz.$0;uA=uB;}return uA;},findIndex:function(uC,uD){var uE,uF,uG;uE=g.tryFindIndex(uC,uD);if(uE.$==0){uF=c.FailWith("KeyNotFoundException");}else{uG=uE.$0;uF=uG;}return uF;},fold:function(uH,uI,uJ){var uK,uL;uK=uI;uL=i.Get(uJ);while(uL.MoveNext()){uK=(uH(uK))(uL.get_Current());}return uK;},forall:function(uM,uN){return!g.exists(function(uO){return!uM(uO);},uN);},forall2:function(uP,uQ,uR){return!g.exists2(function(uS){return function(uT){return!(uP(uS))(uT);};},uQ,uR);},groupBy:function(uU,uV){return g.delay(function(){var uX,uY,uZ,u0,u1,u2,u3;uX={};uY={};uZ=[];u0=i.Get(uV);while(u0.MoveNext()){u1=u0.get_Current();u2=uU(u1);u3=h.Hash(u2);!uX.hasOwnProperty(u3)?uZ.push(u2):null;uY[u3]=u2;uX.hasOwnProperty(u3)?uX[u3].push(u1):void(uX[u3]=[u1]);}return b.map(function(u4){return[u4,uX[h.Hash(u4)]];},uZ);});},head:function(u5){var u6;u6=i.Get(u5);return u6.MoveNext()?u6.get_Current():g.insufficient();},init:function(u7,u8){return g.take(u7,g.initInfinite(u8));},initInfinite:function(u9){var u_;u_=function(){var va;va=function(vb){var vc,vd;vc=u9(vb.s);vb.c=vc;vd=vb.s+1;vb.s=vd;return true;};return x.New(0,null,va);};return R.Of(u_);},insufficient:function(){return c.FailWith("The input sequence has an insufficient number of elements.");},isEmpty:function(ve){var vf;vf=i.Get(ve);return!vf.MoveNext();},iter:function(vg,vh){return g.iteri(function(){return function(vj){return vg(vj);};},vh);},iter2:function(vk,vl,vm){var vn,vo;vn=i.Get(vl);vo=i.Get(vm);while(vn.MoveNext()?vo.MoveNext():false){(vk(vn.get_Current()))(vo.get_Current());}return;},iteri:function(vp,vq){var vr,vs;vr=0;vs=i.Get(vq);while(vs.MoveNext()){(vp(vr))(vs.get_Current());vr=vr+1;}return;},length:function(vt){var vu,vv;vu=0;vv=i.Get(vt);while(vv.MoveNext()){vu=vu+1;}return vu;},map:function(vw,vx){var vy;vy=function(){var vA,vB;vA=i.Get(vx);vB=function(vC){var vD,vE;if(vA.MoveNext()){vE=vw(vA.get_Current());vC.c=vE;vD=true;}else{vD=false;}return vD;};return x.New(null,null,vB);};return R.Of(vy);},mapi:function(vF,vG){return g.mapi2(vF,g.initInfinite(function(vH){return vH;}),vG);},mapi2:function(vI,vJ,vK){var vL;vL=function(){var vN,vO,vP;vN=i.Get(vJ);vO=i.Get(vK);vP=function(vQ){var vR,vS;if(vN.MoveNext()?vO.MoveNext():false){vS=(vI(vN.get_Current()))(vO.get_Current());vQ.c=vS;vR=true;}else{vR=false;}return vR;};return x.New(null,null,vP);};return R.Of(vL);},max:function(vT){return g.reduce(function(vU){return function(vV){return h.Compare(vU,vV)>=0?vU:vV;};},vT);},maxBy:function(vW,vX){return g.reduce(function(vY){return function(vZ){return h.Compare(vW(vY),vW(vZ))>=0?vY:vZ;};},vX);},min:function(v0){return g.reduce(function(v1){return function(v2){return h.Compare(v1,v2)<=0?v1:v2;};},v0);},minBy:function(v3,v4){return g.reduce(function(v5){return function(v6){return h.Compare(v3(v5),v3(v6))<=0?v5:v6;};},v4);},nth:function(v7,v8){var v9,v_;v7<0?c.FailWith("negative index requested"):null;v9=-1;v_=i.Get(v8);while(v9<v7){!v_.MoveNext()?g.insufficient():null;v9=v9+1;}return v_.get_Current();},pairwise:function(v$){var wa,wc;wa=function(wb){return[e.GetArray(wb,0),e.GetArray(wb,1)];};wc=g.windowed(2,v$);return g.map(wa,wc);},pick:function(wd,we){var wf,wg,wh;wf=g.tryPick(wd,we);if(wf.$==0){wg=c.FailWith("KeyNotFoundException");}else{wh=wf.$0;wg=wh;}return wg;},readOnly:function(wi){return R.Of(function(){return i.Get(wi);});},reduce:function(wk,wl){var wm,wn;wm=i.Get(wl);!wm.MoveNext()?c.FailWith("The input sequence was empty"):null;wn=wm.get_Current();while(wm.MoveNext()){wn=(wk(wn))(wm.get_Current());}return wn;},scan:function(wo,wp,wq){var wr;wr=function(){var wt,wu;wt=i.Get(wq);wu=function(wv){var ww,wx,wy;if(wv.s){if(wt.MoveNext()){wy=(wo(wv.get_Current()))(wt.get_Current());wv.c=wy;wx=true;}else{wx=false;}ww=wx;}else{wv.c=wp;wv.s=true;ww=true;}return ww;};return x.New(false,null,wu);};return R.Of(wr);},skip:function(wz,wA){return R.Of(function(){var wC,wD;wC=i.Get(wA);for(wD=1;wD<=wz;wD++){!wC.MoveNext()?g.insufficient():null;}return wC;});},skipWhile:function(wE,wF){return R.Of(function(){var wH,wI,wJ,wK,wL;wH=i.Get(wF);wI=true;while(wH.MoveNext()?wE(wH.get_Current()):false){wI=false;}if(wI){wK=g.empty();wJ=i.Get(wK);}else{wL=function(wM){var wN,wO,wP,wQ;if(wM.s){wM.s=false;wO=wH.get_Current();wM.c=wO;wN=true;}else{wP=wH.MoveNext();wQ=wH.get_Current();wM.c=wQ;wN=wP;}return wN;};wJ=x.New(true,null,wL);}return wJ;});},sort:function(wR){return g.sortBy(function(wS){return wS;},wR);},sortBy:function(wT,wU){return g.delay(function(){var wW;wW=b.ofSeq(wU);b.sortInPlaceBy(wT,wW);return wW;});},sum:function(wX){return g.fold(function(wY){return function(wZ){return wY+wZ;};},0,wX);},sumBy:function(w0,w1){return g.fold(function(w2){return function(w3){return w2+w0(w3);};},0,w1);},take:function(w4,w5){return R.Of(function(){var w7,w8;w7=i.Get(w5);w8=function(w9){var w_,w$,xa,xb;if(w9.s>=w4){w_=false;}else{if(w7.MoveNext()){xa=w9.s+1;w9.s=xa;xb=w7.get_Current();w9.c=xb;w$=true;}else{w7.Dispose();w9.s=w4;w$=false;}w_=w$;}return w_;};return x.New(0,null,w8);});},takeWhile:function(xc,xd){return g.delay(function(){return g.enumUsing(i.Get(xd),function(xf){return g.enumWhile(function(){return xf.MoveNext()?xc(xf.get_Current()):false;},g.delay(function(){return[xf.get_Current()];}));});});},toArray:function(xi){var xj,xk,xl;xj=[];xk=i.Get(xi);while(xk.MoveNext()){xl=xk.get_Current();xj.push(xl);}return xj.slice(0);},toList:function(xm){return J.ofSeq(xm);},truncate:function(xn,xo){return g.delay(function(){return g.enumUsing(i.Get(xo),function(xq){var xr;xr={contents:0};return g.enumWhile(function(){return xq.MoveNext()?xr.contents<xn:false;},g.delay(function(){c.Increment(xr);return[xq.get_Current()];}));});});},tryFind:function(xu,xv){var xw,xx,xy;xw=i.Get(xv);xx={$:0};while(xx.$==0?xw.MoveNext():false){xy=xw.get_Current();xu(xy)?xx={$:1,$0:xy}:null;}return xx;},tryFindIndex:function(xz,xA){var xB,xC,xD,xE;xB=i.Get(xA);xC=true;xD=0;while(xC?xB.MoveNext():false){xE=xB.get_Current();xz(xE)?xC=false:xD=xD+1;}return xC?{$:0}:{$:1,$0:xD};},tryPick:function(xF,xG){var xH,xI;xH=i.Get(xG);xI={$:0};while(h.Equals(xI,{$:0})?xH.MoveNext():false){xI=xF(xH.get_Current());}return xI;},unfold:function(xJ,xK){var xL;xL=function(){var xN;xN=function(xO){var xP,xQ,xR,xS;xP=xJ(xO.s);if(xP.$==0){xQ=false;}else{xR=xP.$0[0];xS=xP.$0[1];xO.c=xR;xO.s=xS;xQ=true;}return xQ;};return x.New(xK,null,xN);};return R.Of(xL);},windowed:function(xT,xU){xT<=0?c.FailWith("The input must be non-negative."):null;return g.delay(function(){return g.enumUsing(i.Get(xU),function(xW){var xX;xX=[];return g.append(g.enumWhile(function(){return xX.length<xT?xW.MoveNext():false;},g.delay(function(){xX.push(xW.get_Current());return g.empty();})),g.delay(function(){return xX.length===xT?g.append([xX.slice(0)],g.delay(function(){return g.enumWhile(function(){return xW.MoveNext();},g.delay(function(){xX.shift();xX.push(xW.get_Current());return[xX.slice(0)];}));})):g.empty();}));});});},zip:function(x4,x5){return g.mapi2(function(x6){return function(x7){return[x6,x7];};},x4,x5);},zip3:function(x8,x9,x_){return g.mapi2(function(x$){return $.Tupled(function(ya){var yb,yc;yb=ya[0];yc=ya[1];return[x$,yb,yc];});},x8,g.zip(x9,x_));}},Stack:{Clear:function(yd){return yd.splice(0,e.GetLength(yd));},Contains:function(ye,yf){return g.exists(function(yg){return h.Equals(yf,yg);},ye);},CopyTo:function(yh,yi,yj){return b.blit(yi,0,yi,yj,e.GetLength(yh));}},Strings:{Compare:function(yk,yl){return c.Compare(yk,yl);},CopyTo:function(ym,yn,yo,yp,yq){return b.blit(M.ToCharArray(ym),yn,yo,yp,yq);},EndsWith:function($x,$s){var $0=this,$this=this;return $x.substring($x.length-$s.length)==$s;},IndexOf:function($s,$c,$i){var $0=this,$this=this;return $s.indexOf($$.String.fromCharCode($c),$i);},Insert:function($x,$index,$s){var $0=this,$this=this;return $x.substring(0,$index-1)+$s+$x.substring($index);},IsNullOrEmpty:function($x){var $0=this,$this=this;return $x==null||$x=="";},Join:function($sep,$values){var $0=this,$this=this;return $values.join($sep);},LastIndexOf:function($s,$c,$i){var $0=this,$this=this;return $s.lastIndexOf($$.String.fromCharCode($c),$i);},PadLeft:function(yr,ys){return M.PadLeftWith(yr,ys,32);},PadLeftWith:function($s,$n,$c){var $0=this,$this=this;return $$.Array($n-$s.length+1).join($$.String.fromCharCode($c))+$s;},PadRight:function(yt,yu){return M.PadRightWith(yt,yu,32);},PadRightWith:function($s,$n,$c){var $0=this,$this=this;return $s+$$.Array($n-$s.length+1).join($$.String.fromCharCode($c));},RegexEscape:function($s){var $0=this,$this=this;return $s.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&");},Remove:function($x,$ix,$ct){var $0=this,$this=this;return $x.substring(0,$ix)+$x.substring($ix+$ct);},Replace:function(yv,yw,yx){var yy;yy=function(yz){var yA,yB,yC,yD,yE;yA=yz.indexOf(yw);if(yA!==-1){yC=M.ReplaceOnce(yz,yw,yx);yD=yA+yx.length;yE=yA+yx.length;yB=M.Substring(yC,0,yE)+yy(yC.substring(yD));}else{yB=yz;}return yB;};return yy(yv);},ReplaceChar:function(yF,yG,yH){return M.Replace(yF,S.fromCharCode(yG),S.fromCharCode(yH));},ReplaceOnce:function($string,$search,$replace){var $0=this,$this=this;return $string.replace($search,$replace);},Split:function(yI,yJ,yK){var yL;yL=M.SplitWith(yI,yJ);return yK===1?b.filter(function(yM){return yM!=="";},yL):yL;},SplitChars:function(yN,yO,yP){var yQ;yQ="["+M.RegexEscape(S.fromCharCode.apply(undefined,yO))+"]";return M.Split(yN,new T(yQ),yP);},SplitStrings:function(yR,yS,yT){var yU;yU=M.concat("|",b.map(function(yV){return M.RegexEscape(yV);},yS));return M.Split(yR,new T(yU),yT);},SplitWith:function($str,$pat){var $0=this,$this=this;return $str.split($pat);},StartsWith:function($t,$s){var $0=this,$this=this;return $t.substring(0,$s.length)==$s;},Substring:function($s,$ix,$ct){var $0=this,$this=this;return $s.substr($ix,$ct);},ToCharArray:function(yW){return b.init(yW.length,function(yX){return yW.charCodeAt(yX);});},ToCharArrayRange:function(yY,yZ,y0){return b.init(y0,function(y1){return yY.charCodeAt(yZ+y1);});},Trim:function($s){var $0=this,$this=this;return $s.replace(/^\s+/,"").replace(/\s+$/,"");},collect:function(y2,y3){return b.init(y3.length,function(y4){return y2(y3.charCodeAt(y4));}).join("");},concat:function(y5,y6){return g.toArray(y6).join(y5);},exists:function(y7,y8){return g.exists(y7,M.protect(y8));},forall:function(y9,y_){return g.forall(y9,M.protect(y_));},init:function(y$,za){return b.init(y$,za).join("");},iter:function(zb,zc){return g.iter(zb,M.protect(zc));},iteri:function(zd,ze){return g.iteri(zd,M.protect(ze));},length:function(zf){return M.protect(zf).length;},map:function(zg,zh){return M.collect(function(zi){return S.fromCharCode(zg(zi));},M.protect(zh));},mapi:function(zj,zk){return g.toArray(g.mapi(function(zl){return function(zm){return S.fromCharCode((zj(zl))(zm));};},zk)).join("");},protect:function(zn){return zn===null?"":zn;},replicate:function(zo,zp){return M.init(zo,function(){return zp;});}},Unchecked:{Compare:function(zr,zs){var zt,zu,zv,zw;if(zr===zs){zt=0;}else{zu=typeof zr;if(zu==="undefined"){zw=typeof zs;zv=zw==="undefined"?0:-1;}else{zv=zu==="function"?c.FailWith("Cannot compare function values."):zu==="boolean"?zr<zs?-1:1:zu==="number"?zr<zs?-1:1:zu==="string"?zr<zs?-1:1:zr===null?-1:zs===null?1:"CompareTo"in zr?zr.CompareTo(zs):(zr instanceof f?zs instanceof f:false)?h.compareArrays(zr,zs):(zr instanceof u?zs instanceof u:false)?h.compareDates(zr,zs):h.compareArrays(G.GetFields(zr),G.GetFields(zs));}zt=zv;}return zt;},Equals:function(zx,zy){var zz,zA;if(zx===zy){zz=true;}else{zA=typeof zx;zz=zA==="object"?zx===null?false:zy===null?false:"Equals"in zx?zx.Equals(zy):(zx instanceof f?zy instanceof f:false)?h.arrayEquals(zx,zy):(zx instanceof u?zy instanceof u:false)?h.dateEquals(zx,zy):h.arrayEquals(G.GetFields(zx),G.GetFields(zy)):false;}return zz;},Hash:function(zB){var zC;zC=typeof zB;return zC==="function"?0:zC==="boolean"?zB?1:0:zC==="number"?zB:zC==="string"?h.hashString(zB):zC==="object"?zB==null?0:zB instanceof f?h.hashArray(zB):h.hashObject(zB):0;},arrayEquals:function(zD,zE){var zF,zG,zH;if(e.GetLength(zD)===e.GetLength(zE)){zG=true;zH=0;while(zG?zH<e.GetLength(zD):false){!h.Equals(e.GetArray(zD,zH),e.GetArray(zE,zH))?zG=false:null;zH=zH+1;}zF=zG;}else{zF=false;}return zF;},compareArrays:function(zI,zJ){var zK,zL,zM,zN;if(e.GetLength(zI)<e.GetLength(zJ)){zK=-1;}else{if(e.GetLength(zI)>e.GetLength(zJ)){zL=1;}else{zM=0;zN=0;while(zM===0?zN<e.GetLength(zI):false){zM=h.Compare(e.GetArray(zI,zN),e.GetArray(zJ,zN));zN=zN+1;}zL=zM;}zK=zL;}return zK;},compareDates:function(zO,zP){return c.Compare(zO.getTime(),zP.getTime());},dateEquals:function(zQ,zR){return zQ.getTime()===zR.getTime();},hashArray:function(zS){var zT,zU;zT=-34948909;for(zU=0;zU<=e.GetLength(zS)-1;zU++){zT=h.hashMix(zT,h.Hash(e.GetArray(zS,zU)));}return zT;},hashMix:function(zV,zW){return(zV<<5)+zV+zW;},hashObject:function(zX){var zY,zZ,z2;if("GetHashCode"in zX){zY=zX.GetHashCode();}else{zZ=function(z0,z1){return h.hashMix(z0,z1);};z2={contents:0};G.ForEach(zX,function(z3){z2.contents=zZ(zZ(z2.contents,h.hashString(z3)),h.Hash(zX[z3]));return false;});zY=z2.contents;}return zY;},hashString:function(z4){var z5,z6,z7;if(z4===null){z5=0;}else{z6=5381;for(z7=0;z7<=z4.length-1;z7++){z6=h.hashMix(z6,z4.charCodeAt(z7)<<0);}z5=z6;}return z5;}},Util:{addListener:function(z8,z9){z8.Subscribe(r.observer(z9));},observer:function(z_){return{OnCompleted:function(){},OnError:function(){},OnNext:z_};},subscribeTo:function(Ab,Ac){return Ab.Subscribe(r.observer(Ac));}}}}});$.OnInit(function(){a=$.Safe($$.IntelliFactory.WebSharper);b=$.Safe(a.Arrays);c=$.Safe(a.Operators);d=$.Safe($$.Number);e=$.Safe(a.IntrinsicFunctionProxy);f=$.Safe($$.Array);g=$.Safe(a.Seq);h=$.Safe(a.Unchecked);i=$.Safe(a.Enumerator);j=$.Safe(a.Arrays2D);k=$.Safe(a.Concurrency);l=$.Safe(a.AggregateException);m=$.Safe(a.Option);n=$.Safe($$.clearTimeout);o=$.Safe($$.setTimeout);p=$.Safe(a.CancellationTokenSource);q=$.Safe(a.Char);r=$.Safe(a.Util);s=$.Safe(a.Lazy);t=$.Safe($$.Error);u=$.Safe($$.Date);v=$.Safe($$.console);w=$.Safe(k.Scheduler);x=$.Safe(i.T);y=$.Safe(a.Html);z=$.Safe(y.Client);A=$.Safe(z.Activator);B=$.Safe($$.document);C=$.Safe($$.jQuery);D=$.Safe(a.Json);E=$.Safe($$.JSON);F=$.Safe(a.JavaScript);G=$.Safe(F.JS);H=$.Safe(z.HtmlContentExtensions);I=$.Safe(H.SingleNode);J=$.Safe(a.List);K=$.Safe(J.T);L=$.Safe($$.Math);M=$.Safe(a.Strings);N=$.Safe(a.PrintfHelpers);O=$.Safe(a.Remoting);P=$.Safe(O.XhrProvider);Q=$.Safe(a.AsyncProxy);R=$.Safe(a.Enumerable);S=$.Safe($$.String);return T=$.Safe($$.RegExp);});$.OnLoad(function(){O.EndPoint();O.AjaxProvider();A.Activate();k.scheduler();k.defCTS();k.GetCT();return;});}());

(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q;$.Define($$,{IntelliFactory:{WebSharper:{Testing:{Assert:{For:function(r,s,t){var u,v,w;u=s.Base;for(v=0;v<=b.GetLength(u)-1;v++){t(b.GetArray(s.Base,v));}for(w=1;w<=r;w++){t(s.Next.call(null,null));}return;},Raises:function(x){var y,z;try{x(null);y=c(false,"Assert raises exception test failed.");}catch(z){y=c(true,"Pass.");}return y;}},Pervasives:{Is:function(A,B){var C,D;if(!d.Equals(A,B)){D=["Equality test failed.",A,B];e?e.log.apply(e,D):undefined;C=c(false,"Equality test failed.");}else{C=c(true,"Pass.");}return C;},Isnt:function(E,F){var G,H;if(d.Equals(E,F)){H=["Inequality test failed.",E,F];e?e.log.apply(e,H):undefined;G=c(false,"Inequality test failed.");}else{G=c(true,"Pass.");}return G;},Test:function(I){return h.New(I);},TestBuilder:$.Class({Delay:function(J){return i(this.name,J);},Zero:function(){return null;}},{New:function(K){var L;L=$.New(this,{});L.name=K;return L;}})},Random:{ArrayOf:function(M){return{Base:[[]],Next:function(){var O;O=j.Natural().Next.call(null,null)%100;return k.init(O,function(){return M.Next.call(null,null);});}};},Boolean:$.Field(function(){return{Base:[true,false],Next:function(){return j.StandardUniform().Next.call(null,null)>0.5;}};}),Const:function(R){return{Base:[R],Next:function(){return R;}};},Exponential:function(T){return{Base:[],Next:function(){var V;V=j.StandardUniform().Next.call(null,null);return-l.log(1-V)/T;}};},Float:$.Field(function(){return{Base:[0],Next:function(){var X;X=j.Boolean().Next.call(null,null)?1:-1;return X*j.Exponential(0.1).Next.call(null,null);}};}),FloatExhaustive:$.Field(function(){return{Base:[0,m,n,-n],Next:function(){return j.Float().Next.call(null,null);}};}),FloatWithin:function(Z,_0){return{Base:[Z,_0],Next:function(){return Z+(_0-Z)*l.random();}};},Implies:function(_2,_3){return!_2?true:_3;},Imply:function(_4,_5){return j.Implies(_4,_5);},Int:$.Field(function(){return{Base:[0,1,-1],Next:function(){return l.round(j.Float().Next.call(null,null));}};}),ListOf:function(_7){var _8,_;_8=function(_9){return o.ofArray(_9);};_=j.ArrayOf(_7);return j.Map(_8,_);},Map:function(ba,bb){var bc;bc=bb.Next;return{Base:k.map(ba,bb.Base),Next:function(bd){return ba(bc(bd));}};},Mix:function(bd,be){var bf;bf={contents:false};return{Base:bd.Base.concat(be.Base),Next:function(){bf.contents=!bf.contents;return bf.contents?bd.Next.call(null,null):be.Next.call(null,null);}};},Natural:$.Field(function(){var bh;bh=j.Int().Next;return{Base:[0,1],Next:function(bi){var bj;bj=bh(bi);return l.abs(bj);}};}),OneOf:function(bk){var bl;bl=j.Within(1,b.GetLength(bk));return{Base:bk,Next:function(){return b.GetArray(bk,bl.Next.call(null,null)-1);}};},OptionOf:function(bn){return j.Mix(j.Const({$:0}),j.Map(function(bo){return{$:1,$0:bo};},bn));},StandardUniform:$.Field(function(){return{Base:[],Next:function(){return l.random();}};}),String:$.Field(function(){return{Base:[""],Next:function(){var br,bs;br=j.Natural().Next.call(null,null)%100;bs=k.init(br,function(){return j.Int().Next.call(null,null)%256;});return p.fromCharCode.apply(undefined,bs);}};}),StringExhaustive:$.Field(function(){return{Base:[null,""],Next:j.String().Next};}),Tuple2Of:function(bu,bv){return{Base:q.toArray(q.delay(function(){return q.collect(function(bx){return q.map(function(by){return[bx,by];},bv.Base);},bu.Base);})),Next:function(){return[bu.Next.call(null,null),bv.Next.call(null,null)];}};},Tuple3Of:function(bA,bB,bC){return{Base:q.toArray(q.delay(function(){return q.collect(function(bE){return q.collect(function(bF){return q.map(function(bG){return[bE,bF,bG];},bC.Base);},bB.Base);},bA.Base);})),Next:function(){return[bA.Next.call(null,null),bB.Next.call(null,null),bC.Next.call(null,null)];}};},Within:function(bI,bJ){return{Base:[bI,bJ],Next:function(){return j.Natural().Next.call(null,null)%(bJ-bI)+bI;}};}}}}}});$.OnInit(function(){a=$.Safe($$.IntelliFactory.WebSharper);b=$.Safe(a.IntrinsicFunctionProxy);c=$.Safe($$.ok);d=$.Safe(a.Unchecked);e=$.Safe($$.console);f=$.Safe(a.Testing);g=$.Safe(f.Pervasives);h=$.Safe(g.TestBuilder);i=$.Safe($$.test);j=$.Safe(f.Random);k=$.Safe(a.Arrays);l=$.Safe($$.Math);m=$.Safe($$.NaN);n=$.Safe($$.Infinity);o=$.Safe(a.List);p=$.Safe($$.String);return q=$.Safe(a.Seq);});$.OnLoad(function(){j.StringExhaustive();j.String();j.StandardUniform();j.Natural();j.Int();j.FloatExhaustive();j.Float();j.Boolean();return;});}());

(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t;$.Define($$,{IntelliFactory:{WebSharper:{Html:{Client:{Attribute:$.Class({get_Body:function(){var u;u=this.HtmlProvider.CreateAttribute(this.Name);u.value=this.Value;return u;}},{New:function(v){var w;w=$.New(this,e.New());w.HtmlProvider=v;return w;},New1:function(x,y,z){var A;A=d.New(x);A.Name=y;A.Value=z;return A;}}),AttributeBuilder:$.Class({Class:function(B){return this.NewAttr("class",B);},NewAttr:function(C,D){var E;E=d.New1(this.HtmlProvider,C,D);return E;}},{New:function(F){var G;G=$.New(this,{});G.HtmlProvider=F;return G;}}),Default:{A:function(H){var I;I=f.Tags();return I.NewTag("a",H);},Action:function(J){var K;K=f.Attr();return K.NewAttr("action",J);},Align:function(L){var M;M=f.Attr();return M.NewAttr("align",L);},Alt:function(N){var O;O=f.Attr();return O.NewAttr("alt",N);},Attr:$.Field(function(){return g.Attr();}),B:function(P){var Q;Q=f.Tags();return Q.NewTag("b",P);},Body:function(R){var S;S=f.Tags();return S.NewTag("body",R);},Br:function(T){var U;U=f.Tags();return U.NewTag("br",T);},Button:function(V){var W;W=f.Tags();return W.NewTag("button",V);},Code:function(X){var Y;Y=f.Tags();return Y.NewTag("code",X);},Deprecated:$.Field(function(){return g.DeprecatedHtml();}),Div:function(Z){return f.Tags().Div(Z);},Em:function(_0){var _1;_1=f.Tags();return _1.NewTag("em",_0);},Form:function(_2){var _3;_3=f.Tags();return _3.NewTag("form",_2);},H1:function(_4){var _5;_5=f.Tags();return _5.NewTag("h1",_4);},H2:function(_6){var _7;_7=f.Tags();return _7.NewTag("h2",_6);},H3:function(_8){var _9;_9=f.Tags();return _9.NewTag("h3",_8);},H4:function(_){var ba;ba=f.Tags();return ba.NewTag("h4",_);},HRef:function(ba){var bb;bb=f.Attr();return bb.NewAttr("href",ba);},Head:function(bc){var bd;bd=f.Tags();return bd.NewTag("head",bc);},Height:function(be){var bf;bf=f.Attr();return bf.NewAttr("height",be);},Hr:function(bg){var bh;bh=f.Tags();return bh.NewTag("hr",bg);},I:function(bi){var bj;bj=f.Tags();return bj.NewTag("i",bi);},IFrame:function(bk){var bl;bl=f.Tags();return bl.NewTag("iframe",bk);},Id:function(bm){var bn;bn=f.Attr();return bn.NewAttr("id",bm);},Img:function(bo){var bp;bp=f.Tags();return bp.NewTag("img",bo);},Input:function(bq){var br;br=f.Tags();return br.NewTag("input",bq);},LI:function(bs){var bt;bt=f.Tags();return bt.NewTag("li",bs);},Name:function(bu){var bv;bv=f.Attr();return bv.NewAttr("name",bu);},NewAttr:function(bw){return function(bx){return f.Attr().NewAttr(bw,bx);};},OL:function(by){var bz;bz=f.Tags();return bz.NewTag("ol",by);},OnLoad:function(bA){return g.HtmlProvider().OnDocumentReady(bA);},P:function(bB){var bC;bC=f.Tags();return bC.NewTag("p",bB);},Pre:function(bD){var bE;bE=f.Tags();return bE.NewTag("pre",bD);},RowSpan:function(bF){var bG;bG=f.Attr();return bG.NewAttr("rowspan",bF);},Script:function(bH){var bI;bI=f.Tags();return bI.NewTag("script",bH);},Select:function(bJ){var bK;bK=f.Tags();return bK.NewTag("select",bJ);},Selected:function(bL){var bM;bM=f.Attr();return bM.NewAttr("selected",bL);},Span:function(bN){var bO;bO=f.Tags();return bO.NewTag("span",bN);},Src:function(bP){var bQ;bQ=f.Attr();return bQ.NewAttr("src",bP);},TBody:function(bR){var bS;bS=f.Tags();return bS.NewTag("tbody",bR);},TD:function(bT){var bU;bU=f.Tags();return bU.NewTag("td",bT);},TFoot:function(bV){var bW;bW=f.Tags();return bW.NewTag("tfoot",bV);},TH:function(bX){var bY;bY=f.Tags();return bY.NewTag("th",bX);},THead:function(bZ){var b0;b0=f.Tags();return b0.NewTag("thead",bZ);},TR:function(b1){var b2;b2=f.Tags();return b2.NewTag("tr",b1);},Table:function(b3){var b4;b4=f.Tags();return b4.NewTag("table",b3);},Tags:$.Field(function(){return g.Tags();}),Text:function(b5){return f.Tags().text(b5);},TextArea:function(b6){var b7;b7=f.Tags();return b7.NewTag("textarea",b6);},UL:function(b8){var b9;b9=f.Tags();return b9.NewTag("ul",b8);},VAlign:function(b_){var b$;b$=f.Attr();return b$.NewAttr("valign",b_);},Width:function(ca){var cb;cb=f.Attr();return cb.NewAttr("width",ca);}},DeprecatedAttributeBuilder:$.Class({NewAttr:function(cc,cd){var ce;ce=d.New1(this.HtmlProvider,cc,cd);return ce;}},{New:function(cf){var cg;cg=$.New(this,{});cg.HtmlProvider=cf;return cg;}}),DeprecatedTagBuilder:$.Class({NewTag:function(ch,ci){var cj,ck,cl;cj=h.New(this.HtmlProvider,ch);ck=i.Get(ci);while(ck.MoveNext()){cl=ck.get_Current();cj.AppendI(cl);}return cj;}},{New:function(cm){var cn;cn=$.New(this,{});cn.HtmlProvider=cm;return cn;}}),Element:$.Class({AppendI:function(co){var cp,cq,cr,cs,ct,cu,cv,cw,cx;cp=co.get_Body();if(cp.nodeType===2){cr=this["HtmlProvider@33"];cs=this.get_Body();cq=cr.AppendAttribute(cs,cp);}else{ct=this["HtmlProvider@33"];cu=this.get_Body();cv=co.get_Body();cq=ct.AppendNode(cu,cv);}if(this.IsRendered){cw=co.Render();}else{cx=this.RenderInternal;cw=void(this.RenderInternal=function(){cx(null);return co.Render();});}return cw;},AppendN:function(cz){var cA,cB;cA=this["HtmlProvider@33"];cB=this.get_Body();return cA.AppendNode(cB,cz);},OnLoad:function(cC){var cD,cE;cD=this["HtmlProvider@33"];cE=this.get_Body();return cD.OnLoad(cE,cC);},Render:function(){var cF;if(!this.IsRendered){this.RenderInternal.call(null,null);cF=void(this.IsRendered=true);}else{cF=null;}return cF;},get_Body:function(){return this.Dom;},get_Html:function(){return this["HtmlProvider@33"].GetHtml(this.get_Body());},get_HtmlProvider:function(){return this["HtmlProvider@33"];},get_Id:function(){var cG,cH,cI,cJ,cK,cL,cM;cG=this["HtmlProvider@33"];cH=this.get_Body();cI=cG.GetProperty(cH,"id");if(cI===undefined?true:cI===""){cK="id"+j.round(j.random()*100000000);cL=this["HtmlProvider@33"];cM=this.get_Body();cL.SetProperty(cM,"id",cK);cJ=cK;}else{cJ=cI;}return cJ;},get_Item:function(cN){var cO,cP,cQ,cR;cO=this["HtmlProvider@33"];cP=this.get_Body();cO.GetAttribute(cP,cN);cQ=this["HtmlProvider@33"];cR=this.get_Body();return cQ.GetAttribute(cR,cN);},get_Text:function(){return this["HtmlProvider@33"].GetText(this.get_Body());},get_Value:function(){return this["HtmlProvider@33"].GetValue(this.get_Body());},set_Html:function(cS){var cT,cU;cT=this["HtmlProvider@33"];cU=this.get_Body();return cT.SetHtml(cU,cS);},set_Item:function(cV,cW){var cX,cY;cX=this["HtmlProvider@33"];cY=this.get_Body();return cX.SetAttribute(cY,cV,cW);},set_Text:function(cZ){var c0,c1;c0=this["HtmlProvider@33"];c1=this.get_Body();return c0.SetText(c1,cZ);},set_Value:function(c2){var c3,c4;c3=this["HtmlProvider@33"];c4=this.get_Body();return c3.SetValue(c4,c2);}},{New:function(c5,c6){var c7,c8;c7=h.New1(c5);c8=k.createElement(c6);c7.RenderInternal=function(){};c7.Dom=c8;c7.IsRendered=false;return c7;},New1:function(c_){var c$;c$=$.New(this,e.New());c$["HtmlProvider@33"]=c_;return c$;}}),Events:{JQueryEventSupport:$.Class({OnBlur:function(da,db){return l(db.get_Body()).bind("blur",function(){return da(db);});},OnChange:function(dd,de){return l(de.get_Body()).bind("change",function(){return dd(de);});},OnClick:function(dg,dh){return this.OnMouse("click",dg,dh);},OnDoubleClick:function(di,dj){return this.OnMouse("dblclick",di,dj);},OnError:function(dk,dl){return l(dl.get_Body()).bind("error",function(){return dk(dl);});},OnFocus:function(dn,_do){return l(_do.get_Body()).bind("focus",function(){return dn(_do);});},OnKeyDown:function(dq,dr){var ds;ds=function(dt){return(dq(dr))({KeyCode:dt.keyCode});};return l(dr.get_Body()).bind("keydown",ds);},OnKeyPress:function(du,dv){return l(dv.get_Body()).keypress(function(dw){return(du(dv))({CharacterCode:dw.which});});},OnKeyUp:function(dx,dy){var dz;dz=function(dA){return(dx(dy))({KeyCode:dA.keyCode});};return l(dy.get_Body()).bind("keyup",dz);},OnLoad:function(dB,dC){return l(dC.get_Body()).bind("load",function(){return dB(dC);});},OnMouse:function(dE,dF,dG){var dH;dH=function(dI){return(dF(dG))({X:dI.pageX,Y:dI.pageY});};return l(dG.get_Body()).bind(dE,dH);},OnMouseDown:function(dJ,dK){return this.OnMouse("mousedown",dJ,dK);},OnMouseEnter:function(dL,dM){return this.OnMouse("mouseenter",dL,dM);},OnMouseLeave:function(dN,dO){return this.OnMouse("mouseleave",dN,dO);},OnMouseMove:function(dP,dQ){return this.OnMouse("mousemove",dP,dQ);},OnMouseOut:function(dR,dS){return this.OnMouse("mouseout",dR,dS);},OnMouseUp:function(dT,dU){return this.OnMouse("mouseup",dT,dU);},OnResize:function(dV,dW){return l(dW.get_Body()).bind("resize",function(){return dV(dW);});},OnScroll:function(dY,dZ){return l(dZ.get_Body()).bind("scroll",function(){return dY(dZ);});},OnSelect:function(d1,d2){return l(d2.get_Body()).bind("select",function(){return d1(d2);});},OnSubmit:function(d4,d5){return l(d5.get_Body()).bind("submit",function(){return d4(d5);});},OnUnLoad:function(d7,d8){return l(d8.get_Body()).bind("unload",function(){return d7(d8);});}},{New:function(){return $.New(this,{});}})},EventsPervasives:{Events:$.Field(function(){return n.New();})},Implementation:{Attr:$.Field(function(){return o.New(g.HtmlProvider());}),DeprecatedHtml:$.Field(function(){return p.New(g.HtmlProvider());}),HtmlProvider:$.Field(function(){return q.New();}),JQueryHtmlProvider:$.Class({AddClass:function(d_,d$){return l(d_).addClass(d$);},AppendAttribute:function(ea,eb){var ec,ed;ec=eb.nodeName;ed=eb.value;return this.SetAttribute(ea,ec,ed);},AppendNode:function(ee,ef){return l(ee).append(l(ef));},Clear:function(eg){return l(eg).contents().detach();},CreateAttribute:function(eh){return k.createAttribute(eh);},CreateElement:function(ei){return k.createElement(ei);},CreateTextNode:function(ej){return k.createTextNode(ej);},GetAttribute:function(ek,el){return l(ek).attr(el);},GetHtml:function(em){return l(em).html();},GetProperty:function(en,eo){var ep;ep=l(en).attr(eo);return ep;},GetText:function(eq){return eq.textContent;},GetValue:function(er){var es;es=l(er).val();return es;},HasAttribute:function(et,eu){return l(et).attr(eu)!=null;},OnDocumentReady:function(ev){return l(k).ready(ev);},OnLoad:function(ew,ex){return l(ew).ready(ex);},Remove:function(ey){return l(ey).remove();},RemoveAttribute:function(ez,eA){return l(ez).removeAttr(eA);},RemoveClass:function(eB,eC){return l(eB).removeClass(eC);},SetAttribute:function(eD,eE,eF){return l(eD).attr(eE,eF);},SetCss:function(eG,eH,eI){return l(eG).css(eH,eI);},SetHtml:function(eJ,eK){return l(eJ).html(eK);},SetProperty:function(eL,eM,eN){var eO;eO=l(eL).prop(eM,eN);return eO;},SetStyle:function(eP,eQ){return l(eP).attr("style",eQ);},SetText:function(eR,eS){eR.textContent=eS;},SetValue:function(eT,eU){return l(eT).val(eU);}},{New:function(){return $.New(this,{});}}),Tags:$.Field(function(){return r.New(g.HtmlProvider());})},Operators:{OnAfterRender:function(eV,eW){var eX;eX=eW.Render;eW.Render=function(){eX.apply(eW);return eV(eW);};return;},OnBeforeRender:function(eZ,e0){var e1;e1=e0.Render;e0.Render=function(){eZ(e0);return e1.apply(e0);};return;},add:function(e3,e4){var e5,e6;e5=i.Get(e4);while(e5.MoveNext()){e6=e5.get_Current();e3.AppendI(e6);}return e3;}},Pagelet:$.Class({AppendTo:function(e7){var e8,e9;e8=k.getElementById(e7);e9=e8.appendChild(this.get_Body());return this.Render();},Render:function(){return null;},ReplaceInDom:function(e_){var e$;e$=e_.parentNode.replaceChild(this.get_Body(),e_);return this.Render();}},{New:function(){return $.New(this,{});}}),TagBuilder:$.Class({Div:function(fa){return this.NewTag("div",fa);},NewTag:function(fb,fc){var fd,fe,ff;fd=h.New(this.HtmlProvider,fb);fe=i.Get(fc);while(fe.MoveNext()){ff=fe.get_Current();fd.AppendI(ff);}return fd;},text:function(fg){return s.New(fg);}},{New:function(fh){var fi;fi=$.New(this,{});fi.HtmlProvider=fh;return fi;}}),Text:$.Class({get_Body:function(){return k.createTextNode(this.text);}},{New:function(fj){var fk;fk=$.New(this,e.New());fk.text=fj;return fk;}})}}}}});$.OnInit(function(){a=$.Safe($$.IntelliFactory.WebSharper);b=$.Safe(a.Html);c=$.Safe(b.Client);d=$.Safe(c.Attribute);e=$.Safe(c.Pagelet);f=$.Safe(c.Default);g=$.Safe(c.Implementation);h=$.Safe(c.Element);i=$.Safe(a.Enumerator);j=$.Safe($$.Math);k=$.Safe($$.document);l=$.Safe($$.jQuery);m=$.Safe(c.Events);n=$.Safe(m.JQueryEventSupport);o=$.Safe(c.AttributeBuilder);p=$.Safe(c.DeprecatedTagBuilder);q=$.Safe(g.JQueryHtmlProvider);r=$.Safe(c.TagBuilder);s=$.Safe(c.Text);return t=$.Safe(c.EventsPervasives);});$.OnLoad(function(){$.Inherit(d,e);$.Inherit(h,e);$.Inherit(s,e);g.Tags();g.HtmlProvider();g.DeprecatedHtml();g.Attr();t.Events();f.Tags();f.Deprecated();f.Attr();return;});}());

(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E;$.Define($$,{IntelliFactory:{WebSharper:{Control:{Disposable:{Of:function(F){return{Dispose:F};}},Event:{Event:$.Class({AddHandler:function(G){return this.Handlers.Add(G);},RemoveHandler:function(H){var I,K,L,N,O;I=function(J){return b.Equals(H,J);};K=this.Handlers;L=function(M){return K.RemoveAt(M);};N=this.Handlers;O=c.tryFindIndex(I,N);return d.iter(L,O);},Subscribe:function(P){var Q,T=this;Q=function(R){return P.OnNext(R);};this.AddHandler(Q);return f.Of(function(){return T.RemoveHandler(Q);});},Trigger:function(U){var V,W,X;V=this.Handlers.ToArray();for(W=0;W<=V.length-1;W++){X=g.GetArray(V,W);X(U);}return;}})},EventModule:{Choose:function(Y,Z){var _0;_0=h.New();i.addListener(Z,function(_1){var _2,_3,_4;_2=Y(_1);if(_2.$==0){_3=null;}else{_4=_2.$0;_3=_0.event.Trigger(_4);}return _3;});return _0.event;},Filter:function(_5,_6){var _7;_7=$.New(k,{Handlers:n.New1()});i.addListener(_6,function(_8){return _5(_8)?_7.Trigger(_8):null;});return _7;},Map:function(_9,_){var ba;ba=$.New(k,{Handlers:n.New1()});i.addListener(_,function(bb){return ba.Trigger(_9(bb));});return ba;},Merge:function(bb,bc){var bd;bd=$.New(k,{Handlers:n.New1()});i.addListener(bb,function(be){return bd.Trigger(be);});i.addListener(bc,function(bf){return bd.Trigger(bf);});return bd;},Pairwise:function(bg){var bh,bi;bh={contents:{$:0}};bi=$.New(k,{Handlers:n.New1()});i.addListener(bg,function(bj){var bk,bl,bm;bk=bh.contents;if(bk.$==1){bm=bk.$0;bh.contents={$:1,$0:bj};bl=bi.Trigger([bm,bj]);}else{bl=void(bh.contents={$:1,$0:bj});}return bl;});return bi;},Partition:function(bn,bo){return[o.Filter(bn,bo),o.Filter(function(bp){var bq;bq=bn(bp);return!bq;},bo)];},Scan:function(br,bs,bt){var bu,bv;bu={contents:bs};bv=function(bw){bu.contents=(br(bu.contents))(bw);return bu.contents;};return o.Map(bv,bt);},Split:function(bx,by){var bz,bE;bz=function(bA){var bB,bC,bD;bB=bx(bA);if(bB.$==0){bD=bB.$0;bC={$:1,$0:bD};}else{bC={$:0};}return bC;};bE=function(bF){var bG,bH,bI;bG=bx(bF);if(bG.$==1){bI=bG.$0;bH={$:1,$0:bI};}else{bH={$:0};}return bH;};return[o.Choose(bz,by),o.Choose(bE,by)];}},FSharpEvent:$.Class({},{New:function(){var bJ;bJ=$.New(this,{});bJ.event=$.New(k,{Handlers:n.New1()});return bJ;}}),HotStream:{HotStream:$.Class({Subscribe:function(bK){var bL,bM;this.Latest.contents.$==1?bK.OnNext(this.Latest.contents.$0):null;bM=this.Event;bL=i.subscribeTo(bM.event,function(bN){return bK.OnNext(bN);});return bL;},Trigger:function(bO){var bP;this.Latest.contents={$:1,$0:bO};bP=this.Event;return bP.event.Trigger(bO);}},{New:function(){return $.New(q,{Latest:{contents:{$:0}},Event:h.New()});}})},MailboxProcessor:$.Class({PostAndAsyncReply:function(bQ,bR){var bS,bV=this;bS=function(){var bU,bW;bU=bV.PostAndTryAsyncReply(bQ,bR);bW=function(bX){var bY,bZ,b0;if(bX.$==1){b0=bX.$0;bZ=b0;}else{bZ=r.Raise(new s("TimeoutException"));}bY=bZ;return t.Return(bY);};return t.Bind(bU,bW);};return t.Delay(bS);},PostAndTryAsyncReply:function(b1,b2){var b3,b4,cb=this;b3=r.DefaultArg(b2,this.get_DefaultTimeout());b4=$.Tupled(function(b5){var b6,b7,b8,b9,b_,ca,cc,cd,cg,ch;b6=b5[0];b7=b5[1];b8=b5[2];if(b3<0){b_=b1(function(b$){return b6({$:1,$0:b$});});ca=cb.mailbox.AddLast(b_);b9=cb.resume();}else{cc={contents:true};cd=b1(function(ce){var cf;if(cc.contents){cc.contents=false;cf=b6({$:1,$0:ce});}else{cf=null;}return cf;});cg=cb.mailbox.AddLast(cd);cb.resume();ch=u(function(){var cj;if(cc.contents){cc.contents=false;cj=b6({$:0});}else{cj=null;}return cj;},b3);b9=void ch;}return b9;});return t.FromContinuations(b4);},Receive:function(ck){var cl,co=this;cl=function(){var cn,cp;cn=co.TryReceive(ck);cp=function(cq){var cr,cs,ct;if(cq.$==1){ct=cq.$0;cs=ct;}else{cs=r.Raise(new s("TimeoutException"));}cr=cs;return t.Return(cr);};return t.Bind(cn,cp);};return t.Delay(cl);},Scan:function(cu,cv){var cw,cz=this;cw=function(){var cy,cA;cy=cz.TryScan(cu,cv);cA=function(cB){var cC,cD,cE;if(cB.$==1){cE=cB.$0;cD=cE;}else{cD=r.Raise(new s("TimeoutException"));}cC=cD;return t.Return(cC);};return t.Bind(cy,cA);};return t.Delay(cw);},Start:function(){var cF,cG,cL=this,cS;if(this.started){cF=r.FailWith("The MailboxProcessor has already been started.");}else{this.started=true;cG=function(){var cI,cO,cP;cI=function(){var cK,cM;cK=cL.initial.call(null,cL);cM=function(){return t.Return(null);};return t.Bind(cK,cM);};cO=t.Delay(cI);cP=function(cQ){var cR;cR=cL.errorEvent;cR.event.Trigger(cQ);return t.Return(null);};return t.TryWith(cO,cP);};cS=t.Delay(cG);cF=cL.startAsync(cS);}return cF;},TryReceive:function(cT){var cU,cV,c0=this;cU=r.DefaultArg(cT,this.get_DefaultTimeout());cV=$.Tupled(function(cW){var cX,cY,cZ,c1,c2,c3,c6,c7,c8,c$,dd,de;cX=cW[0];cY=cW[1];cZ=cW[2];if(b.Equals(c0.mailbox.get_First(),null)){if(cU<0){c3=function(){var c5;c5=c0.dequeue();cX({$:1,$0:c5});return t.Return(null);};c6=t.Delay(c3);c2=void(c0.savedCont={$:1,$0:c6});}else{c7={contents:true};c8=u(function(){var c_;if(c7.contents){c7.contents=false;c0.savedCont={$:0};c_=cX({$:0});}else{c_=null;}return c_;},cU);c$=function(){var db,dc;if(c7.contents){c7.contents=false;v(c8);dc=c0.dequeue();cX({$:1,$0:dc});db=t.Return(null);}else{db=t.Return(null);}return db;};dd=t.Delay(c$);c2=void(c0.savedCont={$:1,$0:dd});}c1=c2;}else{de=c0.dequeue();c1=cX({$:1,$0:de});}return c1;});return t.FromContinuations(cV);},TryScan:function(df,dg){var dh,di,dn=this;dh=r.DefaultArg(dg,this.get_DefaultTimeout());di=function(){var dk,dr,ds,dt,du,dx,d2;dk=function(){var dm,_do,dp,dq;dm=dn.mailbox.get_First();_do={$:0};while(!b.Equals(dm,null)){dp=df(dm.v);if(dp.$==0){dq=dm=dm.n;}else{dn.mailbox.Remove(dm);dm=null;dq=_do=dp;}}return _do;};dr=dk(null);if(dr.$==1){dt=dr.$0;du=function(dv){var dw;dw={$:1,$0:dv};return t.Return(dw);};ds=t.Bind(dt,du);}else{dx=$.Tupled(function(dy){var dz,dA,dB,dC,dD,dN,dO,dR;dz=dy[0];dA=dy[1];dB=dy[2];if(dh<0){dD=function(){var dF,dM;dF=function(){var dH,dI,dJ,dK;dH=df(dn.mailbox.get_First().v);if(dH.$==1){dJ=dH.$0;dn.mailbox.RemoveFirst();dK=function(dL){dz({$:1,$0:dL});return t.Return(null);};dI=t.Bind(dJ,dK);}else{dD(null);dI=t.Return(null);}return dI;};dM=t.Delay(dF);dn.savedCont={$:1,$0:dM};return;};dC=dD(null);}else{dN={contents:true};dO=u(function(){var dQ;if(dN.contents){dN.contents=false;dn.savedCont={$:0};dQ=dz({$:0});}else{dQ=null;}return dQ;},dh);dR=function(){var dT,d1;dT=function(){var dV,dW,dX,dY;dV=df(dn.mailbox.get_First().v);if(dV.$==1){dX=dV.$0;dn.mailbox.RemoveFirst();dY=function(dZ){var d0;if(dN.contents){dN.contents=false;v(dO);dz({$:1,$0:dZ});d0=t.Return(null);}else{d0=t.Return(null);}return d0;};dW=t.Bind(dX,dY);}else{dR(null);dW=t.Return(null);}return dW;};d1=t.Delay(dT);dn.savedCont={$:1,$0:d1};return;};dC=dR(null);}return dC;});d2=t.FromContinuations(dx);ds=d2;}return ds;};return t.Delay(di);},dequeue:function(){var d3;d3=this.mailbox.get_First().v;this.mailbox.RemoveFirst();return d3;},get_CurrentQueueLength:function(){return this.mailbox.get_Count();},get_DefaultTimeout:function(){return this["DefaultTimeout@"];},get_Error:function(){var d4;d4=this.errorEvent;return d4.event;},resume:function(){var d5,d6,d7;d5=this.savedCont;if(d5.$==1){d7=d5.$0;this.savedCont={$:0};d6=this.startAsync(d7);}else{d6=null;}return d6;},set_DefaultTimeout:function(d8){this["DefaultTimeout@"]=d8;return;},startAsync:function(d9){var d_;d_=this.token;return t.Start(d9,d_);}},{New:function(d$,ea){var eb,ec,ed,ee,ef,eh;eb=$.New(this,{});eb.initial=d$;eb.token=ea;eb.started=false;eb.errorEvent=h.New();eb.mailbox=x.New();eb.savedCont={$:0};ec=eb.token;if(ec.$==0){ed=null;}else{ee=ec.$0;ef=function(){return eb.resume();};eh=t.Register(ee,function(){return ef();});ed=void eh;}eb["DefaultTimeout@"]=-1;return eb;},Start:function(ej,ek){var el;el=y.New(ej,ek);el.Start();return el;}}),Observable:{Aggregate:function(em,en,eo){var ep;ep=function(eq){var er,es,ex;er={contents:en};es=function(et){return z.Protect(function(){return(eo(er.contents))(et);},function(ev){er.contents=ev;return eq.OnNext(ev);},function(ew){return eq.OnError(ew);});};ex=A.New(es,function(ey){return eq.OnError(ey);},function(){return eq.OnCompleted();});return em.Subscribe(ex);};return z.New(ep);},Choose:function(eA,eB){var eC;eC=function(eD){var eE,eL;eE=function(eF){var eH;eH=function(eI){return eD.OnNext(eI);};return z.Protect(function(){return eA(eF);},function(eJ){return d.iter(eH,eJ);},function(eK){return eD.OnError(eK);});};eL=A.New(eE,function(eM){return eD.OnError(eM);},function(){return eD.OnCompleted();});return eB.Subscribe(eL);};return z.New(eC);},CombineLatest:function(eO,eP,eQ){var eR;eR=function(eS){var eT,eU,eV,e5,e7,e_,fa,fd,fe;eT={contents:{$:0}};eU={contents:{$:0}};eV=function(){var eX,eY,eZ,e0,e1;eX=[eT.contents,eU.contents];if(eX[0].$==1){if(eX[1].$==1){e0=eX[0].$0;e1=eX[1].$0;eZ=z.Protect(function(){return(eQ(e0))(e1);},function(e3){return eS.OnNext(e3);},function(e4){return eS.OnError(e4);});}else{eZ=null;}eY=eZ;}else{eY=null;}return eY;};e5=function(e6){eT.contents={$:1,$0:e6};return eV(null);};e7=A.New(e5,function(){},function(){});e_=function(e$){eU.contents={$:1,$0:e$};return eV(null);};fa=A.New(e_,function(){},function(){});fd=eO.Subscribe(e7);fe=eP.Subscribe(fa);return f.Of(function(){fd.Dispose();return fe.Dispose();});};return z.New(eR);},Concat:function(fg,fh){var fi;fi=function(fj){var fk,fl,fq;fk={contents:{$:0}};fl=fg.Subscribe(A.New(function(fm){return fj.OnNext(fm);},function(){},function(){var fp;fp=fh.Subscribe(fj);fk.contents={$:1,$0:fp};}));fq=function(){fk.contents.$==1?fk.contents.$0.Dispose():null;return fl.Dispose();};return f.Of(fq);};return z.New(fi);},Drop:function(fs,ft){var fu;fu=function(fv){var fw,fx,fz;fw={contents:0};fx=function(fy){r.Increment(fw);return fw.contents>fs?fv.OnNext(fy):null;};fz=A.New(fx,function(fA){return fv.OnError(fA);},function(){return fv.OnCompleted();});return ft.Subscribe(fz);};return z.New(fu);},Filter:function(fC,fD){var fE;fE=function(fF){var fG,fN;fG=function(fH){var fJ;fJ=function(fK){return fF.OnNext(fK);};return z.Protect(function(){return fC(fH)?{$:1,$0:fH}:{$:0};},function(fL){return d.iter(fJ,fL);},function(fM){return fF.OnError(fM);});};fN=A.New(fG,function(fO){return fF.OnError(fO);},function(){return fF.OnCompleted();});return fD.Subscribe(fN);};return z.New(fE);},Map:function(fQ,fR){var fS;fS=function(fT){var fU,fZ;fU=function(fV){return z.Protect(function(){return fQ(fV);},function(fX){return fT.OnNext(fX);},function(fY){return fT.OnError(fY);});};fZ=A.New(fU,function(f0){return fT.OnError(f0);},function(){return fT.OnCompleted();});return fR.Subscribe(fZ);};return z.New(fS);},Merge:function(f2,f3){var f4;f4=function(f5){var f6,f7,f8,ga,gb,gf;f6={contents:false};f7={contents:false};f8=A.New(function(f9){return f5.OnNext(f9);},function(){},function(){f6.contents=true;return(f6.contents?f7.contents:false)?f5.OnCompleted():null;});ga=f2.Subscribe(f8);gb=A.New(function(gc){return f5.OnNext(gc);},function(){},function(){f7.contents=true;return(f6.contents?f7.contents:false)?f5.OnCompleted():null;});gf=f3.Subscribe(gb);return f.Of(function(){ga.Dispose();return gf.Dispose();});};return z.New(f4);},Never:function(){return z.New(function(){return f.Of(function(){});});},New:function(gj){return $.New(B,{Subscribe1:gj});},Observable:$.Class({Subscribe:function(gk){return this.Subscribe1.call(null,gk);}}),Of:function(gl){return z.New(function(gm){return f.Of(gl(function(gn){return gm.OnNext(gn);}));});},Protect:function(go,gp,gq){var gr,gs,gt,gu,gv,gw;try{gs={$:0,$0:go(null)};}catch(gt){gs={$:1,$0:gt};}gr=gs;if(gr.$==1){gv=gr.$0;gu=gq(gv);}else{gw=gr.$0;gu=gp(gw);}return gu;},Range:function(gx,gy){var gz;gz=function(gA){var gB;for(gB=gx;gB<=gx+gy;gB++){gA.OnNext(gB);}return f.Of(function(){});};return z.New(gz);},Return:function(gD){var gE;gE=function(gF){gF.OnNext(gD);gF.OnCompleted();return f.Of(function(){});};return z.New(gE);},SelectMany:function(gH){return z.New(function(gI){var gJ,gL;gJ={contents:function(){}};gL=i.subscribeTo(gH,function(gM){var gN;gN=i.subscribeTo(gM,function(gO){return gI.OnNext(gO);});gJ.contents=function(){gJ.contents.call(null,null);return gN.Dispose();};return;});return f.Of(function(){gJ.contents.call(null,null);return gL.Dispose();});});},Sequence:function(gR){var gS;gS=function(gT){var gU,gV,gW,gX;if(gT.$==1){gV=gT.$1;gW=gT.$0;gX=gS(gV);gU=z.CombineLatest(gW,gX,function(gY){return function(gZ){return $.New(D,{$:1,$0:gY,$1:gZ});};});}else{gU=z.Return($.New(D,{$:0}));}return gU;};return gS(C.ofSeq(gR));},Switch:function(g0){return z.New(function(g1){var g2,g3,g4;g2={contents:0};g3={contents:{$:0}};g4=i.subscribeTo(g0,function(g5){var g6,g7,g9;r.Increment(g2);g3.contents.$==1?g3.contents.$0.Dispose():null;g6=g2.contents;g7=i.subscribeTo(g5,function(g8){return g6===g2.contents?g1.OnNext(g8):null;});g9={$:1,$0:g7};g3.contents=g9;return;});return g4;});}},ObservableModule:{Pairwise:function(g_){var g$;g$=function(ha){var hb,hc,hh;hb={contents:{$:0}};hc=function(hd){var he,hf,hg;he=hb.contents;if(he.$==1){hg=he.$0;hf=ha.OnNext([hg,hd]);}else{hf=null;}hb.contents={$:1,$0:hd};return;};hh=A.New(hc,function(hi){return ha.OnError(hi);},function(){return ha.OnCompleted();});return g_.Subscribe(hh);};return z.New(g$);},Partition:function(hk,hl){var hm;hm=function(hn){var ho;ho=hk(hn);return!ho;};return[z.Filter(hk,hl),z.Filter(hm,hl)];},Scan:function(hp,hq,hr){var hs;hs=function(ht){var hu,hv,hA;hu={contents:hq};hv=function(hw){return z.Protect(function(){return(hp(hu.contents))(hw);},function(hy){hu.contents=hy;return ht.OnNext(hy);},function(hz){return ht.OnError(hz);});};hA=A.New(hv,function(hB){return ht.OnError(hB);},function(){return ht.OnCompleted();});return hr.Subscribe(hA);};return z.New(hs);},Split:function(hD,hE){var hF,hK,hL,hQ;hF=function(hG){var hH,hI,hJ;hH=hD(hG);if(hH.$==0){hJ=hH.$0;hI={$:1,$0:hJ};}else{hI={$:0};}return hI;};hK=z.Choose(hF,hE);hL=function(hM){var hN,hO,hP;hN=hD(hM);if(hN.$==1){hP=hN.$0;hO={$:1,$0:hP};}else{hO={$:0};}return hO;};hQ=z.Choose(hL,hE);return[hK,hQ];}},Observer:{New:function(hR,hS,hT){return $.New(E,{onNext:hR,onError:hS,onCompleted:hT});},Observer:$.Class({OnCompleted:function(){return this.onCompleted.call(null,null);},OnError:function(hU){return this.onError.call(null,hU);},OnNext:function(hV){return this.onNext.call(null,hV);}}),Of:function(hW){return $.New(E,{onNext:function(hX){return hW(hX);},onError:function(hY){return r.Raise(hY);},onCompleted:function(){return null;}});}}}}}});$.OnInit(function(){a=$.Safe($$.IntelliFactory.WebSharper);b=$.Safe(a.Unchecked);c=$.Safe(a.Seq);d=$.Safe(a.Option);e=$.Safe(a.Control);f=$.Safe(e.Disposable);g=$.Safe(a.IntrinsicFunctionProxy);h=$.Safe(e.FSharpEvent);i=$.Safe(a.Util);j=$.Safe(e.Event);k=$.Safe(j.Event);l=$.Safe(a.Collections);m=$.Safe(l.ResizeArray);n=$.Safe(m.ResizeArrayProxy);o=$.Safe(e.EventModule);p=$.Safe(e.HotStream);q=$.Safe(p.HotStream);r=$.Safe(a.Operators);s=$.Safe($$.Error);t=$.Safe(a.Concurrency);u=$.Safe($$.setTimeout);v=$.Safe($$.clearTimeout);w=$.Safe(l.LinkedList);x=$.Safe(w.ListProxy);y=$.Safe(e.MailboxProcessor);z=$.Safe(e.Observable);A=$.Safe(e.Observer);B=$.Safe(z.Observable);C=$.Safe(a.List);D=$.Safe(C.T);return E=$.Safe(A.Observer);});$.OnLoad(function(){return;});}());

(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E;$.Define($$,{IntelliFactory:{WebSharper:{Collections:{BalancedTree:{Add:function(F,G){return c.Put(function(){return function(I){return I;};},F,G);},Branch:function(J,K,L){return{Node:J,Left:K,Right:L,Height:1+d.Max(K==null?0:K.Height,L==null?0:L.Height),Count:1+(K==null?0:K.Count)+(L==null?0:L.Count)};},Build:function(M,N,O){var P,Q,R,S,T;P=O-N+1;if(P<=0){Q=null;}else{R=(N+O)/2>>0;S=c.Build(M,N,R-1);T=c.Build(M,R+1,O);Q=c.Branch(e.GetArray(M,R),S,T);}return Q;},Contains:function(U,V){return!((c.Lookup(U,V))[0]==null);},Enumerate:function(W,X){var Y;Y=$.Tupled(function(Z){var _0,_1,_2,_3,_4,_5,_6;_0=Z[0];_1=Z[1];if(_0==null){if(_1.$==1){_4=_1.$0[0];_5=_1.$1;_6=_1.$0[1];_3={$:1,$0:[_4,[_6,_5]]};}else{_3={$:0};}_2=_3;}else{_2=W?Y([_0.Right,$.New(h,{$:1,$0:[_0.Node,_0.Left],$1:_1})]):Y([_0.Left,$.New(h,{$:1,$0:[_0.Node,_0.Right],$1:_1})]);}return _2;});return f.unfold(Y,[X,$.New(h,{$:0})]);},Lookup:function(_7,_8){var _9,_,ba,bb,bc,bd;_9=[];_=_8;ba=true;while(ba){if(_==null){bb=ba=false;}else{bc=d.Compare(_7,_.Node);if(bc===0){bd=ba=false;}else{if(bc===1){_9.unshift([true,_.Node,_.Left]);bd=_=_.Right;}else{_9.unshift([false,_.Node,_.Right]);bd=_=_.Left;}}bb=bd;}}return[_,_9];},OfSeq:function(bd){var be;be=i.sort(f.toArray(f.distinct(bd)));return c.Build(be,0,be.length-1);},Put:function(bf,bg,bh){var bi,bj,bk;bi=c.Lookup(bg,bh);bj=bi[0];bk=bi[1];return bj==null?c.Rebuild(bk,c.Branch(bg,null,null)):c.Rebuild(bk,c.Branch((bf(bj.Node))(bg),bj.Left,bj.Right));},Rebuild:function(bl,bm){var bn,bp,bq,br,bs,bt,bu,bv,bw,bx,by,bz,bA,bB,bC;bn=function(bo){return bo==null?0:bo.Height;};bp=bm;for(bq=0;bq<=e.GetLength(bl)-1;bq++){br=e.GetArray(bl,bq);if(br[0]){bt=br[1];bu=br[2];if(bn(bp)>bn(bu)+1){if(bn(bp.Left)===bn(bp.Right)+1){bx=bp.Left;bw=c.Branch(bx.Node,c.Branch(bt,bu,bx.Left),c.Branch(bp.Node,bx.Right,bp.Right));}else{bw=c.Branch(bp.Node,c.Branch(bt,bu,bp.Left),bp.Right);}bv=bw;}else{bv=c.Branch(bt,bu,bp);}bs=bv;}else{by=br[1];bz=br[2];if(bn(bp)>bn(bz)+1){if(bn(bp.Right)===bn(bp.Left)+1){bC=bp.Right;bB=c.Branch(bC.Node,c.Branch(bp.Node,bp.Left,bC.Left),c.Branch(by,bC.Right,bz));}else{bB=c.Branch(bp.Node,bp.Left,c.Branch(by,bp.Right,bz));}bA=bB;}else{bA=c.Branch(by,bp,bz);}bs=bA;}bp=bs;}return bp;},Remove:function(bD,bE){var bF,bG,bH,bI,bJ,bK,bL,bM,bN,bO,bP;bF=c.Lookup(bD,bE);bG=bF[0];bH=bF[1];if(bG==null){bI=bE;}else{if(bG.Right==null){bJ=c.Rebuild(bH,bG.Left);}else{if(bG.Left==null){bK=c.Rebuild(bH,bG.Right);}else{bM=bG.Left;bN=bG.Right;bL=f.append(c.Enumerate(false,bM),c.Enumerate(false,bN));bO=f.toArray(bL);bP=c.Build(bO,0,bO.length-1);bK=c.Rebuild(bH,bP);}bJ=bK;}bI=bJ;}return bI;},TryFind:function(bQ,bR){var bS;bS=(c.Lookup(bQ,bR))[0];return bS==null?{$:0}:{$:1,$0:bS.Node};}},Dictionary:$.Class({Add:function(bT,bU){var bV,bW;bV=this.hash.call(null,bT);if(this.data.hasOwnProperty(bV)){bW=d.FailWith("An item with the same key has already been added.");}else{this.data[bV]={K:bT,V:bU};bW=void(this.count=this.count+1);}return bW;},Clear:function(){this.data={};this.count=0;return;},ContainsKey:function(bX){return this.data.hasOwnProperty(this.hash.call(null,bX));},GetEnumerator:function(){var bY;bY=k.GetFieldValues(this.data);return l.Get(bY);},Remove:function(bZ){var b0,b1;b0=this.hash.call(null,bZ);if(this.data.hasOwnProperty(b0)){k.Delete(this.data,b0);this.count=this.count-1;b1=true;}else{b1=false;}return b1;},get_Item:function(b2){var b3,b4,b5;b3=this.hash.call(null,b2);if(this.data.hasOwnProperty(b3)){b5=this.data[b3];b4=b5.V;}else{b4=m.notPresent();}return b4;},set_Item:function(b6,b7){var b8;b8=this.hash.call(null,b6);!this.data.hasOwnProperty(b8)?void(this.count=this.count+1):null;this.data[b8]={K:b6,V:b7};return;}},{New:function(b9,b_){return $.New(this,n.New11(b9,function(b$){return function(ca){return b_.Equals(b$,ca);};},function(cb){return b_.GetHashCode(cb);}));},New1:function(cc){return $.New(this,n.New11(cc,function(cd){return function(ce){return o.Equals(cd,ce);};},function(cf){return o.Hash(cf);}));},New11:function(cg,ch,ci){var cj,ck,cl,cm;cj=$.New(this,{});cj.hash=ci;cj.count=0;cj.data={};ck=l.Get(cg);while(ck.MoveNext()){cl=ck.get_Current();cm=cl.K;cj.data[cj.hash.call(null,cm)]=cl.V;}return cj;},New12:function(cn){return $.New(this,n.New11([],function(co){return function(cp){return cn.Equals(co,cp);};},function(cq){return cn.GetHashCode(cq);}));},New2:function(){return $.New(this,n.New11([],function(cr){return function(cs){return o.Equals(cr,cs);};},function(ct){return o.Hash(ct);}));},New3:function(){return $.New(this,n.New2());},New4:function(cv,cw){return $.New(this,n.New12(cw));}}),DictionaryUtil:{notPresent:function(){return d.FailWith("The given key was not present in the dictionary.");}},FSharpMap:$.Class({Add:function(cx,cy){var cz,cA;cz=this.tree;cA=$.New(q,{Key:cx,Value:cy});return p.New1(c.Add(cA,cz));},CompareTo:function(cB){return f.compareWith(function(cC){return function(cD){return d.Compare(cC,cD);};},this,cB);},ContainsKey:function(cE){var cF,cG;cF=this.tree;cG=$.New(q,{Key:cE,Value:undefined});return c.Contains(cG,cF);},Equals:function(cH){return this.get_Count()===cH.get_Count()?f.forall2(function(cI){return function(cJ){return o.Equals(cI,cJ);};},this,cH):false;},GetEnumerator:function(){var cK,cL,cN,cO;cK=this.tree;cL=function(cM){return{K:cM.Key,V:cM.Value};};cN=c.Enumerate(false,cK);cO=f.map(cL,cN);return l.Get(cO);},GetHashCode:function(){var cP;cP=f.toArray(this);return o.Hash(cP);},Remove:function(cQ){var cR,cS;cR=this.tree;cS=$.New(q,{Key:cQ,Value:undefined});return p.New1(c.Remove(cS,cR));},TryFind:function(cT){var cU,cV,cW,cY;cU=this.tree;cV=$.New(q,{Key:cT,Value:undefined});cW=function(cX){return cX.Value;};cY=c.TryFind(cV,cU);return r.map(cW,cY);},get_Count:function(){var cZ;cZ=this.tree;return cZ==null?0:cZ.Count;},get_IsEmpty:function(){return this.tree==null;},get_Item:function(c0){var c1,c2,c3;c1=this.TryFind(c0);if(c1.$==0){c2=d.FailWith("The given key was not present in the dictionary.");}else{c3=c1.$0;c2=c3;}return c2;},get_Tree:function(){return this.tree;}},{New:function(c4){return $.New(this,p.New1(s.fromSeq(c4)));},New1:function(c5){var c6;c6=$.New(this,{});c6.tree=c5;return c6;}}),FSharpSet:$.Class({Add:function(c7){return t.New1(c.Add(c7,this.tree));},CompareTo:function(c8){return f.compareWith(function(c9){return function(c_){return d.Compare(c9,c_);};},this,c8);},Contains:function(c$){return c.Contains(c$,this.tree);},Equals:function(da){return this.get_Count()===da.get_Count()?f.forall2(function(db){return function(dc){return o.Equals(db,dc);};},this,da):false;},GetEnumerator:function(){var dd,de;dd=this.tree;de=c.Enumerate(false,dd);return l.Get(de);},GetHashCode:function(){var df;df=f.toArray(this);return-1741749453+o.Hash(df);},IsProperSubsetOf:function(dg){return this.IsSubsetOf(dg)?this.get_Count()<dg.get_Count():false;},IsProperSupersetOf:function(dh){return this.IsSupersetOf(dh)?this.get_Count()>dh.get_Count():false;},IsSubsetOf:function(di){return f.forall(function(dj){return di.Contains(dj);},this);},IsSupersetOf:function(dk){var dm=this;return f.forall(function(dl){return dm.Contains(dl);},dk);},Remove:function(dn){return t.New1(c.Remove(dn,this.tree));},add:function(_do){var dp,dq;dp=f.append(this,_do);dq=c.OfSeq(dp);return t.New1(dq);},get_Count:function(){var dr;dr=this.tree;return dr==null?0:dr.Count;},get_IsEmpty:function(){return this.tree==null;},get_MaximumElement:function(){var ds;ds=this.tree;return f.head(c.Enumerate(true,ds));},get_MinimumElement:function(){var dt;dt=this.tree;return f.head(c.Enumerate(false,dt));},get_Tree:function(){return this.tree;},sub:function(du){return u.Filter(function(dv){return!du.Contains(dv);},this);}},{New:function(dw){return $.New(this,t.New1(v.ofSeq(dw)));},New1:function(dx){var dy;dy=$.New(this,{});dy.tree=dx;return dy;}}),HashSet:{HashSet:$.Class({Add:function(dz){return this.add(dz);},Clear:function(){this.data=w.prototype.constructor.apply(undefined,[].concat([]));this.count=0;return;},Contains:function(dA){var dB;dB=this.data[this.hash.call(null,dA)];return dB==null?false:this.arrContains(dA,dB);},CopyTo:function(dC){var dD,dE,dF;dD=0;dE=y.concat(this.data);for(dF=0;dF<=dE.length-1;dF++){e.SetArray(dC,dF,dE[dF]);}return;},ExceptWith:function(dG){var dH,dI,dJ;dH=l.Get(dG);while(dH.MoveNext()){dI=dH.get_Current();dJ=this.Remove(dI);}return;},GetEnumerator:function(){var dK;dK=y.concat(this.data);return l.Get(dK);},IntersectWith:function(dL){var dM,dN,dO,dP,dQ,dR,dS;dM=z.New3(dL,this.equals,this.hash);dN=y.concat(this.data);for(dO=0;dO<=dN.length-1;dO++){dP=dN[dO];dQ=dM.Contains(dP);if(!dQ){dS=this.Remove(dP);dR=void dS;}else{dR=null;}}return;},IsProperSubsetOf:function(dT){var dU;dU=i.ofSeq(dT);return this.count<e.GetLength(dU)?this.IsSubsetOf(dU):false;},IsProperSupersetOf:function(dV){var dW;dW=i.ofSeq(dV);return this.count>e.GetLength(dW)?this.IsSupersetOf(dW):false;},IsSubsetOf:function(dX){var dY,dZ,d1;dY=z.New3(dX,this.equals,this.hash);dZ=function(d0){return dY.Contains(d0);};d1=y.concat(this.data);return f.forall(dZ,d1);},IsSupersetOf:function(d2){var d3,d5=this;d3=function(d4){return d5.Contains(d4);};return f.forall(d3,d2);},Overlaps:function(d6){var d7,d9=this;d7=function(d8){return d9.Contains(d8);};return f.exists(d7,d6);},Remove:function(d_){var d$,ea,eb,ec;d$=this.hash.call(null,d_);ea=this.data[d$];if(ea==null){eb=false;}else{if(this.arrRemove(d_,ea)){this.count=this.count-1;ec=true;}else{ec=false;}eb=ec;}return eb;},RemoveWhere:function(ed){var ee,ef,eg,eh,ei;ee=y.concat(this.data);for(ef=0;ef<=ee.length-1;ef++){eg=ee[ef];if(ed(eg)){ei=this.Remove(eg);eh=void ei;}else{eh=null;}}return;},SetEquals:function(ej){var ek;ek=z.New3(ej,this.equals,this.hash);return this.get_Count()===ek.get_Count()?this.IsSupersetOf(ek):false;},SymmetricExceptWith:function(el){var em,en,eo,ep,eq;em=l.Get(el);while(em.MoveNext()){en=em.get_Current();if(this.Contains(en)){ep=this.Remove(en);eo=void ep;}else{eq=this.Add(en);eo=void eq;}}return;},UnionWith:function(er){var es,et,eu;es=l.Get(er);while(es.MoveNext()){et=es.get_Current();eu=this.Add(et);}return;},add:function(ev){var ew,ex,ey,ez,eA,eB;ew=this.hash.call(null,ev);ex=this.data[ew];if(ex==null){this.data[ew]=[ev];this.count=this.count+1;ey=true;}else{if(this.arrContains(ev,ex)){ez=false;}else{eA=[ev];eB=ex.push.apply(ex,[].concat(eA));this.count=this.count+1;ez=true;}ey=ez;}return ey;},arrContains:function(eC,eD){var eE,eF,eG;eE=true;eF=0;eG=eD.length;while(eE?eF<eG:false){(this.equals.call(null,eD[eF]))(eC)?eE=false:eF=eF+1;}return!eE;},arrRemove:function(eH,eI){var eJ,eK,eL,eM,eN,eO,eP;eJ=true;eK=0;eL=eI.length;while(eJ?eK<eL:false){if((this.equals.call(null,eI[eK]))(eH)){eN=eK;eO=[];eP=eI.splice.apply(eI,[eN,1].concat(eO));eM=eJ=false;}else{eM=eK=eK+1;}}return!eJ;},get_Count:function(){return this.count;}},{New:function(eQ){return $.New(this,z.New3(f.empty(),function(eR){return function(eS){return eQ.Equals(eR,eS);};},function(eT){return eQ.GetHashCode(eT);}));},New1:function(eU,eV){return $.New(this,z.New3(eU,function(eW){return function(eX){return eV.Equals(eW,eX);};},function(eY){return eV.GetHashCode(eY);}));},New11:function(eZ){return $.New(this,z.New3(eZ,function(e0){return function(e1){return o.Equals(e0,e1);};},function(e2){return o.Hash(e2);}));},New2:function(){return $.New(this,z.New3(f.empty(),function(e3){return function(e4){return o.Equals(e3,e4);};},function(e5){return o.Hash(e5);}));},New3:function(e6,e7,e8){var e9,e_,e$,fa;e9=$.New(this,{});e9.equals=e7;e9.hash=e8;e9.data=w.prototype.constructor.apply(undefined,[].concat([]));e9.count=0;e_=l.Get(e6);while(e_.MoveNext()){e$=e_.get_Current();fa=e9.add(e$);}return e9;}}),HashSetUtil:{concat:function($o){var $0=this,$this=this;var r=[];for(var k in $o){r.push.apply(r,$o[k]);};return r;}}},LinkedList:{EnumeratorProxy:$.Class({Dispose:function(){return null;},MoveNext:function(){this.c=this.c.n;return!o.Equals(this.c,null);},get_Current:function(){return this.c.v;}},{New:function(fb){var fc;fc=$.New(this,{});fc.c=fb;return fc;}}),ListProxy:$.Class({AddAfter:function(fd,fe){var ff,fg,fh;ff=fd.n;fg={p:fd,n:ff,v:fe};o.Equals(fd.n,null)?void(this.p=fg):null;fd.n=fg;if(!o.Equals(ff,null)){ff.p=fg;fh=fg;}else{fh=null;}this.c=this.c+1;return fg;},AddBefore:function(fi,fj){var fk,fl,fm;fk=fi.p;fl={p:fk,n:fi,v:fj};o.Equals(fi.p,null)?void(this.n=fl):null;fi.p=fl;if(!o.Equals(fk,null)){fk.n=fl;fm=fl;}else{fm=null;}this.c=this.c+1;return fl;},AddFirst:function(fn){var fo,fp;if(this.c===0){fp={p:null,n:null,v:fn};this.n=fp;this.p=this.n;this.c=1;fo=fp;}else{fo=this.AddBefore(this.n,fn);}return fo;},AddLast:function(fq){var fr,fs;if(this.c===0){fs={p:null,n:null,v:fq};this.n=fs;this.p=this.n;this.c=1;fr=fs;}else{fr=this.AddAfter(this.p,fq);}return fr;},Clear:function(){this.c=0;this.n=null;this.p=null;return;},Contains:function(ft){var fu,fv;fu=false;fv=this.n;while(!o.Equals(fv,null)?!fu:false){fv.v==ft?fu=true:fv=fv.n;}return fu;},Find:function(fw){var fx,fy;fx=this.n;fy=true;while(fy?!o.Equals(fx,null):false){fx.v==fw?fy=false:fx=fx.n;}return fy?null:fx;},FindLast:function(fz){var fA,fB;fA=this.p;fB=true;while(fB?!o.Equals(fA,null):false){fA.v==fz?fB=false:fA=fA.p;}return fB?null:fA;},GetEnumerator:function(){return B.New(this);},Remove:function(fC){var fD,fE,fF,fG;fD=fC.p;fE=fC.n;if(o.Equals(fD,null)){fF=void(this.n=fE);}else{fD.n=fE;fF=fE;}if(o.Equals(fE,null)){fG=void(this.p=fD);}else{fE.p=fD;fG=fD;}this.c=this.c-1;return;},Remove1:function(fH){var fI,fJ;fI=this.Find(fH);if(o.Equals(fI,null)){fJ=false;}else{this.Remove(fI);fJ=true;}return fJ;},RemoveFirst:function(){return this.Remove(this.n);},RemoveLast:function(){return this.Remove(this.p);},get_Count:function(){return this.c;},get_First:function(){return this.n;},get_Last:function(){return this.p;}},{New:function(){return $.New(this,C.New1(f.empty()));},New1:function(fK){var fL,fM,fN,fO;fL=$.New(this,{});fL.c=0;fL.n=null;fL.p=null;fM=l.Get(fK);if(fM.MoveNext()){fL.n={p:null,n:null,v:fM.get_Current()};fL.p=fL.n;fN=void(fL.c=1);}else{fN=null;}while(fM.MoveNext()){fO={p:fL.p,n:null,v:fM.get_Current()};fL.p.n=fO;fL.p=fO;fL.c=fL.c+1;}return fL;}})},MapModule:{Exists:function(fP,fQ){var fR;fR=function(fS){return(fP(fS.K))(fS.V);};return f.exists(fR,fQ);},Filter:function(fT,fU){var fV,fW,fY,fZ,f0,f1;fV=fU.get_Tree();fW=function(fX){return(fT(fX.Key))(fX.Value);};fY=c.Enumerate(false,fV);fZ=f.filter(fW,fY);f0=f.toArray(fZ);f1=c.Build(f0,0,f0.length-1);return p.New1(f1);},FindKey:function(f2,f3){var f4;f4=function(f5){return(f2(f5.K))(f5.V)?{$:1,$0:f5.K}:{$:0};};return f.pick(f4,f3);},Fold:function(f6,f7,f8){var f9,f_,gb;f9=f8.get_Tree();f_=function(f$){return function(ga){return((f6(f$))(ga.Key))(ga.Value);};};gb=c.Enumerate(false,f9);return f.fold(f_,f7,gb);},FoldBack:function(gc,gd,ge){var gf,gg,gj;gf=gd.get_Tree();gg=function(gh){return function(gi){return((gc(gi.Key))(gi.Value))(gh);};};gj=c.Enumerate(true,gf);return f.fold(gg,ge,gj);},ForAll:function(gk,gl){var gm;gm=function(gn){return(gk(gn.K))(gn.V);};return f.forall(gm,gl);},Iterate:function(go,gp){var gq;gq=function(gr){return(go(gr.K))(gr.V);};return f.iter(gq,gp);},Map:function(gs,gt){var gu,gv,gx,gy,gz;gu=gt.get_Tree();gv=function(gw){return $.New(q,{Key:gw.Key,Value:(gs(gw.Key))(gw.Value)});};gx=c.Enumerate(false,gu);gy=f.map(gv,gx);gz=c.OfSeq(gy);return p.New1(gz);},OfArray:function(gA){var gB,gF,gG;gB=$.Tupled(function(gC){var gD,gE;gD=gC[0];gE=gC[1];return $.New(q,{Key:gD,Value:gE});});gF=f.map(gB,gA);gG=c.OfSeq(gF);return p.New1(gG);},Partition:function(gH,gI){var gJ,gL,gM,gN,gO,gP,gQ,gR;gJ=function(gK){return(gH(gK.Key))(gK.Value);};gM=gI.get_Tree();gL=f.toArray(c.Enumerate(false,gM));gN=i.partition(gJ,gL);gO=gN[1];gP=gN[0];gQ=c.Build(gP,0,gP.length-1);gR=c.Build(gO,0,gO.length-1);return[p.New1(gQ),p.New1(gR)];},Pick:function(gS,gT){var gU;gU=function(gV){return(gS(gV.K))(gV.V);};return f.pick(gU,gT);},ToSeq:function(gW){var gX,gY,g0;gX=gW.get_Tree();gY=function(gZ){return[gZ.Key,gZ.Value];};g0=c.Enumerate(false,gX);return f.map(gY,g0);},TryFind:function(g1,g2){return g2.TryFind(g1);},TryFindKey:function(g3,g4){var g5;g5=function(g6){return(g3(g6.K))(g6.V)?{$:1,$0:g6.K}:{$:0};};return f.tryPick(g5,g4);},TryPick:function(g7,g8){var g9;g9=function(g_){return(g7(g_.K))(g_.V);};return f.tryPick(g9,g8);}},MapUtil:{fromSeq:function(g$){var ha;ha=f.toArray(f.delay(function(){return f.collect($.Tupled(function(hc){var hd,he;hd=hc[1];he=hc[0];return[$.New(q,{Key:he,Value:hd})];}),f.distinctBy($.Tupled(function(hf){return hf[0];}),g$));}));i.sortInPlace(ha);return c.Build(ha,0,ha.length-1);}},Pair:$.Class({CompareTo:function(hg){return d.Compare(this.Key,hg.Key);},Equals:function(hh){return o.Equals(this.Key,hh.Key);},GetHashCode:function(){var hi;hi=this.Key;return o.Hash(hi);}}),ResizeArray:{ResizeArrayProxy:$.Class({Add:function(hj){return this.arr.push(hj);},AddRange:function(hk){var hm=this;return f.iter(function(hl){return hm.Add(hl);},hk);},Clear:function(){var hn,ho;ho=this.arr;hn=D.splice(this.arr,0,e.GetLength(ho),[]);return;},CopyTo:function(hp){return this.CopyTo1(hp,0);},CopyTo1:function(hq,hr){return this.CopyTo2(0,hq,hr,this.get_Count());},CopyTo2:function(hs,ht,hu,hv){return i.blit(this.arr,hs,ht,hu,hv);},GetEnumerator:function(){var hw;hw=this.arr;return l.Get(hw);},GetRange:function(hx,hy){return E.New(i.sub(this.arr,hx,hy));},Insert:function(hz,hA){var hB;hB=D.splice(this.arr,hz,0,[hA]);return;},InsertRange:function(hC,hD){var hE;hE=D.splice(this.arr,hC,0,f.toArray(hD));return;},RemoveAt:function(hF){var hG;hG=D.splice(this.arr,hF,1,[]);return;},RemoveRange:function(hH,hI){var hJ;hJ=D.splice(this.arr,hH,hI,[]);return;},Reverse:function(){return this.arr.reverse();},Reverse1:function(hK,hL){return i.reverse(this.arr,hK,hL);},ToArray:function(){return this.arr.slice();},get_Count:function(){var hM;hM=this.arr;return e.GetLength(hM);},get_Item:function(hN){return e.GetArray(this.arr,hN);},set_Item:function(hO,hP){return e.SetArray(this.arr,hO,hP);}},{New:function(hQ){var hR;hR=$.New(this,{});hR.arr=hQ;return hR;},New1:function(){return $.New(this,E.New([]));},New11:function(hS){return $.New(this,E.New(f.toArray(hS)));},New2:function(){return $.New(this,E.New([]));}}),splice:function($arr,$index,$howMany,$items){var $0=this,$this=this;return $$.Array.prototype.splice.apply($arr,[$index,$howMany].concat($items));}},SetModule:{Filter:function(hU,hV){var hW,hX;hW=f.toArray(f.filter(hU,hV));hX=c.Build(hW,0,hW.length-1);return t.New1(hX);},FoldBack:function(hY,hZ,h0){var h3;h3=hZ.get_Tree();return f.fold(function(h1){return function(h2){return(hY(h2))(h1);};},h0,c.Enumerate(true,h3));},Partition:function(h4,h5){var h6,h7,h8,h9,h_;h6=i.partition(h4,f.toArray(h5));h7=h6[1];h8=h6[0];h9=c.OfSeq(h8);h_=c.OfSeq(h7);return[t.New1(h9),t.New1(h_)];}},SetUtil:{ofSeq:function(h$){var ia;ia=f.toArray(h$);i.sortInPlace(ia);return c.Build(ia,0,ia.length-1);}}}}}});$.OnInit(function(){a=$.Safe($$.IntelliFactory.WebSharper);b=$.Safe(a.Collections);c=$.Safe(b.BalancedTree);d=$.Safe(a.Operators);e=$.Safe(a.IntrinsicFunctionProxy);f=$.Safe(a.Seq);g=$.Safe(a.List);h=$.Safe(g.T);i=$.Safe(a.Arrays);j=$.Safe(a.JavaScript);k=$.Safe(j.JS);l=$.Safe(a.Enumerator);m=$.Safe(b.DictionaryUtil);n=$.Safe(b.Dictionary);o=$.Safe(a.Unchecked);p=$.Safe(b.FSharpMap);q=$.Safe(b.Pair);r=$.Safe(a.Option);s=$.Safe(b.MapUtil);t=$.Safe(b.FSharpSet);u=$.Safe(b.SetModule);v=$.Safe(b.SetUtil);w=$.Safe($$.Array);x=$.Safe(b.HashSet);y=$.Safe(x.HashSetUtil);z=$.Safe(x.HashSet);A=$.Safe(b.LinkedList);B=$.Safe(A.EnumeratorProxy);C=$.Safe(A.ListProxy);D=$.Safe(b.ResizeArray);return E=$.Safe(D.ResizeArrayProxy);});$.OnLoad(function(){return;});}());

(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q;$.Define($$,{IntelliFactory:{Reactive:{Disposable:$.Class({Dispose:function(){return this.Dispose1.call(null,null);}},{New:function(r){return $.New(b,{Dispose1:r});}}),HotStream:$.Class({Subscribe:function(s){var t;this.Latest.contents.$==1?s.OnNext(this.Latest.contents.$0):null;t=this.Event;return t.event.Subscribe(s);},Trigger:function(u){var v;this.Latest.contents={$:1,$0:u};v=this.Event;return v.event.Trigger(u);}},{New:function(w){var x;x={$:1,$0:w};return $.New(c,{Latest:{contents:x},Event:f.New()});},New1:function(){return $.New(c,{Latest:{contents:{$:0}},Event:f.New()});}}),Observable:$.Class({Subscribe:function(y){return this.OnSubscribe.call(null,y);},SubscribeWith:function(z,A){return this.OnSubscribe.call(null,g.New(z,A));}},{New:function(B){return $.New(h,{OnSubscribe:B});}}),Observer:$.Class({OnCompleted:function(){return this.OnCompleted1.call(null,null);},OnError:function(){return null;},OnNext:function(D){return this.OnNext1.call(null,D);}},{New:function(E,F){return $.New(g,{OnNext1:E,OnCompleted1:F});}}),Reactive:{Aggregate:function(G,H,I){return h.New(function(J){var K;K={contents:H};return i.subscribeTo(G,function(L){K.contents=(I(K.contents))(L);return J.OnNext(K.contents);});});},Choose:function(M,N){var O;O=function(P){return i.subscribeTo(M,function(Q){var R,S,T;R=N(Q);if(R.$==0){S=null;}else{T=R.$0;S=P.OnNext(T);}return S;});};return h.New(O);},CollectLatest:function(U){return h.New(function(V){var W,X;W=k.New2();X={contents:0};return i.subscribeTo(U,function(Y){var Z,_0;l.Increment(X);Z=X.contents;_0=i.subscribeTo(Y,function(_1){var _2;W.set_Item(Z,_1);_2=m.delay(function(){return m.map(function(_4){return _4.V;},W);});return V.OnNext(_2);});return;});});},CombineLatest:function(_5,_6,_7){var _8;_8=function(_9){var _,ba,bb,bi,bk,bm,bn,bp,br,bs,bt;_={contents:{$:0}};ba={contents:{$:0}};bb=function(){var bd,be,bf,bg,bh;bd=[_.contents,ba.contents];if(bd[0].$==1){if(bd[1].$==1){bg=bd[0].$0;bh=bd[1].$0;bf=_9.OnNext((_7(bg))(bh));}else{bf=null;}be=bf;}else{be=null;}return be;};bi=function(bj){_.contents={$:1,$0:bj};return bb(null);};bk=function(){};bm=g.New(bi,bk);bn=function(bo){ba.contents={$:1,$0:bo};return bb(null);};bp=function(){};br=g.New(bn,bp);bs=_5.Subscribe(bm);bt=_6.Subscribe(br);return b.New(function(){bs.Dispose();return bt.Dispose();});};return h.New(_8);},Concat:function(bu,bv){var bw;bw=function(bx){var by,bz,bB,bD,bE;by={contents:{$:0}};bz=function(bA){return bx.OnNext(bA);};bB=function(){by.contents={$:1,$0:bv.Subscribe(bx)};};bD=g.New(bz,bB);bE=bu.Subscribe(bD);return b.New(function(){by.contents.$==1?by.contents.$0.Dispose():null;return bE.Dispose();});};return h.New(bw);},Default:$.Field(function(){return o.New();}),Drop:function(bG,bH){var bI;bI=function(bJ){var bK;bK={contents:0};return i.subscribeTo(bG,function(bL){l.Increment(bK);return bK.contents>bH?bJ.OnNext(bL):null;});};return h.New(bI);},Heat:function(bM){var bN;bN=c.New1();i.subscribeTo(bM,function(bO){return bN.Trigger(bO);});return bN;},Merge:function(bP,bQ){var bR;bR=function(bS){var bT,bU,bV,bX,bZ,b0,b1,b3,b5,b6;bT={contents:false};bU={contents:false};bV=function(bW){return bS.OnNext(bW);};bX=function(){bT.contents=true;return(bT.contents?bU.contents:false)?bS.OnCompleted():null;};bZ=g.New(bV,bX);b0=bP.Subscribe(bZ);b1=function(b2){return bS.OnNext(b2);};b3=function(){bU.contents=true;return(bT.contents?bU.contents:false)?bS.OnCompleted():null;};b5=g.New(b1,b3);b6=bQ.Subscribe(b5);return b.New(function(){b0.Dispose();return b6.Dispose();});};return h.New(bR);},Never:function(){return h.New(function(){return b.New(function(){});});},Range:function(b_,b$){var ca;ca=function(cb){var cc;for(cc=b_;cc<=b_+b$;cc++){cb.OnNext(cc);}return b.New(function(){});};return h.New(ca);},Reactive:$.Class({Aggregate:function(ce,cf,cg){return n.Aggregate(ce,cf,cg);},Choose:function(ch,ci){return n.Choose(ch,ci);},CollectLatest:function(cj){return n.CollectLatest(cj);},CombineLatest:function(ck,cl,cm){return n.CombineLatest(ck,cl,cm);},Concat:function(cn,co){return n.Concat(cn,co);},Drop:function(cp,cq){return n.Drop(cp,cq);},Heat:function(cr){return n.Heat(cr);},Merge:function(cs,ct){return n.Merge(cs,ct);},Never:function(){return n.Never();},Return:function(cu){return n.Return(cu);},Select:function(cv,cw){return n.Select(cv,cw);},SelectMany:function(cx){return n.SelectMany(cx);},Sequence:function(cy){return n.Sequence(cy);},Switch:function(cz){return n.Switch(cz);},Where:function(cA,cB){return n.Where(cA,cB);}},{New:function(){return $.New(this,{});}}),Return:function(cC){var cD;cD=function(cE){cE.OnNext(cC);cE.OnCompleted();return b.New(function(){});};return h.New(cD);},Select:function(cG,cH){return h.New(function(cI){return i.subscribeTo(cG,function(cJ){return cI.OnNext(cH(cJ));});});},SelectMany:function(cK){return h.New(function(cL){var cM,cO;cM={contents:function(){}};cO=i.subscribeTo(cK,function(cP){var cQ;cQ=i.subscribeTo(cP,function(cR){return cL.OnNext(cR);});cM.contents=function(){cM.contents.call(null,null);return cQ.Dispose();};return;});return b.New(function(){cM.contents.call(null,null);return cO.Dispose();});});},Sequence:function(cU){var cV;cV=function(cW){var cX,cY,cZ,c0;if(cW.$==1){cY=cW.$1;cZ=cW.$0;c0=cV(cY);cX=n.CombineLatest(cZ,c0,function(c1){return function(c2){return $.New(q,{$:1,$0:c1,$1:c2});};});}else{cX=n.Return($.New(q,{$:0}));}return cX;};return n.Select(cV(p.ofSeq(cU)),function(c3){return c3;});},Switch:function(c4){return h.New(function(c5){var c6,c7,c8;c6={contents:0};c7={contents:{$:0}};c8=i.subscribeTo(c4,function(c9){var c_,c$,db;l.Increment(c6);c7.contents.$==1?c7.contents.$0.Dispose():null;c_=c6.contents;c$=i.subscribeTo(c9,function(da){return c_===c6.contents?c5.OnNext(da):null;});db={$:1,$0:c$};c7.contents=db;return;});return c8;});},Where:function(dc,dd){var de;de=function(df){return i.subscribeTo(dc,function(dg){return dd(dg)?df.OnNext(dg):null;});};return h.New(de);}}}}});$.OnInit(function(){a=$.Safe($$.IntelliFactory.Reactive);b=$.Safe(a.Disposable);c=$.Safe(a.HotStream);d=$.Safe($$.IntelliFactory.WebSharper);e=$.Safe(d.Control);f=$.Safe(e.FSharpEvent);g=$.Safe(a.Observer);h=$.Safe(a.Observable);i=$.Safe(d.Util);j=$.Safe(d.Collections);k=$.Safe(j.Dictionary);l=$.Safe(d.Operators);m=$.Safe(d.Seq);n=$.Safe(a.Reactive);o=$.Safe(n.Reactive);p=$.Safe(d.List);return q=$.Safe(p.T);});$.OnLoad(function(){n.Default();return;});}());

(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V;$.Define($$,{IntelliFactory:{WebSharper:{Piglets:{Choose:{Stream:$.Class({Choice:function(W,X){var Y,Z,_4=this;Y=g.New2();Z={contents:false};this.subscriptions.contents=$.New(i,{$:1,$0:this.pStream.SubscribeImmediate(function(_0){var _1,_2,_3;if(_0.$==0){_1=_0.$0[1];_2=_0.$0[0];_3=Y.ContainsKey(_2)?Y.get_Item(_2):_1.view.call(null,X);_4.out.Trigger(_1.stream.get_Latest());if(Z.contents){W.Remove(0);}Z.contents=true;return W.Add(_3);}else{return null;}}),$1:_4.subscriptions.contents});return W.get_Container();},Chooser:function(_5){return this.chooser.view.call(null,_5);},Dispose:function(){var _6,_7;_6=this.subscriptions.contents;_7=j.Get(_6);while(_7.MoveNext()){_7.get_Current().Dispose();}return k.iter(function(_8){return(l.KeyValue(_8))[1][1].Dispose();},this.choiceSubscriptions);},Subscribe:function(_9){return this.out.Subscribe(_9);},get_ChooserStream:function(){return this.chooser.stream;},get_Latest:function(){return this.out.get_Latest();}},{New:function(_,ba,bb){var bc;bc=$.New(this,e.New(bb.get_Id()));bc.chooser=_;bc.out=bb;bc.pStream=m.New($.New(n,{$:1,$0:$.New(i,{$:0})}),{$:0});bc.choiceSubscriptions=g.New2();bc.subscriptions={contents:h.ofArray([bc.chooser.stream.SubscribeImmediate(function(bd){return bc.pStream.Trigger(n.Map(function(be){var bf,bg,bh;if(bc.choiceSubscriptions.ContainsKey(be)){bf=(bc.choiceSubscriptions.get_Item(be))[0];}else{bg=ba(be);bh=bc.out;bc.choiceSubscriptions.set_Item(be,[bg,bg.stream.Subscribe(function(bi){return bh.Trigger(bi);})]);bf=bg;}return[be,bf];},bd));})])};return bc;}})},ConcreteReader:$.Class({Subscribe:function(bi){return this.subscribe.call(null,bi);},get_Latest:function(){return this.latest.call(null,null);}},{New:function(bj,bk){var bl;bl=$.New(this,e.New((p.next())(null)));bl.latest=bj;bl.subscribe=bk;return bl;}}),ConcreteWriter:$.Class({Trigger:function(bm){return this.trigger.call(null,bm);}},{New:function(bn){return q.New1(function(bo){return bo.$==1?null:bn(bo.$0);});},New1:function(bp){var bq;bq=$.New(this,{});bq.trigger=bp;return bq;}}),ConstReader:$.Class({Subscribe:function(){return s.New(function(){});},get_Latest:function(){return this.x;}},{New:function(bt){var bu;bu=$.New(this,e.New((p.next())(null)));bu.x=bt;return bu;}}),Controls:{Attr:function(bv,bw,bx,by){v.OnAfterRender(function(bz){var bA;bA=function(bB){var bC,bD,bE;if(bB.$==0){bC=bx(bB.$0);bD=bz["HtmlProvider@33"];bE=bz.get_Body();return bD.SetAttribute(bE,bw,bC);}else{return null;}};bA(bv.get_Latest());bv.Subscribe(bA);return;},by);return by;},AttrResult:function(bF,bG,bH,bI){v.OnAfterRender(function(bJ){var bK;bK=function(bL){var bM,bN,bO;bM=bH(bL);bN=bJ["HtmlProvider@33"];bO=bJ.get_Body();return bN.SetAttribute(bO,bG,bM);};bK(bF.get_Latest());bF.Subscribe(bK);return;},bI);return bI;},Button:function(bP){var bQ,bR;bQ=w.Button($.New(i,{$:0}));bR=function(){return function(){return bP.Trigger($.New(n,{$:0,$0:null}));};};x.Events().OnClick(bR,bQ);return bQ;},ButtonValidate:function(bU){var bV;bV=y.Button(bU);return y.EnableOnSuccess(bU.get_Input(),bV);},CheckBox:function(bW){var bX,bY,bZ,b0,b1,b2,b5;bX=(y.nextId())(null);bZ=w.Attr();b0=w.Attr();bY=w.Input(h.ofArray([bZ.NewAttr("type","checkbox"),b0.NewAttr("id",bX)]));b1=bW.get_Latest();if(b1.$==0){b2=b1.$0;bY.get_Body().checked=b2;}bW.Subscribe(function(b3){var b4;if(b3.$==1){return null;}else{b4=b3.$0;return!z.Equals(bY.get_Body().checked,b4)?void(bY.get_Body().checked=b4):null;}});b5=function(){return bW.Trigger($.New(n,{$:0,$0:bY.get_Body().checked}));};bY.get_Body().addEventListener("change",b5,true);return bY;},Css:function(b7,b8,b9,b_){v.OnAfterRender(function(b$){var ca;ca=function(cb){var cc,cd,ce;if(cb.$==0){cc=b9(cb.$0);cd=b$["HtmlProvider@33"];ce=b$.get_Body();return cd.SetCss(ce,b8,cc);}else{return null;}};ca(b7.get_Latest());b7.Subscribe(ca);return;},b_);return b_;},CssResult:function(cf,cg,ch,ci){v.OnAfterRender(function(cj){var ck;ck=function(cl){var cm,cn,co;cm=ch(cl);cn=cj["HtmlProvider@33"];co=cj.get_Body();return cn.SetCss(co,cg,cm);};ck(cf.get_Latest());cf.Subscribe(ck);return;},ci);return ci;},EnableOnSuccess:function(cp,cq){v.OnAfterRender(function(cr){cr.get_Body().disabled=!cp.get_Latest().get_isSuccess();cp.Subscribe(function(cs){cr.get_Body().disabled=!cs.get_isSuccess();});return;},cq);return cq;},HtmlContainer:$.Class({Add:function(ct){return this.container.AppendI(ct);},MoveUp:function(cu){var cv,cw;cv=this.container.get_Body().childNodes[cu];cw=this.container.get_Body().childNodes[cu-1];this.container.get_Body().removeChild(cv);this.container.get_Body().insertBefore(cv,cw);return;},Remove:function(cx){this.container.get_Body().removeChild(this.container.get_Body().childNodes[cx]);},get_Container:function(){return this.container;}},{New:function(cy){var cz;cz=$.New(this,{});cz.container=cy;return cz;}}),IntInput:function(cA){return y.input("number",function(cB){return cB<<0;},function(cC){return $$.String(cC);},cA);},Link:function(cD){var cE,cF;cF=w.Attr();cE=w.A(h.ofArray([cF.NewAttr("href","#")]));v.OnAfterRender(function(cG){return A(cG.get_Body()).on("click",function(){cD.Trigger($.New(n,{$:0,$0:null}));return false;});},cE);return cE;},Radio:function(cI,cJ){var cK,cL,cM,c1,c2;cK=(y.nextId())(null);cL=h.ofSeq(cJ);cM=$.Tupled(function(cN){var cO,cP,cQ,cR,cS,cT,cU,cV,cX,cY,cZ,c0;cO=cN[0];cP=cN[1];cQ=(y.nextId())(null);cS=w.Attr();cT=w.Attr();cU=w.Attr();cR=w.Input(h.ofArray([cS.NewAttr("type","radio"),cT.NewAttr("name",cK),cU.NewAttr("id",cQ)]));cV=function(cW){return cW.get_Body().checked?cI.Trigger($.New(n,{$:0,$0:cO})):null;};x.Events().OnChange(cV,cR);cX=cR;cZ=w.Attr();cY=h.ofArray([cZ.NewAttr("for",cQ),w.Text(cP)]);c0=w.Tags();return[cX,w.Span(h.ofArray([cX,c0.NewTag("label",cY)]))];});c1=h.map(cM,cL);c2=w.Div(k.map($.Tupled(function(c3){return c3[1];}),c1));v.OnAfterRender(function(){var c5;c5=function(c6){var c7;if(c6.$==1){return null;}else{c7=c6.$0;return h.iter2($.Tupled(function(c8){var c9;c9=c8[0];return $.Tupled(function(c_){c_[0].get_Body().checked=z.Equals(c9,c7);});}),cL,c1);}};c5(cI.get_Latest());cI.Subscribe(c5);return;},c2);return c2;},RenderChoice:function(c$,da,db){return c$.Choice(B.New(db),da);},RenderMany:function(dc,dd,de){return dc.Render(B.New(de),dd);},Select:function(df,dg){var dh,di,dj,dq,dr,ds,du;dh=(y.nextId())(null);di=C.ofSeq(dg);dj=$.Tupled(function(dk){var dl,dm,dn,_do,dp;dl=dk[1];dm=(y.nextId())(null);dn=w.Tags();dp=w.Attr();_do=h.ofArray([dp.NewAttr("value",dm)]);return v.add(dn.NewTag("option",_do),h.ofArray([w.Text(dl)]));});dq=C.map(dj,di);dr=w.Select(dq);ds=function(dt){return dt.get_Body().selectedIndex>=0?df.Trigger($.New(n,{$:0,$0:(D.GetArray(di,dt.get_Body().selectedIndex))[0]})):null;};x.Events().OnChange(ds,dr);du=dr;v.OnAfterRender(function(){df.SubscribeImmediate(function(dw){var dx,dy,dA,dB,dC;if(dw.$==1){return null;}else{dx=dw.$0;dy=C.tryFindIndex($.Tupled(function(dz){return z.Equals(dx,dz[0]);}),di);if(dy.$==0){return null;}else{dA=D.GetArray(dq,dy.$0);dB=dA["HtmlProvider@33"];dC=dA.get_Body();return dB.SetAttribute(dC,"selected","");}}});},du);return du;},Show:function(dD,dE,dF){return y.ShowResult(dD,function(dG){return dG.$==1?k.empty():dE(dG.$0);},dF);},ShowErrors:function(dH,dI,dJ){return y.ShowResult(dH,function(dK){return dK.$==1?dI(h.map(function(dL){return dL.get_Message();},dK.$0)):k.empty();},dJ);},ShowResult:function(dM,dN,dO){var dP,dQ;dP=dN(dM.get_Latest());dQ=j.Get(dP);while(dQ.MoveNext()){dO.AppendI(dQ.get_Current());}dM.Subscribe(function(dR){var dS,dT;dO["HtmlProvider@33"].Clear(dO.get_Body());dS=dN(dR);dT=j.Get(dS);while(dT.MoveNext()){dO.AppendI(dT.get_Current());}return;});return dO;},ShowString:function(dU,dV,dW){return y.Show(dU,function(dX){return h.ofArray([w.Text(dV(dX))]);},dW);},Submit:function(dY){var dZ,d0,d1;d0=w.Attr();dZ=w.Input(h.ofArray([d0.NewAttr("type","submit")]));d1=function(){return function(){return dY.Trigger($.New(n,{$:0,$0:null}));};};x.Events().OnClick(d1,dZ);return dZ;},SubmitValidate:function(d4){var d5;d5=y.Submit(d4);return y.EnableOnSuccess(d4.get_Input(),d5);},TextArea:function(d6){var d7,d8,d$;d7=w.TextArea($.New(i,{$:0}));d8=d6.get_Latest();if(d8.$==0){d7.set_Value(d8.$0);}d6.Subscribe(function(d9){var d_;if(d9.$==1){return null;}else{d_=d9.$0;return d7.get_Value()!==d_?d7.set_Value(d_):null;}});d$=function(){return d6.Trigger($.New(n,{$:0,$0:d7.get_Value()}));};d7.get_Body().addEventListener("keyup",d$,true);d7.get_Body().addEventListener("change",d$,true);return d7;},WithLabel:function(eb,ec){var ed,ee,ef,eg,eh;ed=(y.nextId())(null);ef=w.Attr();ee=h.ofArray([ef.NewAttr("for",ed),w.Text(eb)]);eg=w.Tags();eh=w.Attr();return w.Span(h.ofArray([eg.NewTag("label",ee),v.add(ec,h.ofArray([eh.NewAttr("id",ed)]))]));},WithLabelAfter:function(ei,ej){var ek,el,em,en,eo;ek=(y.nextId())(null);el=w.Attr();en=w.Attr();em=h.ofArray([en.NewAttr("for",ek),w.Text(ei)]);eo=w.Tags();return w.Span(h.ofArray([v.add(ej,h.ofArray([el.NewAttr("id",ek)])),eo.NewTag("label",em)]));},input:function(ep,eq,er,es){var et,eu,ev,ey;eu=w.Attr();et=w.Input(h.ofArray([eu.NewAttr("type",ep)]));ev=es.get_Latest();if(ev.$==0){et.set_Value(er(ev.$0));}es.Subscribe(function(ew){var ex;if(ew.$==1){return null;}else{ex=er(ew.$0);return et.get_Value()!==ex?et.set_Value(ex):null;}});ey=function(){var eA;eA=$.New(n,{$:0,$0:eq(et.get_Value())});return!z.Equals(eA,es.get_Latest())?es.Trigger(eA):null;};et.get_Body().addEventListener("keyup",ey,true);et.get_Body().addEventListener("change",ey,true);return et;},nextId:$.Field(function(){var eB;eB={contents:0};return function(){l.Increment(eB);return"pl__"+$$.String(eB.contents);};})},Disposable:$.Class({Dispose:function(){return this.dispose.call(null,null);}},{New:function(eD){var eE;eE=$.New(this,{});eE.dispose=eD;return eE;}}),ErrorMessage:$.Class({get_Message:function(){return this.message;},get_Source:function(){return this.source;}},{Create:function(eF,eG){return E.New(eF,eG.get_Id());},New:function(eH,eI){var eJ;eJ=$.New(this,{});eJ.message=eH;eJ.source=eI;return eJ;}}),Id:{next:$.Field(function(){var eK;eK={contents:0};return function(){l.Increment(eK);return eK.contents;};})},Many:{Operations:$.Class({get_Delete:function(){return q.New(this["delete"]);},get_MoveDown:function(){return this.moveDown;},get_MoveUp:function(){return this.moveUp;}},{New:function(eM,eN,eO){var eP;eP=$.New(this,{});eP["delete"]=eM;eP.moveUp=eN;eP.moveDown=eO;return eP;}}),Stream:$.Class({AddRender:function(eQ){return this.adder.view.call(null,eQ);},Render:function(eR,eS){var eT,eW=this,fk;eT=function(eU){var eV,eY,e1,e4,e6,e8,e_,fa,fb,fc,fe,ff,fg,fh;eV=eW.p.call(null,eU);eW.streams.Add(eV.stream);eV.stream.SubscribeImmediate(function(){return eW.update();});eY=function(){return k.findIndex(function(e0){return e0.get_Id()===eV.stream.get_Id();},eW.streams);};e1=function(e2){var e3;if(e2>0?e2<eW.streams.get_Count():false){e3=eW.streams.get_Item(e2);eW.streams.set_Item(e2,eW.streams.get_Item(e2-1));eW.streams.set_Item(e2-1,e3);eR.MoveUp(e2);return eW.update();}else{return null;}};e4=function(){return e1(eY(null)+1);};e6=function(){return e1(eY(null));};e8=function(){return eY(null)>0?$.New(n,{$:0,$0:null}):$.New(n,{$:1,$0:$.New(i,{$:0})});};e_=function(){return eY(null)<eW.streams.get_Count()-1?$.New(n,{$:0,$0:null}):$.New(n,{$:1,$0:$.New(i,{$:0})});};fa=m.New(e8(null),{$:0});fb=m.New(e_(null),{$:0});fc=eW.out.Subscribe(function(){fa.Trigger(e8(null));return fb.Trigger(e_(null));});fe=H.New(fa,false);ff=H.New(fb,false);fg=fe.Subscribe(n.Iter(e6));fh=ff.Subscribe(n.Iter(e4));return eR.Add(eV.view.call(null,eS(I.New(function(){var fj;fj=eY(null);eW.streams.RemoveAt(fj);eR.Remove(fj);fc.Dispose();fg.Dispose();fh.Dispose();return eW.update();},fe,ff))));};fk=eW.out.get_Latest();if(fk.$==0){C.iter(eT,fk.$0);}eW.adder.stream.Subscribe(function(fl){return fl.$==0?eT(fl.$0):null;});return eR.get_Container();},Subscribe:function(fm){return this.out.Subscribe(fm);},get_Add:function(){return this.adder.stream;},get_Latest:function(){return this.out.get_Latest();},update:function(){var fn;fn=this.out;return fn.Trigger(n.Map(function(fo){var fp;fp=h.rev(fo);return C.ofSeq(fp);},k.fold(function(fq){return function(fr){var fs,ft,fu;fs=[fq,fr.get_Latest()];if(fs[0].$==1){if(fs[1].$==1){ft=fs[0].$0;fu=fs[1].$0;return $.New(n,{$:1,$0:h.append(fu,ft)});}else{return $.New(n,{$:1,$0:fs[0].$0});}}else{return fs[1].$==1?$.New(n,{$:1,$0:fs[1].$0}):$.New(n,{$:0,$0:$.New(i,{$:1,$0:fs[1].$0,$1:fs[0].$0})});}};},$.New(n,{$:0,$0:$.New(i,{$:0})}),this.streams)));}},{New:function(fv,fw,fx){var fy;fy=$.New(this,e.New(fw.get_Id()));fy.p=fv;fy.out=fw;fy.adder=fx;fy.streams=K.New1();return fy;}}),UnitStream:$.Class({get_Add:function(){return this.submitStream;}},{New:function(fz,fA,fB,fC){var fD,fE,fF,fG;fD=$.New(this,G.New(fz,fA,fB));fE=m.New($.New(n,{$:1,$0:$.New(i,{$:0})}),{$:0});fF=fB.get_Stream();fG=function(fH){return fF.Trigger(fH);};fE.Subscribe(function(fI){return fI.$==0?fG($.New(n,{$:0,$0:fC})):fG($.New(n,{$:1,$0:fI.$0}));});fD.submitStream=fE;return fD;}})},Pervasives:{op_LessMultiplyGreater:function(fJ,fK){var fL,fM;fL=fJ.view;fM=fK.view;return $.New(M,{stream:N.Ap(fJ.stream,fK.stream),view:function(fN){return fM(fL(fN));}});},op_LessMultiplyQmarkGreater:function(fO,fP){var fQ,fR;fQ=fO.view;fR=fP.view;return $.New(M,{stream:N.ApJoin(fO.stream,fP.stream),view:function(fS){return fR(fQ(fS));}});}},Piglet:$.Class({get_Stream:function(){return this.stream;}}),Piglet1:{Builder:$.Class({Bind:function(fT,fU){return O.Choose(fT,fU);},Return:function(fV){return O.Return(fV);},ReturnFrom:function(fW){return fW;},Yield:function(fX){return O.Yield(fX);},YieldFrom:function(fY){return fY;},Zero:function(){return O.ReturnFailure();}}),Choose:function(fZ,f0){var f1,f2;f1=m.New($.New(n,{$:1,$0:$.New(i,{$:0})}),{$:0});f2=d.New(fZ,f0,f1);return $.New(M,{stream:f1,view:function(f3){return f3(f2);}});},Confirm:function(f4,f5,f6){var f7,f8,f$;f7=O.Yield(f4);f8=P.op_LessMultiplyGreater(P.op_LessMultiplyGreater(O.Return(function(f9){return function(f_){return[f9,f_];};}),f5(O.Yield(f4))),f7);f$=Q["Is'"]($.Tupled(function(ga){return z.Equals(ga[0],ga[1]);}),E.Create(f6,f7.get_Stream()),f8);return O.MapViewArgs(function(gb){return function(gc){return[gb,gc];};},O.Map($.Tupled(function(gd){return gd[0];}),f$));},FlushErrors:function(ge){return O.MapResult(function(gf){return gf.$==1?$.New(n,{$:1,$0:$.New(i,{$:0})}):gf;},ge);},Many:function(gg,gh){return O.ManyInit([gg],gg,gh);},ManyInit:function(gi,gj,gk){var gl,gm;gl=m.New($.New(n,{$:0,$0:gi}),{$:0});gm=L.New(gk,gl,gk(gj),gj);return $.New(M,{stream:gl,view:function(gn){return gn(gm);}});},ManyPiglet:function(go,gp,gq){var gr,gs;gr=m.New($.New(n,{$:0,$0:go}),{$:0});gs=G.New(gq,gr,gp);return $.New(M,{stream:gr,view:function(gt){return gt(gs);}});},Map:function(gu,gv){return O.MapResult(function(gw){return gw.$==0?$.New(n,{$:0,$0:gu(gw.$0)}):$.New(n,{$:1,$0:gw.$0});},gv);},MapAsync:function(gx,gy){return O.MapAsyncResult(function(gz){var gA,gB,gH;if(gz.$==0){gA=gz.$0;gB=function(){var gD,gE;gD=gx(gA);gE=function(gF){var gG;gG=$.New(n,{$:0,$0:gF});return R.Return(gG);};return R.Bind(gD,gE);};return R.Delay(gB);}else{gH=$.New(n,{$:1,$0:gz.$0});return R.Return(gH);}},gy);},MapAsyncResult:function(gI,gJ){var gK,gU,g0,g1;gK=m.New($.New(n,{$:1,$0:$.New(i,{$:0})}),{$:0});gJ.stream.Subscribe(function(gL){var gM,gS,gT;gM=function(){var gO,gP;gO=gI(gL);gP=function(gQ){var gR;gR=gK.Trigger(gQ);return R.Return(gR);};return R.Bind(gO,gP);};gS=R.Delay(gM);gT={$:0};return R.Start(gS,gT);});gU=function(){var gW,gX;gW=gI(gJ.stream.get_Latest());gX=function(gY){var gZ;gZ=gK.Trigger(gY);return R.Return(gZ);};return R.Bind(gW,gX);};g0=R.Delay(gU);g1={$:0};R.Start(g0,g1);return $.New(M,{stream:gK,view:gJ.view});},MapResult:function(g2,g3){var g4;g4=m.New(g2(g3.stream.get_Latest()),{$:0});g3.stream.Subscribe(function(g5){return g4.Trigger(g2(g5));});return $.New(M,{stream:g4,view:g3.view});},MapResultWithWriter:function(g6,g7){var g8;g8=m.New($.New(n,{$:1,$0:$.New(i,{$:0})}),{$:0});g7.stream.SubscribeImmediate(g6(g8));return $.New(M,{stream:g8,view:g7.view});},MapToAsyncResult:function(g9,g_){return O.MapAsyncResult(function(g$){var ha;if(g$.$==0){return g9(g$.$0);}else{ha=$.New(n,{$:1,$0:g$.$0});return R.Return(ha);}},g_);},MapToResult:function(hb,hc){return O.MapResult(function(hd){return hd.$==0?hb(hd.$0):$.New(n,{$:1,$0:hd.$0});},hc);},MapViewArgs:function(he,hf){var hg;hg=hf.view;return $.New(M,{stream:hf.stream,view:function(hh){return hh(hg(he));}});},MapWithWriter:function(hi,hj){return O.MapResultWithWriter(function(hk){return function(hl){var hm;if(hl.$==0){hm=hl.$0;return(hi(hk))(hm);}else{return hk.Trigger($.New(n,{$:1,$0:hl.$0}));}};},hj);},Render:function(hn,ho){return ho.view.call(null,hn);},Return:function(hp){return $.New(M,{stream:m.New($.New(n,{$:0,$0:hp}),{$:0}),view:function(hq){return hq;}});},ReturnFailure:function(){return $.New(M,{stream:m.New($.New(n,{$:1,$0:$.New(i,{$:0})}),{$:0}),view:function(hr){return hr;}});},Run:function(hs,ht){return O.RunResult(n.Iter(hs),ht);},RunResult:function(hu,hv){hv.stream.Subscribe(hu);return hv;},TransmitReader:function(hw){var hx,hy;hx=hw.view;hy=hw.stream;return $.New(M,{stream:hw.stream,view:function(hz){return(hx(hz))(hy);}});},TransmitReaderMap:function(hA,hB){var hC,hD;hC=hB.view;hD=e.Map(hA,hB.stream);return $.New(M,{stream:hB.stream,view:function(hE){return(hC(hE))(hD);}});},TransmitReaderMapResult:function(hF,hG){var hH,hI;hH=hG.view;hI=e.MapResult(hF,hG.stream);return $.New(M,{stream:hG.stream,view:function(hJ){return(hH(hJ))(hI);}});},TransmitReaderMapToResult:function(hK,hL){var hM,hN;hM=hL.view;hN=e.MapToResult(hK,hL.stream);return $.New(M,{stream:hL.stream,view:function(hO){return(hM(hO))(hN);}});},TransmitStream:function(hP){var hQ,hR;hQ=hP.view;hR=hP.stream;return $.New(M,{stream:hP.stream,view:function(hS){return(hQ(hS))(hR);}});},TransmitWriter:function(hT){var hU,hV;hU=hT.view;hV=hT.stream;return $.New(M,{stream:hT.stream,view:function(hW){return(hU(hW))(hV);}});},Validation:{Is:function(hX,hY,hZ){var h0;h0=m.New(hZ.stream.get_Latest(),{$:1,$0:hZ.stream.get_Id()});hZ.stream.Subscribe(function(h1){return h1.$==0?hX(h1.$0)?h0.Trigger($.New(n,{$:0,$0:h1.$0})):h0.Trigger($.New(n,{$:1,$0:h.ofArray([E.New(hY,h0.get_Id())])})):h0.Trigger($.New(n,{$:1,$0:h1.$0}));});return $.New(M,{stream:h0,view:hZ.view});},"Is'":function(h2,h3,h4){var h5;h5=m.New(h4.stream.get_Latest(),{$:1,$0:h4.stream.get_Id()});h4.stream.Subscribe(function(h6){return h6.$==0?h2(h6.$0)?h5.Trigger($.New(n,{$:0,$0:h6.$0})):h5.Trigger($.New(n,{$:1,$0:h.ofArray([h3])})):h5.Trigger($.New(n,{$:1,$0:h6.$0}));});return $.New(M,{stream:h5,view:h4.view});},Match:function(h7){var h8;h8=new S(h7);return function(h9){return h8.test(h9);};},NotEmpty:function(h_){return h_!=="";}},WithSubmit:function(h$){var ia,ib;ia=H.New(h$.stream,false);ib=h$.view;return $.New(M,{stream:ia.get_Output(),view:function(ic){return(ib(ic))(ia);}});},WithSubmitClearError:function(id){var ie,_if;ie=H.New(id.stream,true);_if=id.view;return $.New(M,{stream:ie.get_Output(),view:function(ig){return(_if(ig))(ie);}});},Yield:function(ih){var ii;ii=m.New($.New(n,{$:0,$0:ih}),{$:0});return $.New(M,{stream:ii,view:function(ij){return ij(ii);}});},YieldFailure:function(){var ik;ik=m.New($.New(n,{$:1,$0:$.New(i,{$:0})}),{$:0});return $.New(M,{stream:ik,view:function(il){return il(ik);}});},YieldOption:function(im,_in){var io,iq;io=function(ip){return ip.$==1?ip.$0:_in;};iq=function(ir){return z.Equals(ir,_in)?{$:0}:{$:1,$0:ir};};return O.MapViewArgs(function(is){return N.Map(io,iq,is);},O.Yield(im));}},Reader:$.Class({SubscribeImmediate:function(it){it(this.get_Latest());return this.Subscribe(it);},Through:function(iu){var iv,iz=this;iv=m.New(this.get_Latest(),{$:0});iu.Subscribe(function(iw){var ix,iy,iB,iC;if(iw.$==1){ix=iw.$0;iy=[iz.get_Latest(),h.filter(function(iA){return iA.get_Source()===iz.get_Id();},ix)];if(iy[1].$==0){return iv.Trigger(iz.get_Latest());}else{if(iy[0].$==1){iB=iy[1];iC=iy[0].$0;return iv.Trigger($.New(n,{$:1,$0:h.append(iC,iB)}));}else{return iv.Trigger($.New(n,{$:1,$0:iy[1]}));}}}else{return iv.Trigger(iz.get_Latest());}});return iv;},get_Id:function(){return this.id;}},{Const:function(iD){return r.New($.New(n,{$:0,$0:iD}));},ConstResult:function(iE){return r.New(iE);},Map:function(iF,iG){return e.MapResult(function(iH){return n.Map(iF,iH);},iG);},Map2:function(iI,iJ,iK){return e.MapResult2(function(iL){return function(iM){return n.Map2(iI,iL,iM);};},iJ,iK);},MapResult:function(iN,iO){var iP;iP=m.New(iN(iO.get_Latest()),{$:0});iO.Subscribe(function(iQ){return iP.Trigger(iN(iQ));});return iP;},MapResult2:function(iR,iS,iT){var iU;iU=m.New((iR(iS.get_Latest()))(iT.get_Latest()),{$:0});iS.Subscribe(function(iV){return iU.Trigger((iR(iV))(iT.get_Latest()));});iT.Subscribe(function(iW){return iU.Trigger((iR(iS.get_Latest()))(iW));});return iU;},MapToResult:function(iX,iY){return e.MapResult(n.Bind(iX),iY);},New:function(iZ){var i0;i0=$.New(this,{});i0.id=iZ;return i0;}}),Result:$.Class({get_isSuccess:function(){return this.$==1?false:true;}},{Ap:function(i1,i2){var i3,i4,i5;i3=[i1,i2];if(i3[0].$==1){if(i3[1].$==1){i4=i3[0].$0;i5=i3[1].$0;return $.New(n,{$:1,$0:h.append(i4,i5)});}else{return $.New(n,{$:1,$0:i3[0].$0});}}else{return i3[1].$==1?$.New(n,{$:1,$0:i3[1].$0}):$.New(n,{$:0,$0:i3[0].$0.call(null,i3[1].$0)});}},Bind:function(i6){return function(i7){return i7.$==1?$.New(n,{$:1,$0:i7.$0}):i6(i7.$0);};},Failwith:function(i8){return $.New(n,{$:1,$0:h.ofArray([E.New(i8,0)])});},Iter:function(i9){return function(i_){return i_.$==1?null:i9(i_.$0);};},Join:function(i$){return i$.$==0?i$.$0.$==0?$.New(n,{$:0,$0:i$.$0.$0}):$.New(n,{$:1,$0:i$.$0.$0}):$.New(n,{$:1,$0:i$.$0});},Map:function(ja,jb){return jb.$==1?$.New(n,{$:1,$0:jb.$0}):$.New(n,{$:0,$0:ja(jb.$0)});},Map2:function(jc,jd,je){var jf,jg,jh,ji;jf=[jd,je];if(jf[0].$==1){if(jf[1].$==1){jg=jf[0].$0;jh=jf[1].$0;return $.New(n,{$:1,$0:h.append(jg,jh)});}else{return $.New(n,{$:1,$0:jf[0].$0});}}else{if(jf[1].$==1){return $.New(n,{$:1,$0:jf[1].$0});}else{ji=jf[1].$0;return $.New(n,{$:0,$0:(jc(jf[0].$0))(ji)});}}}}),Stream:$.Class({Subscribe:function(jj){return T.subscribeTo(this.s,jj);},Trigger:function(jk){return this.s.Trigger(jk);},Trigger1:function(jl){return this.Trigger(jl);},Write:function(jm){var jo=this;return q.New1(function(jn){return jn.$==0?jo.Trigger($.New(n,{$:0,$0:jm})):jo.Trigger($.New(n,{$:1,$0:jn.$0}));});},get_Latest:function(){return this.s.Latest.contents.$0;}},{New:function(jp,jq){return $.New(this,m.New1(V.New(jp),jq));},New1:function(jr,js){var jt;jt=$.New(this,e.New(js.$==0?(p.next())(null):js.$0));jt.s=jr;return jt;}}),Stream1:{Ap:function(ju,jv){var jw;jw=m.New(n.Ap(ju.get_Latest(),jv.get_Latest()),{$:0});ju.Subscribe(function(jx){return jw.Trigger(n.Ap(jx,jv.get_Latest()));});jv.Subscribe(function(jy){return jw.Trigger(n.Ap(ju.get_Latest(),jy));});return jw;},ApJoin:function(jz,jA){var jB;jB=m.New(n.Ap(jz.get_Latest(),n.Join(jA.get_Latest())),{$:0});jz.Subscribe(function(jC){return jB.Trigger(n.Ap(jC,n.Join(jA.get_Latest())));});jA.Subscribe(function(jD){return jB.Trigger(n.Ap(jz.get_Latest(),n.Join(jD)));});return jB;},Map:function(jE,jF,jG){var jH,jI,jJ;jH=m.New(n.Map(jE,jG.get_Latest()),{$:1,$0:jG.get_Id()});jI={contents:jG.get_Latest()};jJ={contents:jH.get_Latest()};jG.Subscribe(function(jK){if(jI.contents!==jK){jJ.contents=n.Map(jE,jK);return jH.Trigger(jJ.contents);}else{return null;}});jH.Subscribe(function(jL){if(jJ.contents!==jL){jI.contents=n.Map(jF,jL);return jG.Trigger(jI.contents);}else{return null;}});return jH;}},Submitter:$.Class({Subscribe:function(jM){return this.output.Subscribe(jM);},Trigger:function(){return this.writer.Trigger($.New(n,{$:0,$0:null}));},Trigger1:function(jN){return this.writer.Trigger(jN);},get_Input:function(){return this.input;},get_Latest:function(){return this.output.get_Latest();},get_Output:function(){return this.output;}},{New:function(jO,jP){var jQ;jQ=$.New(this,e.New((p.next())(null)));jQ.input=jO;jQ.output=m.New($.New(n,{$:1,$0:$.New(i,{$:0})}),{$:0});jQ.writer=q.New1(function(jR){var jS,jT,jU;jS=[jR,jQ.input.get_Latest()];if(jS[0].$==0){return jS[1].$==0?jQ.output.Trigger($.New(n,{$:0,$0:jS[1].$0})):jQ.output.Trigger($.New(n,{$:1,$0:jS[1].$0}));}else{if(jS[1].$==0){return jQ.output.Trigger($.New(n,{$:1,$0:jS[0].$0}));}else{jT=jS[0].$0;jU=jS[1].$0;return jQ.output.Trigger($.New(n,{$:1,$0:h.append(jT,jU)}));}}});if(jP){jQ.input.Subscribe(function(){var jW;jW=jQ.output.get_Latest();return jW.$==1?jW.$0.$==0?null:jQ.output.Trigger($.New(n,{$:1,$0:$.New(i,{$:0})})):jQ.output.Trigger($.New(n,{$:1,$0:$.New(i,{$:0})}));});}return jQ;}})}}}});$.OnInit(function(){a=$.Safe($$.IntelliFactory.WebSharper);b=$.Safe(a.Piglets);c=$.Safe(b.Choose);d=$.Safe(c.Stream);e=$.Safe(b.Reader);f=$.Safe(a.Collections);g=$.Safe(f.Dictionary);h=$.Safe(a.List);i=$.Safe(h.T);j=$.Safe(a.Enumerator);k=$.Safe(a.Seq);l=$.Safe(a.Operators);m=$.Safe(b.Stream);n=$.Safe(b.Result);o=$.Safe(b.ConcreteReader);p=$.Safe(b.Id);q=$.Safe(b.ConcreteWriter);r=$.Safe(b.ConstReader);s=$.Safe(b.Disposable);t=$.Safe(a.Html);u=$.Safe(t.Client);v=$.Safe(u.Operators);w=$.Safe(u.Default);x=$.Safe(u.EventsPervasives);y=$.Safe(b.Controls);z=$.Safe(a.Unchecked);A=$.Safe($$.jQuery);B=$.Safe(y.HtmlContainer);C=$.Safe(a.Arrays);D=$.Safe(a.IntrinsicFunctionProxy);E=$.Safe(b.ErrorMessage);F=$.Safe(b.Many);G=$.Safe(F.Stream);H=$.Safe(b.Submitter);I=$.Safe(F.Operations);J=$.Safe(f.ResizeArray);K=$.Safe(J.ResizeArrayProxy);L=$.Safe(F.UnitStream);M=$.Safe(b.Piglet);N=$.Safe(b.Stream1);O=$.Safe(b.Piglet1);P=$.Safe(b.Pervasives);Q=$.Safe(O.Validation);R=$.Safe(a.Concurrency);S=$.Safe($$.RegExp);T=$.Safe(a.Util);U=$.Safe($$.IntelliFactory.Reactive);return V=$.Safe(U.HotStream);});$.OnLoad(function(){$.Inherit(d,e);$.Inherit(o,e);$.Inherit(r,e);$.Inherit(G,e);$.Inherit(G,e);$.Inherit(L,G);$.Inherit(m,e);$.Inherit(H,e);p.next();y.nextId();return;});}());

(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p;$.Define($$,{IntelliFactory:{Formlets:{Base:{D:$.Class({Dispose:function(){return null;}},{New:function(){return $.New(this,{});}}),Form:$.Class({Dispose:function(){return this.Dispose1.call(null,null);}}),Formlet:$.Class({Build:function(){return this.Build1.call(null,null);},MapResult:function(q){var t=this;return $.New(c,{Layout:this.Layout,Build1:function(){var s,u,v,w,y;s=t.Build1.call(null,null);u=t.Utils.Reactive;v=s.State;w=function(x){return q(x);};u.Select(v,w);y=s.State;return $.New(d,{Body:s.Body,Dispose1:s.Dispose1,Notify:s.Notify,State:y});},Utils:t.Utils});},get_Layout:function(){return this.Layout;}}),FormletBuilder:$.Class({Bind:function(z,A){var B;B=this.F;return B.Bind(z,A);},Delay:function(C){return this.F.Delay(C);},Return:function(D){return this.F.Return(D);},ReturnFrom:function(E){return E;}},{New:function(F){var G;G=$.New(this,{});G.F=F;return G;}}),FormletProvider:$.Class({AppendLayout:function(H,I){var J;J=this.ApplyLayout(I);return this.WithLayout(H,J);},Apply:function(K,L){var M,P=this;M=function(){var O,Q,R,S,T,V,W,X,Y,_0,_1,_2,_3,_4,_5,_6,_9;O=P.BuildForm(K);Q=P.BuildForm(L);R=P.U.Reactive;S=O.Body;T=function(U){return $.New(f,{$:1,$0:U});};V=R.Select(S,T);W=P.U.Reactive;X=Q.Body;Y=function(Z){return $.New(f,{$:2,$0:Z});};_0=W.Select(X,Y);_1=P.U.Reactive;_2=_1.Merge(V,_0);_3=P.U.Reactive;_4=Q.State;_5=O.State;_6=function(_7){return function(_8){return g.Apply(_8,_7);};};_9=_3.CombineLatest(_4,_5,_6);return $.New(d,{Body:_2,Dispose1:function(){Q.Dispose1.call(null,null);return O.Dispose1.call(null,null);},Notify:function(ba){Q.Notify.call(null,ba);return O.Notify.call(null,ba);},State:_9});};return P.New(M);},ApplyLayout:function(ba){var bb,bi=this;bb=function(){var bd,be,bf,bg,bh;bd=ba.Build();be=ba.get_Layout().Apply.call(null,bd.Body);if(be.$==0){bg=bd.Body;}else{be.$0[1];bh=be.$0[0];bg=bi.U.Reactive.Return(e.Set(bh));}bf=bg;return $.New(d,{Body:bf,Dispose1:bd.Dispose1,Notify:bd.Notify,State:bd.State});};return bi.New(bb);},Bind:function(bj,bk){var bl;bl=this.Map(bk,bj);return this.Join(bl);},BindWith:function(bm,bn,bo){var bp,bs=this;bp=function(){var br,bt,bu,bv,bw,by,bz,bA,bB,bD,bE,bF,bG,bH,bI,bJ,bK,bL,bM;br=bs.Bind(bn,bo);bt=br.Build();bu=bs.U.Reactive;bv=bt.Body;bw=function(bx){return bx.$==1?true:false;};by=bs.U.DefaultLayout.Apply.call(null,bu.Where(bv,bw));bz=bs.U.Reactive;bA=bt.Body;bB=function(bC){return bC.$==2?true:false;};bD=bs.U.DefaultLayout.Apply.call(null,bz.Where(bA,bB));bE=[by,bD];if(bE[0].$==1){if(bE[1].$==1){bI=bE[0].$0[0];bJ=bE[1].$0[0];bK=bs.U.Reactive;bL=(bm(bI))(bJ);bM=e.Set(bL);bH=bK.Return(bM);}else{bH=bs.U.Reactive.Never();}bG=bH;}else{bG=bs.U.Reactive.Never();}bF=bG;return $.New(d,{Body:bF,Dispose1:bt.Dispose1,Notify:bt.Notify,State:bt.State});};return bs.New(bp);},BuildForm:function(bN){var bO,bP,bQ,bR,bS;bO=bN.Build();bP=bN.get_Layout().Apply.call(null,bO.Body);if(bP.$==1){bR=bP.$0[1];bS=bP.$0[0];bQ=$.New(d,{Body:this.U.Reactive.Return(e.Set(bS)),Dispose1:function(){bO.Dispose1.call(null,null);return bR.Dispose();},Notify:bO.Notify,State:bO.State});}else{bQ=bO;}return bQ;},Delay:function(bU){var bV,bX=this;bV=function(){return bX.BuildForm(bU(null));};return $.New(c,{Layout:bX.L.Delay(function(){return bU(null).get_Layout();}),Build1:bV,Utils:bX.U});},Deletable:function(bZ){var b0,b4=this;b0=function(b1){var b2,b3;if(b1.$==1){b3=b1.$0;b2=b4.Return({$:1,$0:b3});}else{b2=b4.ReturnEmpty({$:0});}return b2;};return b4.Replace(bZ,b0);},Empty:function(){var b5,b7=this;b5=function(){return $.New(d,{Body:b7.U.Reactive.Return(e.Delete()),Dispose1:function(){},Notify:function(){},State:b7.U.Reactive.Never()});};return b7.New(b5);},EmptyForm:function(){return $.New(d,{Body:this.U.Reactive.Never(),Dispose1:function(){},Notify:function(){},State:this.U.Reactive.Never()});},Fail:function(ca){return $.New(d,{Body:this.U.Reactive.Never(),Dispose1:function(cb){return cb;},Notify:function(){},State:this.U.Reactive.Return($.New(g,{$:1,$0:ca}))});},FailWith:function(cd){var ce,cg=this;ce=function(){return cg.Fail(cd);};return cg.New(ce);},FlipBody:function(ch){var ci,cm=this,cr,cs;ci=function(){var ck,cl,cn,co,cq;ck=ch.Build();cl=cm.U.Reactive;cn=ck.Body;co=function(cp){return e.FlipEdit(cp);};cq=cl.Select(cn,co);return $.New(d,{Body:cq,Dispose1:ck.Dispose1,Notify:ck.Notify,State:ck.State});};cr=cm.New(ci);cs=ch.get_Layout();return cm.WithLayout(cs,cr);},FromState:function(ct){var cu,cw=this;cu=function(){return $.New(d,{Body:cw.U.Reactive.Never(),Dispose1:function(){},Notify:function(){},State:ct});};return cw.New(cu);},InitWith:function(cz,cA){var cB,cF=this,cJ,cK;cB=function(){var cD,cE,cG,cH,cI;cD=cA.Build();cE=cF.U.Reactive;cG=cF.U.Reactive.Return($.New(g,{$:0,$0:cz}));cH=cD.State;cI=cE.Concat(cG,cH);return $.New(d,{Body:cD.Body,Dispose1:cD.Dispose1,Notify:cD.Notify,State:cI});};cJ=cF.New(cB);cK=cA.get_Layout();return cF.WithLayout(cK,cJ);},InitWithFailure:function(cL){var cM,cQ=this,cU,cV;cM=function(){var cO,cP,cR,cS,cT;cO=cL.Build();cP=cQ.U.Reactive;cR=cQ.U.Reactive.Return($.New(g,{$:1,$0:$.New(j,{$:0})}));cS=cO.State;cT=cP.Concat(cR,cS);return $.New(d,{Body:cO.Body,Dispose1:cO.Dispose1,Notify:cO.Notify,State:cT});};cU=cQ.New(cM);cV=cL.get_Layout();return cQ.WithLayout(cV,cU);},Join:function(cW){var cX,c0=this;cX=function(){var cZ,c1,c2,c3,c8,c9,c_,c$,da,df,dg,dh,di,dk,dl,dm,dn,_do,dq,dr,ds,dt,du,dw,dy;cZ=c0.BuildForm(cW);c1=c0.U.Reactive;c2=cZ.State;c3=function(c4){var c5,c6,c7;if(c4.$==1){c6=c4.$0;c5=c0.Fail(c6);}else{c7=c4.$0;c5=c0.BuildForm(c7);}return c5;};c8=c0.U.Reactive;c9=c1.Select(c2,c3);c_=c8.Heat(c9);c$=c0.U.Reactive;da=function(db){var dc,dd,de;dc=c0.U.Reactive.Return(e.Delete());dd=c0.U.Reactive;de=db.Body;return dd.Concat(dc,de);};df=c$.Select(c_,da);dg=c0.U.Reactive;dh=c0.U.Reactive.Switch(df);di=function(dj){return $.New(f,{$:2,$0:dj});};dk=dg.Select(dh,di);dl=c0.U.Reactive;dm=c0.U.Reactive;dn=cZ.Body;_do=function(dp){return $.New(f,{$:1,$0:dp});};dq=dm.Select(dn,_do);dr=dl.Merge(dq,dk);dt=c0.U.Reactive;du=function(dv){return dv.State;};ds=c0.U.Reactive.Switch(dt.Select(c_,du));dw=function(dx){return cZ.Notify.call(null,dx);};dy=function(){return cZ.Dispose1.call(null,null);};return $.New(d,{Body:dr,Dispose1:dy,Notify:dw,State:ds});};return c0.New(cX);},LiftResult:function(dA){var dB;dB=function(dC){return $.New(g,{$:0,$0:dC});};return this.MapResult(dB,dA);},Map:function(dD,dE){var dF;dF=function(dG){return g.Map(dD,dG);};return this.MapResult(dF,dE);},MapBody:function(dH,dI){var dJ,dO=this;dJ={Apply:function(dK){var dL,dM,dN,dP,dQ,dR,dS,dT;dL=dI.get_Layout().Apply.call(null,dK);if(dL.$==0){dN=dO.U.DefaultLayout.Apply.call(null,dK);if(dN.$==0){dP={$:0};}else{dQ=dN.$0[1];dR=dN.$0[0];dP={$:1,$0:[dH(dR),dQ]};}dM=dP;}else{dS=dL.$0[1];dT=dL.$0[0];dM={$:1,$0:[dH(dT),dS]};}return dM;}};return dO.WithLayout(dJ,dI);},MapResult:function(dU,dV){var dW,d0=this;dW=function(){var dY,dZ,d1,d2,d4;dY=dV.Build();dZ=d0.U.Reactive;d1=dY.State;d2=function(d3){return dU(d3);};d4=dZ.Select(d1,d2);return $.New(d,{Body:dY.Body,Dispose1:dY.Dispose1,Notify:dY.Notify,State:d4});};return $.New(c,{Layout:dV.get_Layout(),Build1:dW,Utils:d0.U});},Never:function(){var d5,d7=this;d5=function(){return $.New(d,{Body:d7.U.Reactive.Never(),Dispose1:function(){},Notify:function(){},State:d7.U.Reactive.Never()});};return d7.New(d5);},New:function(d_){return $.New(c,{Layout:this.L.Default(),Build1:d_,Utils:this.U});},Replace:function(d$,ea){var eb,ed;eb=function(ec){return ea(ec);};ed=this.Map(eb,d$);return this.Switch(ed);},ReplaceFirstWithFailure:function(ee){var ef,ej=this,ep,eq;ef=function(){var eh,ei,ek,el,em,en,eo;eh=ee.Build();ei=ej.U.Reactive;ek=eh.State;el=ei.Drop(ek,1);em=ej.U.Reactive;en=ej.U.Reactive.Return($.New(g,{$:1,$0:$.New(j,{$:0})}));eo=em.Concat(en,el);return $.New(d,{Body:eh.Body,Dispose1:eh.Dispose1,Notify:eh.Notify,State:eo});};ep=ej.New(ef);eq=ee.get_Layout();return ej.WithLayout(eq,ep);},Return:function(er){var es,eu=this;es=function(){return $.New(d,{Body:eu.U.Reactive.Never(),Dispose1:function(ev){return ev;},Notify:function(){},State:eu.U.Reactive.Return($.New(g,{$:0,$0:er}))});};return eu.New(es);},ReturnEmpty:function(ex){var ey,eA=this;ey=function(){return $.New(d,{Body:eA.U.Reactive.Return(e.Delete()),Dispose1:function(eB){return eB;},Notify:function(){},State:eA.U.Reactive.Return($.New(g,{$:0,$0:ex}))});};return eA.New(ey);},SelectMany:function(eD){var eE,eH=this;eE=function(){var eG,eI,eJ,eK,eP,eQ,eR,eS,eT,eU,eW,eX,eZ,e4,e5,e_,e$,fa,fb,fc,fd,ff,fg,fh,fi,fk,fl,fn;eG=eH.BuildForm(eD);eI=eH.U.Reactive;eJ=eG.State;eK=function(eL){var eM,eN,eO;if(eL.$==1){eL.$0;eM={$:0};}else{eN=eL.$0;eO=eH.BuildForm(eN);eM={$:1,$0:eO};}return eM;};eP=eH.U.Reactive;eQ=eI.Choose(eJ,eK);eR=eP.Heat(eQ);eS=eH.U.Reactive;eT=eG.Body;eU=function(eV){return $.New(f,{$:1,$0:eV});};eW=eS.Select(eT,eU);eX={contents:function(eY){return $.New(f,{$:1,$0:eY});}};eZ=function(){var e1;e1=eX.contents;eX.contents=function(e2){var e3;e3=e1(e2);return $.New(f,{$:2,$0:e3});};return;};e4=eH.U.Reactive;e5=function(e6){var e7,e8,e9;eZ(null);e7=eX.contents;e8=eH.U.Reactive;e9=e6.Body;return e8.Select(e9,e7);};e_=e4.Select(eR,e5);e$=eH.U.Reactive.SelectMany(e_);fa=eH.U.Reactive;fb=fa.Merge(eW,e$);fc=eH.U.Reactive;fd=function(fe){return fe.State;};ff=fc.Select(eR,fd);fg=eH.U.Reactive;fh=eH.U.Reactive.CollectLatest(ff);fi=function(fj){return g.Sequence(fj);};fk=fg.Select(fh,fi);fl=function(fm){return eG.Notify.call(null,fm);};fn=function(){return eG.Dispose1.call(null,null);};return $.New(d,{Body:fb,Dispose1:fn,Notify:fl,State:fk});};return eH.New(eE);},Sequence:function(fp){var fq,fr,fs,ft,fu,fx,fy;fq=i.ofSeq(fp);if(fq.$==1){fs=fq.$1;ft=fq.$0;fu=this.Return(function(fv){return function(fw){return $.New(j,{$:1,$0:fv,$1:fw});};});fx=this.Sequence(fs);fy=this.Apply(fu,ft);fr=this.Apply(fy,fx);}else{fr=this.Return($.New(j,{$:0}));}return fr;},Switch:function(fz){var fA,fD=this;fA=function(){var fC,fE,fF,fG,fH,fI,fN,fO,fP,fQ,fR,fS,fT,fU,fW,fX,fY,fZ,f1,f3;fC=fD.WithLayoutOrDefault(fz);fE=fD.ApplyLayout(fC);fF=fD.BuildForm(fE);fG=fD.U.Reactive;fH=fF.State;fI=function(fJ){var fK,fL,fM;if(fJ.$==1){fJ.$0;fK={$:0};}else{fL=fJ.$0;fM=fD.BuildForm(fL);fK={$:1,$0:fM};}return fK;};fN=fD.U.Reactive;fO=fG.Choose(fH,fI);fP=fN.Heat(fO);fQ=fD.U.Reactive;fR=fF.Body;fT=fD.U.Reactive;fU=function(fV){return fV.Body;};fS=fD.U.Reactive.Switch(fT.Select(fP,fU));fW=fQ.Concat(fR,fS);fY=fD.U.Reactive;fZ=function(f0){return f0.State;};fX=fD.U.Reactive.Switch(fY.Select(fP,fZ));f1=function(f2){return fF.Notify.call(null,f2);};f3=function(){return fF.Dispose1.call(null,null);};return $.New(d,{Body:fW,Dispose1:f3,Notify:f1,State:fX});};return fD.New(fA);},WithCancelation:function(f5,f6){var f7,gd,ge,gf,gg,gh,gj;f7=function(f8){return function(f9){var f_,f$,ga,gb,gc;f_=[f8,f9];if(f_[1].$==0){f$=$.New(g,{$:0,$0:{$:0}});}else{if(f_[0].$==1){gb=f_[0].$0;ga=$.New(g,{$:1,$0:gb});}else{gc=f_[0].$0;ga=$.New(g,{$:0,$0:{$:1,$0:gc}});}f$=ga;}return f$;};};gd=this.Return(f7);ge=this.LiftResult(f5);gf=this.LiftResult(f6);gg=this.Apply(gd,ge);gh=function(gi){return g.Join(gi);};gj=this.Apply(gg,gf);return this.MapResult(gh,gj);},WithLayout:function(gk,gl){return $.New(c,{Layout:gk,Build1:function(){return gl.Build();},Utils:this.U});},WithLayoutOrDefault:function(gn){var go;go=function(gp){return gp;};return this.MapBody(go,gn);},WithNotification:function(gq,gr){var gs,gv=this,gy,gz;gs=function(){var gu,gw;gu=gv.BuildForm(gr);gw=function(gx){gu.Notify.call(null,gx);return gq(gx);};return $.New(d,{Body:gu.Body,Dispose1:gu.Dispose1,Notify:gw,State:gu.State});};gy=gv.New(gs);gz=gr.get_Layout();return gv.WithLayout(gz,gy);},WithNotificationChannel:function(gA){var gB,gF=this,gN,gO;gB=function(){var gD,gE,gG,gH,gJ,gL,gM;gD=gA.Build();gE=gF.U.Reactive;gG=gD.State;gH=function(gI){return[gI,gD.Notify];};gJ=function(gK){return g.Map(gH,gK);};gL=gE.Select(gG,gJ);gM=gD.Notify;return $.New(d,{Body:gD.Body,Dispose1:gD.Dispose1,Notify:gM,State:gL});};gN=gF.New(gB);gO=gA.get_Layout();return gF.WithLayout(gO,gN);}},{New:function(gP){var gQ;gQ=$.New(this,{});gQ.U=gP;gQ.L=k.New({Reactive:gQ.U.Reactive});return gQ;}}),LayoutUtils:$.Class({Default:function(){return{Apply:function(){return{$:0};}};},Delay:function(gS){return{Apply:function(gT){return gS(null).Apply.call(null,gT);}};},New:function(gU){return{Apply:function(gV){var gW,gX,gY;gW=gU(null);gX={contents:$.New(l,{$:0})};gY=m.subscribeTo(gV,function(gZ){var g0,g1,g2,g3;g0=e.ReplacedTree(gZ,gX.contents);gX.contents=e.Apply(gZ,gX.contents);g1=e.Range(gZ,gX.contents);g2=g1[0];gW.Remove.call(null,g0.get_Sequence());g3=function(g4){return function(g5){return(gW.Insert.call(null,g2+g4))(g5);};};return n.iteri(g3,gZ);});return{$:1,$0:[gW.Body,gY]};}};}},{New:function(){return $.New(this,{});}}),Result:$.Class({},{Apply:function(g7,g8){var g9,g_,g$,ha,hb,hc,hd,he,hf,hg;g9=[g7,g8];if(g9[0].$==1){if(g9[1].$==1){ha=g9[0].$0;hb=g9[1].$0;g$=$.New(g,{$:1,$0:i.append(ha,hb)});}else{hc=g9[0].$0;g$=$.New(g,{$:1,$0:hc});}g_=g$;}else{if(g9[1].$==1){g9[0].$0;he=g9[1].$0;hd=$.New(g,{$:1,$0:he});}else{hf=g9[0].$0;hg=g9[1].$0;hd=$.New(g,{$:0,$0:hf(hg)});}g_=hd;}return g_;},Join:function(hh){var hi,hj,hk;if(hh.$==1){hj=hh.$0;hi=$.New(g,{$:1,$0:hj});}else{hk=hh.$0;hi=hk;}return hi;},Map:function(hl,hm){var hn,ho,hp;if(hm.$==1){ho=hm.$0;hn=$.New(g,{$:1,$0:ho});}else{hp=hm.$0;hn=$.New(g,{$:0,$0:hl(hp)});}return hn;},OfOption:function(hq){var hr,hs;if(hq.$==0){hr=$.New(g,{$:1,$0:$.New(j,{$:0})});}else{hs=hq.$0;hr=$.New(g,{$:0,$0:hs});}return hr;},Sequence:function(ht){var hu;hu=function(hv){return function(hw){var hx,hy,hz,hA,hB,hC,hD,hE,hF;if(hv.$==1){hy=hv.$0;if(hw.$==1){hA=hw.$0;hz=$.New(g,{$:1,$0:i.append(hy,hA)});}else{hw.$0;hz=$.New(g,{$:1,$0:hy});}hx=hz;}else{hB=hv.$0;if(hw.$==1){hD=hw.$0;hC=$.New(g,{$:1,$0:hD});}else{hE=hw.$0;hF=i.ofArray([hE]);hC=$.New(g,{$:0,$0:i.append(hB,hF)});}hx=hC;}return hx;};};return n.fold(hu,$.New(g,{$:0,$0:$.New(j,{$:0})}),ht);}}),Tree:{Apply:function(hG,hH){var hI;hI=function(hJ,hK){var hL,hM,hN,hO,hP,hQ,hR,hS,hT,hU;if(hJ.$==1){hM=hJ.$0;if(hK.$==2){hO=hK.$1;hP=hK.$0;hN=$.New(l,{$:2,$0:hI(hM,hP),$1:hO});}else{hN=hI($.New(f,{$:1,$0:hM}),$.New(l,{$:2,$0:$.New(l,{$:0}),$1:hK}));}hL=hN;}else{if(hJ.$==2){hQ=hJ.$0;if(hK.$==2){hS=hK.$1;hT=hK.$0;hR=$.New(l,{$:2,$0:hT,$1:hI(hQ,hS)});}else{hR=hI($.New(f,{$:2,$0:hQ}),$.New(l,{$:2,$0:hK,$1:$.New(l,{$:0})}));}hL=hR;}else{hU=hJ.$0;hL=hU;}}return hL;};return hI(hG,hH);},Count:function(hV){var hW,hX,hY,hZ,h0,h1,h2,h3,h4,h5,h6,h7,h8;hW=[];hX=$.New(j,{$:0});hW[3]=hV;hW[2]=hX;hW[1]=0;hW[0]=1;while(hW[0]){if(hW[3].$==2){hZ=hW[3].$1;h0=hW[3].$0;h1=$.New(j,{$:1,$0:hZ,$1:hW[2]});h2=hW[1];hW[3]=h0;hW[2]=h1;hW[1]=h2;hY=void(hW[0]=1);}else{h3=hW[3];h4=h3.$==0?0:1;if(hW[2].$==1){h6=hW[2].$1;h7=hW[2].$0;h8=hW[1]+h4;hW[3]=h7;hW[2]=h6;hW[1]=h8;h5=void(hW[0]=1);}else{hW[0]=0;h5=void(hW[1]=hW[1]+h4);}hY=h5;}}return hW[1];},DeepFlipEdit:function(h9){var h_,h$,ia,ib;if(h9.$==1){h$=h9.$0;h_=$.New(f,{$:2,$0:e.DeepFlipEdit(h$)});}else{if(h9.$==2){ia=h9.$0;h_=$.New(f,{$:1,$0:e.DeepFlipEdit(ia)});}else{ib=h9.$0;h_=$.New(f,{$:0,$0:ib});}}return h_;},Delete:function(){return $.New(f,{$:0,$0:$.New(l,{$:0})});},Edit:$.Class({GetEnumerator:function(){var ic;ic=this.get_Sequence();return o.Get(ic);},GetEnumerator1:function(){var id;id=this.get_Sequence();return o.Get(id);},get_Sequence:function(){var ie,_if,ig,ih;if(this.$==1){_if=this.$0;ie=_if.get_Sequence();}else{if(this.$==2){ig=this.$0;ie=ig.get_Sequence();}else{ih=this.$0;ie=ih.get_Sequence();}}return ie;}}),FlipEdit:function(ii){var ij,ik,il,im;if(ii.$==1){ik=ii.$0;ij=$.New(f,{$:2,$0:ik});}else{if(ii.$==2){il=ii.$0;ij=$.New(f,{$:1,$0:il});}else{im=ii.$0;ij=$.New(f,{$:0,$0:im});}}return ij;},FromSequence:function(_in){var io,ir;io=function(ip){return function(iq){return $.New(l,{$:2,$0:ip,$1:$.New(l,{$:1,$0:iq})});};};ir=$.New(l,{$:0});return n.fold(io,ir,_in);},Range:function(is,it){var iu,iv,iw,ix,iy,iz,iA,iB,iC,iD,iE,iF,iG,iH;iu=[];iu[3]=0;iu[2]=it;iu[1]=is;iu[0]=1;while(iu[0]){if(iu[1].$==1){iw=iu[1].$0;if(iu[2].$==2){iu[2].$1;iy=iu[2].$0;iu[3]=iu[3];iu[2]=iy;iu[1]=iw;ix=void(iu[0]=1);}else{iz=iu[3];iA=$.New(l,{$:0});iu[3]=iz;iu[2]=iA;iu[1]=iw;ix=void(iu[0]=1);}iv=ix;}else{if(iu[1].$==2){iB=iu[1].$0;if(iu[2].$==2){iD=iu[2].$1;iE=iu[2].$0;iu[3]=iu[3]+e.Count(iE);iu[2]=iD;iu[1]=iB;iC=void(iu[0]=1);}else{iF=iu[2];iG=iu[3]+e.Count(iF);iH=$.New(l,{$:0});iu[3]=iG;iu[2]=iH;iu[1]=iB;iC=void(iu[0]=1);}iv=iC;}else{iu[1].$0;iu[0]=0;iv=void(iu[1]=[iu[3],e.Count(iu[2])]);}}}return iu[1];},ReplacedTree:function(iI,iJ){var iK,iL,iM,iN,iO,iP,iQ;if(iI.$==1){iL=iI.$0;if(iJ.$==2){iJ.$1;iN=iJ.$0;iM=e.ReplacedTree(iL,iN);}else{iM=e.ReplacedTree($.New(f,{$:1,$0:iL}),$.New(l,{$:2,$0:$.New(l,{$:0}),$1:iJ}));}iK=iM;}else{if(iI.$==2){iO=iI.$0;if(iJ.$==2){iQ=iJ.$1;iJ.$0;iP=e.ReplacedTree(iO,iQ);}else{iP=e.ReplacedTree($.New(f,{$:2,$0:iO}),$.New(l,{$:2,$0:iJ,$1:$.New(l,{$:0})}));}iK=iP;}else{iI.$0;iK=iJ;}}return iK;},Set:function(iR){return $.New(f,{$:0,$0:$.New(l,{$:1,$0:iR})});},ShowEdit:function(iS){var iT;iT=function(iU){var iV,iW,iX;if(iU.$==1){iW=iU.$0;iV="Left > "+iT(iW);}else{if(iU.$==2){iX=iU.$0;iV="Right > "+iT(iX);}else{iV="Replace";}}return iV;};return iT(iS);},Transform:function(iY,iZ){var i0,i1,i2,i3,i4,i5;if(iZ.$==1){i1=iZ.$0;i2=e.Transform(iY,i1);i0=$.New(f,{$:1,$0:i2});}else{if(iZ.$==2){i3=iZ.$0;i4=e.Transform(iY,i3);i0=$.New(f,{$:2,$0:i4});}else{i5=iZ.$0;i0=$.New(f,{$:0,$0:iY(i5)});}}return i0;},Tree:$.Class({GetEnumerator:function(){var i6;i6=this.get_Sequence();return o.Get(i6);},GetEnumerator1:function(){var i7;i7=this.get_Sequence();return o.Get(i7);},Map:function(i8){var i9,i_,i$,ja;if(this.$==1){i_=this.$0;i9=$.New(l,{$:1,$0:i8(i_)});}else{if(this.$==2){i$=this.$1;ja=this.$0;i9=$.New(l,{$:2,$0:ja.Map(i8),$1:i$.Map(i8)});}else{i9=$.New(l,{$:0});}}return i9;},get_Sequence:function(){var jb,jc,jd,je;if(this.$==1){jc=this.$0;jb=[jc];}else{if(this.$==2){jd=this.$1;je=this.$0;jb=n.append(je.get_Sequence(),jd.get_Sequence());}else{jb=n.empty();}}return jb;}})},Validator:$.Class({Is:function(jf,jg,jh){return this.Validate(jf,jg,jh);},IsEmail:function(ji){var jk=this;return function(jj){return jk.IsRegexMatch("^[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\\.)+[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?$",ji,jj);};},IsEqual:function(jl,jm,jn){var jo;jo=function(jp){return p.Equals(jp,jl);};return this.Validate(jo,jm,jn);},IsFloat:function(jq){var js=this;return function(jr){return js.IsRegexMatch("^\\s*(\\+|-)?((\\d+(\\.\\d+)?)|(\\.\\d+))\\s*$",jq,jr);};},IsGreaterThan:function(jt,ju,jv){var jw;jw=function(jx){return p.Compare(jx,jt)===1;};return this.Validate(jw,ju,jv);},IsInt:function(jy){var jA=this;return function(jz){return jA.IsRegexMatch("^-?\\d+$",jy,jz);};},IsLessThan:function(jB,jC,jD){var jE;jE=function(jF){return p.Compare(jF,jB)===-1;};return this.Validate(jE,jC,jD);},IsNotEmpty:function(jG,jH){var jI;jI=function(jJ){return jJ!=="";};return this.Validate(jI,jG,jH);},IsNotEqual:function(jK,jL,jM){var jN;jN=function(jO){return!p.Equals(jO,jK);};return this.Validate(jN,jL,jM);},IsRegexMatch:function(jP,jQ,jR){var jS,jV=this;jS=function(jT){var jU;jU=jV.VP;return jU.Matches(jP,jT);};return jV.Validate(jS,jQ,jR);},IsTrue:function(jW,jX){var jY;jY=function(jZ){return jZ;};return this.Validate(jY,jW,jX);},Validate:function(j0,j1,j2){var j3;j3=j2.MapResult(function(j4){var j5,j6,j7;if(j4.$==1){j6=j4.$0;j5=$.New(g,{$:1,$0:j6});}else{j7=j4.$0;j5=j0(j7)?$.New(g,{$:0,$0:j7}):$.New(g,{$:1,$0:i.ofArray([j1])});}return j5;});return j3;}},{New:function(j8){var j9;j9=$.New(this,{});j9.VP=j8;return j9;}})}}}});$.OnInit(function(){a=$.Safe($$.IntelliFactory.Formlets);b=$.Safe(a.Base);c=$.Safe(b.Formlet);d=$.Safe(b.Form);e=$.Safe(b.Tree);f=$.Safe(e.Edit);g=$.Safe(b.Result);h=$.Safe($$.IntelliFactory.WebSharper);i=$.Safe(h.List);j=$.Safe(i.T);k=$.Safe(b.LayoutUtils);l=$.Safe(e.Tree);m=$.Safe(h.Util);n=$.Safe(h.Seq);o=$.Safe(h.Enumerator);return p=$.Safe(h.Unchecked);});$.OnLoad(function(){return;});}());

(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_0,_1,_2,_3;$.Define($$,{IntelliFactory:{WebSharper:{Formlets:{Body:$.Class({},{New:function(_4,_5){return $.New(c,{Element:_4,Label:_5});}}),Controls:{Button:function(_6){var _7;_7=function(){return f.Button(g.ofArray([f.Text(_6)]));};return h.ElementButton(_7);},Checkbox:function(_9){return h.CheckboxControl(false,_9);},CheckboxControl:function(_,ba){var bb;bb=function(){var bd,be,bf,bg,bh,bi,bj,bp,bq,br,bs,bt,bu,bv;bd=j.New($.New(m,{$:0,$0:ba}));if(_){bg=f.Attr();bf=g.ofArray([bg.NewAttr("disabled","disabled")]);}else{bf=$.New(n,{$:0});}be=bf;bi=f.Attr();bh=o.add(f.Input(g.ofArray([bi.NewAttr("type","checkbox"),f.Attr().Class("inputCheckbox")])),be);bj=function(bk){return function(){var bm,bn,bo;if(!_){bn=p(bk.get_Body()).prop("checked");bo=$.New(m,{$:0,$0:bn});bm=bd.Trigger(bo);}else{bm=null;}return bm;};};q.Events().OnClick(bj,bh);bp=bh;if(ba){br=bp["HtmlProvider@33"];bs=bp.get_Body();bq=br.SetAttribute(bs,"defaultChecked","true");}else{bt=bp["HtmlProvider@33"];bu=bp.get_Body();bq=bt.RemoveAttribute(bu,"checked");}bv=function(){var bx,by,bz,bA,bB,bC,bD;if(ba){by=bp["HtmlProvider@33"];bz=bp.get_Body();bx=by.SetProperty(bz,"checked",true);}else{bA=bp["HtmlProvider@33"];bB=bp.get_Body();bA.RemoveAttribute(bB,"checked");bC=bp["HtmlProvider@33"];bD=bp.get_Body();bx=bC.SetProperty(bD,"checked",false);}return bd.Trigger($.New(m,{$:0,$0:ba}));};bv(null);return[bp,bv,bd];};return r.MkFormlet(bb);},CheckboxGroup:function(bD){return h.CheckboxGroupControl(false,bD);},CheckboxGroupControl:function(bE,bF){var bG,bU,bV,bW,b0;bG=$.Tupled(function(bH){var bI,bJ,bK,bL,bM,bQ,bR,bT;bI=bH[0];bJ=bH[1];bK=bH[2];bL=h.CheckboxControl(bE,bK);bM=function(){var bO,bP;bO=g.ofArray([f.Text(bI)]);bP=f.Tags();return bP.NewTag("label",bO);};bQ={$:1,$0:bM};bR=function(bS){return[bS,bJ];};bT=s.WithLabel(bQ,bL);return s.Map(bR,bT);});bU=g.map(bG,bF);bV=s.Sequence(bU);bW=$.Tupled(function(bX){var bY,bZ;bY=bX[0];bZ=bX[1];return bY?{$:1,$0:bZ}:{$:0};});b0=function(b1){return g.choose(bW,b1);};return s.Map(b0,bV);},ElementButton:function(b2){var b3;b3=function(){var b5,b6,b7,b8,b$,ca;b5=j.New($.New(m,{$:1,$0:$.New(n,{$:0})}));b6={contents:0};b7=b2(null);b8=function(){return function(){b5.Trigger($.New(m,{$:0,$0:b6.contents}));return t.Increment(b6);};};q.Events().OnClick(b8,b7);b$=b7;ca=function(){b6.contents=0;return b5.Trigger($.New(m,{$:1,$0:$.New(n,{$:0})}));};return[b$,ca,b5];};return r.MkFormlet(b3);},Input:function(cc){return h.InputField(false,"text",u.InputTextClass(),cc);},InputControl:function(cd,ce){var cf;cf=function(){var ch,ci,cj;ch=j.New($.New(m,{$:0,$0:cd}));ci=ce(ch);ci.set_Value(cd);cj=function(){ci.set_Value(cd);return ch.Trigger($.New(m,{$:0,$0:cd}));};return[ci,cj,ch];};return r.MkFormlet(cf);},InputField:function(cl,cm,cn,co){return h.InputControl(co,function(cp){var cq,cr,cs,ct,cu,cv,cw,cx;if(cl){cs=f.Attr();cr=g.ofArray([cs.NewAttr("readonly","readonly")]);}else{cr=$.New(n,{$:0});}cq=cr;cu=f.Attr();ct=g.ofArray([cu.NewAttr("type",cm),f.Attr().Class(cn)]);cv=g.append(ct,cq);cw=f.Input(cv);cx=function(){return!cl?cp.Trigger($.New(m,{$:0,$0:cw.get_Value()})):null;};h.OnTextChange(cx,cw);return cw;});},OnTextChange:function(cz,cA){var cB,cC,cF,cH;cB={contents:cA.get_Value()};cC=function(){var cE;if(cA.get_Value()!==cB.contents){cB.contents=cA.get_Value();cE=cz(null);}else{cE=null;}return cE;};cF=function(){return cC(null);};q.Events().OnChange(cF,cA);cH=function(){return function(){return cC(null);};};q.Events().OnKeyUp(cH,cA);cA.Dom.oninput=cC;return;},Password:function(cK){return h.InputField(false,"password","inputPassword",cK);},RadioButtonGroup:function(cL,cM){return h.RadioButtonGroupControl(false,cL,cM);},RadioButtonGroupControl:function(cN,cO,cP){var cQ;cQ=function(){var cS,cT,cU,cV,cW,c0,c1,c7,c8,c_,c$,di,dj,dw,dD,dQ,dR,dS,dT;cS="id"+v.round(v.random()*100000000);if(cO.$==0){cU={$:0};}else{cV=cO.$0;cW=function(cX){return $.Tupled(function(cY){var cZ;cY[0];cZ=cY[1];return[cX,cZ];});};c0=g.mapi(cW,cP);c1=$.Tupled(function(c2){var c3,c4,c5,c6;c3=c2[0];c4=c2[1];if(cO.$==0){c5={$:0};}else{c6=cO.$0;c5=c6===c3?{$:1,$0:$.New(m,{$:0,$0:c4})}:{$:0};}return c5;});cU=w.tryPick(c1,c0);}cT=cU;c7=j.New($.New(m,{$:1,$0:$.New(n,{$:0})}));c8=function(c9){return j.New(c9);};c_=x.Maybe(c7,c8,cT);c$=$.Tupled(function(da){var db,dc,dd,de,df,dg,dh;db=da[0];dc=da[1];de=f.Attr();df=f.Attr();if(cN){dh=f.Attr();dg=g.ofArray([dh.NewAttr("disabled","disabled")]);}else{dg=$.New(n,{$:0});}dd=o.add(f.Input(g.ofArray([f.Attr().Class("inputRadio"),de.NewAttr("type","radio"),df.NewAttr("name",cS)])),dg);return[dd,db,dc];});di=g.map(c$,cP);dj=function(dk,dl,dm){var dn,_do,dp,dq,dr,ds,dt,du,dv;if(cO.$==0){_do=dk["HtmlProvider@33"];dp=dk.get_Body();_do.RemoveAttribute(dp,"checked");dn=c_.Trigger($.New(m,{$:1,$0:$.New(n,{$:0})}));}else{dq=cO.$0;if(dq===dm){ds=dk["HtmlProvider@33"];dt=dk.get_Body();ds.SetProperty(dt,"checked",true);dr=c_.Trigger($.New(m,{$:0,$0:dl}));}else{du=dk["HtmlProvider@33"];dv=dk.get_Body();dr=du.SetProperty(dv,"checked",false);}dn=dr;}return dn;};dw=function(){var dy;dy=function(dz){return $.Tupled(function(dA){var dB,dC;dB=dA[0];dA[1];dC=dA[2];return dj(dB,dC,dz);});};return w.iteri(dy,di);};dD=function(dE){return $.Tupled(function(dF){var dG,dH,dI,dJ,dM;dG=dF[0];dH=dF[1];dI=dF[2];dj(dG,dI,dE);dJ=function(){return function(){return!cN?c_.Trigger($.New(m,{$:0,$0:dI})):null;};};q.Events().OnClick(dJ,dG);dM={$:1,$0:function(){var dO,dP;dO=g.ofArray([f.Text(dH)]);dP=f.Tags();return dP.NewTag("label",dO);}};return $.New(c,{Element:dG,Label:dM});});};dQ=g.mapi(dD,di);dR=y.FromSequence(dQ);dS=$.New(z,{$:0,$0:dR});dT=r.RX().Return(dS);return $.New(A,{Body:dT,Dispose1:function(){},Notify:function(){return dw(null);},State:c_});};return s.New(cQ);},ReadOnlyCheckbox:function(dW){return h.CheckboxControl(true,dW);},ReadOnlyInput:function(dX){return h.InputField(true,"text",u.InputTextClass(),dX);},ReadOnlyRadioButtonGroup:function(dY,dZ){return h.RadioButtonGroupControl(true,dY,dZ);},ReadOnlySelect:function(d0,d1){return h.SelectControl(true,d0,d1);},ReadOnlyTextArea:function(d2){return h.TextAreaControl(true,d2);},Select:function(d3,d4){return h.SelectControl(false,d3,d4);},SelectControl:function(d5,d6,d7){var d8;d8=function(){var d_,ea,eb,ec,ed,el,em,en,eo,ep,eq,er,es,ex;d_=$.Tupled(function(d$){return d$[1];});ea=g.map(d_,d7);eb=B.ofSeq(ea);ec=(d6>=0?d6<d7.get_Length():false)?d6:0;ed=function(ee){return $.Tupled(function(ef){var eg,eh,ei,ej,ek;eg=ef[0];ef[1];eh=f.Tags();ej=f.Attr();ek=$$.String(ee);ei=g.ofArray([f.Text(eg),ej.NewAttr("value",ek)]);return eh.NewTag("option",ei);});};el=g.mapi(ed,d7);em=f.Select(el);if(d5){ep=f.Attr();eo=o.add(em,g.ofArray([ep.NewAttr("disabled","disabled")]));}else{eo=em;}en=eo;eq=$.New(m,{$:0,$0:C.GetArray(eb,ec)});er=j.New(eq);es=function(){var eu,ev,ew;eu=$$.String(ec);ev=en["HtmlProvider@33"];ew=en.get_Body();ev.SetProperty(ew,"value",eu);return er.Trigger(eq);};es(null);ex=function(){var ez,eA,eB,eC;if(!d5){eA=en.get_Value();eB=C.GetArray(eb,eA<<0);eC=$.New(m,{$:0,$0:eB});ez=er.Trigger(eC);}else{ez=null;}return ez;};q.Events().OnChange(ex,en);es(null);return[en,es,er];};return r.MkFormlet(d8);},TextArea:function(eD){return h.TextAreaControl(false,eD);},TextAreaControl:function(eE,eF){return h.InputControl(eF,function(eG){var eH,eI,eJ,eK,eL;if(eE){eJ=f.Attr();eI=g.ofArray([eJ.NewAttr("readonly","readonly")]);}else{eI=$.New(n,{$:0});}eH=eI;eK=f.TextArea(eH);eL=function(){return!eE?eG.Trigger($.New(m,{$:0,$0:eK.get_Value()})):null;};h.OnTextChange(eL,eK);return eK;});}},CssConstants:{InputTextClass:$.Field(function(){return"inputText";})},Data:{$:function(eN,eO){var eP,eQ;eP=r.BaseFormlet();eQ=eP.Apply(eN,eO);return r.OfIFormlet(eQ);},BaseFormlet:function(){return D.New(r.UtilsProvider());},DefaultLayout:$.Field(function(){return r.Layout().get_Vertical();}),Formlet:$.Class({Build:function(){return this.buildInternal.call(null,null);},MapResult:function(eR){var eS,eV=this;eS=E.New(function(){var eU,eW,eX,eY;eU=eV.buildInternal.call(null,null);eW=eV.utils.Reactive;eX=eU.State;eY=function(eZ){return eR(eZ);};return $.New(A,{Body:eU.Body,Dispose1:eU.Dispose1,Notify:eU.Notify,State:eW.Select(eX,eY)});},eV.layoutInternal,eV.formletBase,eV.utils);return eS;},Render:function(){return this.Run(function(){}).Render();},Run:function(e1){var e2,e3,e4,e5,e6,e9,e_,e$,fa,fb,fc,fd;e2=this.get_ElementInternal();if(e2.$==0){e4=this.formletBase.ApplyLayout(this);e5=e4.Build();e6=G.subscribeTo(e5.State,function(e7){var e8;e8=m.Map(e1,e7);return;});e9=e4.get_Layout().Apply.call(null,e5.Body);if(e9.$==0){fa=r.DefaultLayout().Apply.call(null,e5.Body).$0;fb=fa[0];e$=fb.Element;}else{fc=e9.$0[0];e$=fc.Element;}e_=e$;this.set_ElementInternal({$:1,$0:e_});e3=e_;}else{fd=e2.$0;e3=fd;}return e3;},get_Body:function(){return this.Run(function(){}).get_Body();},get_ElementInternal:function(){return this["ElementInternal@"];},get_Layout:function(){return this.layoutInternal;},set_ElementInternal:function(ff){this["ElementInternal@"]=ff;return;}},{New:function(fg,fh,fi,fj){var fk;fk=$.New(this,F.New());fk.buildInternal=fg;fk.layoutInternal=fh;fk.formletBase=fi;fk.utils=fj;fk["ElementInternal@"]={$:0};return fk;}}),Layout:$.Field(function(){return H.New(I.New({Reactive:J.Default()}));}),MkFormlet:function(fl){var fm,fn,fy;fm=r.BaseFormlet();fn=function(){var fp,fq,fr,fs,ft,fv,fw;fp=fl(null);fq=fp[2];fr=fp[1];fs=fp[0];ft=function(){return fr(null);};fv=r.NewBody(fs,{$:0});fw=y.Set(fv);return $.New(A,{Body:r.RX().Return(fw),Dispose1:function(){return null;},Notify:ft,State:fq});};fy=fm.New(fn);return r.OfIFormlet(fy);},NewBody:function(fz,fA){return c.New(fz,fA);},OfIFormlet:function(fB){var fC;fC=E.New(function(){return fB.Build();},fB.get_Layout(),r.BaseFormlet(),r.UtilsProvider());return r.PropagateRenderFrom(fB,fC);},PropagateRenderFrom:function(fE,fF){fE.hasOwnProperty("Render")?void(fF.Render=fE.Render):null;return fF;},RX:$.Field(function(){return J.Default();}),UtilsProvider:function(){return{Reactive:r.RX(),DefaultLayout:r.DefaultLayout()};},Validator:$.Field(function(){return K.New(L.New());}),ValidatorProvidor:$.Class({Matches:function(fG,fH){return fH.match(new M(fG));}},{New:function(){return $.New(this,{});}})},ElementStore:$.Class({Init:function(){this.store=O.New2();return;},RegisterElement:function(fI,fJ){var fK;fK=this.store.ContainsKey(fI);return!fK?this.store.set_Item(fI,fJ):null;},Remove:function(fL){var fM,fN;if(this.store.ContainsKey(fL)){(this.store.get_Item(fL))(null);fN=this.store.Remove(fL);fM=void fN;}else{fM=null;}return fM;}},{New:function(){return $.New(this,{});},NewElementStore:function(){var fO;fO=P.New();fO.Init();return fO;}}),Enhance:{Cancel:function(fP,fQ){return s.Replace(fP,function(fR){return fQ(fR)?s.Empty():s.Return(fR);});},CustomMany:function(fS,fT){var fU,fW,fX,fZ,f1,f2,f3,f4,f5,f6,gc,gd,ge,gf,gh,gi;fU=h.ElementButton(function(){return o.add(f.Div(g.ofArray([f.Attr().Class(fS.AddIconClass)])),g.ofArray([f.Div($.New(n,{$:0}))]));});fW=s.InitWith(1,fU);fX=function(){};fZ=h.ElementButton(function(){return o.add(f.Div(g.ofArray([f.Attr().Class(fS.RemoveIconClass)])),g.ofArray([f.Div($.New(n,{$:0}))]));});f1=s.Map(fX,fZ);f2=s.WithCancelation(fT,f1);f3=r.Layout().get_Horizontal();f4=s.WithLayout(f3,f2);f5=Q.Deletable(f4);f6=function(){var f8,f_,ga,gb;f8=function(f9){return g.ofSeq(f9);};f_=Q.Many_(fW,function(){return f5;});ga=s.Map(f8,f_);gb=s.WithLayoutOrDefault(ga);return s.ApplyLayout(gb);};gc=j.New($.New(m,{$:0,$0:null}));gd=r.BaseFormlet().FromState(gc);ge=r.OfIFormlet(gd);gf=function(){return gc.Trigger($.New(m,{$:0,$0:null}));};gh=s.Do();gi=gh.Delay(function(){return gh.Bind(ge,function(){return gh.ReturnFrom(f6(null));});});return s.WithNotification(gf,gi);},Deletable:function(gl){return Q.Replace(gl,function(gm){var gn,go;if(gm.$==1){go=gm.$0;gn=s.Return({$:1,$0:go});}else{gn=s.ReturnEmpty({$:0});}return gn;});},FormButtonConfiguration:$.Class({},{get_Default:function(){return $.New(R,{Label:{$:0},Style:{$:0},Class:{$:0}});}}),FormContainerConfiguration:$.Class({},{get_Default:function(){var gp;gp={$:0};return $.New(S,{Header:{$:0},Padding:T.get_Default(),Description:gp,BackgroundColor:{$:0},BorderColor:{$:0},CssClass:{$:0},Style:{$:0}});}}),InputButton:function(gq,gr){var gs;gs=function(){var gu,gv,gw,gy,gz,gA,gB,gE,gF,gG,gH,gI,gJ,gK,gL,gM,gN,gO,gP,gQ,gR,gS,gT;gu=j.New($.New(m,{$:1,$0:$.New(n,{$:0})}));gv={contents:0};gw=x.Maybe("Submit",function(gx){return gx;},gq.Label);gz=f.Attr();gA=f.Attr();gy=o.add(f.Input(g.ofArray([gz.NewAttr("type","button")])),g.ofArray([f.Attr().Class("submitButton"),gA.NewAttr("value",gw)]));gB=function(){return function(){t.Increment(gv);return gu.Trigger($.New(m,{$:0,$0:gv.contents}));};};q.Events().OnClick(gB,gy);gE=gy;if(!gr){gH=gE["HtmlProvider@33"];gI=gE.get_Body();gG=gH.AddClass(gI,"disabledButton");}else{gG=null;}gJ=gq.Style;if(gJ.$==1){gL=gJ.$0;gM=gE["HtmlProvider@33"];gN=gE.get_Body();gK=gM.SetStyle(gN,gL);}else{gK=null;}gO=gq.Class;if(gO.$==1){gQ=gO.$0;gR=gE["HtmlProvider@33"];gS=gE.get_Body();gP=gR.AddClass(gS,gQ);}else{gP=null;}gF=gE;gT=function(){gv.contents=0;return gu.Trigger($.New(m,{$:1,$0:$.New(n,{$:0})}));};gu.Trigger($.New(m,{$:1,$0:$.New(n,{$:0})}));return[gF,gT,gu];};return r.MkFormlet(gs);},Many:function(gV){return Q.CustomMany(U.get_Default(),gV);},ManyConfiguration:$.Class({},{get_Default:function(){return $.New(U,{AddIconClass:"addIcon",RemoveIconClass:"removeIcon"});}}),Many_:function(gW,gX){var gY,g0,g2,g4,g5,g6;gY=function(gZ){return gX(gZ);};g0=function(g1){return g1;};g2=function(g3){return w.choose(g0,g3);};g4=s.Map(gY,gW);g5=s.SelectMany(g4);g6=s.FlipBody(g5);return s.Map(g2,g6);},Padding:$.Class({},{get_Default:function(){return $.New(T,{Left:{$:0},Right:{$:0},Top:{$:0},Bottom:{$:0}});}}),Replace:function(g7,g8){var g9,hd;g9=function(g_){var g$,ha,hb,hc;if(g_.$==1){ha=g_.$0;hb=s.FailWith(ha);g$=$.New(m,{$:0,$0:hb});}else{hc=g_.$0;g$=$.New(m,{$:0,$0:g8(hc)});}return g$;};hd=s.MapResult(g9,g7);return s.Switch(hd);},ValidationFrameConfiguration:$.Class({},{get_Default:function(){return $.New(V,{ValidClass:{$:1,$0:"successFormlet"},ValidStyle:{$:0},ErrorClass:{$:1,$0:"errorFormlet"},ErrorStyle:{$:0}});}}),ValidationIconConfiguration:$.Class({},{get_Default:function(){return $.New(W,{ValidIconClass:"validIcon",ErrorIconClass:"errorIcon"});}}),WithCssClass:function(he,hf){var hg;hg=function(hh){var hi,hj;hi=hh["HtmlProvider@33"];hj=hh.get_Body();hi.AddClass(hj,he);return hh;};return s.MapElement(hg,hf);},WithCustomFormContainer:function(hk,hl){var hm,hn;hm=s.ApplyLayout(hl);hn=function(ho){var hp,hq,hr,hw,hx,hy,hz,hG,hH,hI,hN,hO,hP,hR,hS,hU,hV,hX,hY,h0,h1,h3,h4,ia,ib,ic,id,ie,_if,ig,ih,ii,ij;hp=hk.Description;hq=$.New(n,{$:0});hr=function(hs){var ht,hu,hv;if(hs.$==1){hu=hs.$0;ht=g.ofArray([hu(null)]);}else{hv=hs.$0;ht=g.ofArray([f.P(g.ofArray([f.Tags().text(hv)]))]);}return ht;};hw=x.Maybe(hq,hr,hp);hx=hk.Header;hy=x.InTable(g.ofArray([g.ofArray([o.add(f.Div(g.ofArray([f.Attr().Class("headerPanel")])),hw)]),g.ofArray([ho])]));hz=function(hA){var hB,hC,hD,hE,hF;if(hA.$==1){hD=hA.$0;hC=hD(null);}else{hE=hA.$0;hC=f.H1(g.ofArray([f.Tags().text(hE)]));}hB=hC;hF=o.add(f.Div(g.ofArray([f.Attr().Class("headerPanel")])),$.New(n,{$:1,$0:hB,$1:hw}));return x.InTable(g.ofArray([g.ofArray([hF]),g.ofArray([ho])]));};hG=x.Maybe(hy,hz,hx);hH=o.add(f.TD(g.ofArray([f.Attr().Class("formlet")])),g.ofArray([hG]));hI=function(hJ){var hK,hL,hM;hK="border-color: "+hJ;hL=hH["HtmlProvider@33"];hM=hH.get_Body();return hL.SetStyle(hM,hK);};hN=hk.BorderColor;x.Maybe(null,hI,hN);hP=function(hQ){return hQ;};hR=hk.BackgroundColor;hS=function(hT){return $$.String(hT)+"px";};hU=hk.Padding.Left;hV=function(hW){return $$.String(hW)+"px";};hX=hk.Padding.Right;hY=function(hZ){return $$.String(hZ)+"px";};h0=hk.Padding.Top;h1=function(h2){return $$.String(h2)+"px";};h3=hk.Padding.Bottom;hO=g.ofArray([["background-color",x.MapOption(hP,hR)],["padding-left",x.MapOption(hS,hU)],["padding-right",x.MapOption(hV,hX)],["padding-top",x.MapOption(hY,h0)],["padding-bottom",x.MapOption(h1,h3)]]);h4=$.Tupled(function(h5){var h6,h7,h8,h9,h_,h$;h6=h5[0];h7=h5[1];if(h7.$==0){h8=null;}else{h9=h7.$0;h_=hH["HtmlProvider@33"];h$=hH.get_Body();h8=h_.SetCss(h$,h6,h9);}return h8;});w.iter(h4,hO);ia=hk.Style;if(ia.$==0){ib=null;}else{ic=ia.$0;id=hH["HtmlProvider@33"];ie=hH.get_Body();ib=id.SetStyle(ie,ic);}_if=hk.CssClass;if(_if.$==0){ig=null;}else{ih=_if.$0;ii=hH["HtmlProvider@33"];ij=hH.get_Body();ig=ii.AddClass(ij,ih);}return f.Table(g.ofArray([f.TBody(g.ofArray([f.TR(g.ofArray([hH]))]))]));};return s.MapElement(hn,hm);},WithCustomResetButton:function(ik,il){var im,_in,io,ip;im=ik.Label;if(im.$==0){io=$.New(R,{Label:{$:1,$0:"Reset"},Style:ik.Style,Class:ik.Class});}else{im.$0;io=ik;}_in=io;ip=Q.InputButton(_in,true);return Q.WithResetFormlet(il,ip);},WithCustomSubmitAndResetButtons:function(iq,ir,is){var it;it=function(iu){return function(iv){var iw,ix,iy,iz,iB,iC,iD,iF,iG,iH,iK,iN;if(iv.$==1){iy=iv.$0;iz=function(){return $.New(m,{$:1,$0:iy});};iB=Q.InputButton(iq,false);ix=s.MapResult(iz,iB);}else{iC=iv.$0;iD=function(){return iC;};iF=Q.InputButton(iq,true);ix=s.Map(iD,iF);}iw=ix;iG=s.Do();iH=iG.Delay(function(){return iG.Bind(s.LiftResult(Q.InputButton(ir,true)),function(iJ){iJ.$==0?iu(null):null;return iG.Return(null);});});iK=r.$(r.$(s.Return(function(iL){return function(){return iL;};}),iw),iH);iN=r.Layout().get_Horizontal();return s.WithLayout(iN,iK);};};return Q.WithSubmitAndReset(is,it);},WithCustomSubmitButton:function(iO,iP){var iQ,iR,iS;iQ=iO.Label;if(iQ.$==0){iS=$.New(R,{Label:{$:1,$0:"Submit"},Style:iO.Style,Class:iO.Class});}else{iQ.$0;iS=iO;}iR=iS;return Q.WithSubmitFormlet(iP,function(iT){var iU,iW,iX;iU=function(){};iW=iT.$==0?true:false;iX=Q.InputButton(iR,iW);return s.Map(iU,iX);});},WithCustomValidationFrame:function(iY,iZ){var i0;i0=function(i1){return function(i2){var i3,i4;i3=f.Div(g.ofArray([i2.Element]));i4=function(i5){var i6;i6=G.subscribeTo(i1,function(i7){var i8,i9,i_,i$,ja,jb,jc,jd,je,jf,jg,jh,ji,jj,jk,jl,jm,jn,jo,jp,jq,jr,js,jt,ju,jv,jw,jx,jy,jz,jA,jB,jC,jD,jE,jF;if(i7.$==1){i9=i7.$0;i_=iY.ValidClass;if(i_.$==1){ja=i_.$0;jb=i5["HtmlProvider@33"];jc=i5.get_Body();i$=jb.RemoveClass(jc,ja);}else{i$=null;}jd=iY.ErrorClass;if(jd.$==1){jf=jd.$0;jg=i5["HtmlProvider@33"];jh=i5.get_Body();je=jg.AddClass(jh,jf);}else{je=null;}ji=iY.ErrorStyle;if(ji.$==1){jk=ji.$0;jl=i5["HtmlProvider@33"];jm=i5.get_Body();jj=jl.SetStyle(jm,jk);}else{jn=i5["HtmlProvider@33"];jo=i5.get_Body();jj=jn.SetStyle(jo,"");}i8=jj;}else{jp=iY.ErrorClass;if(jp.$==1){jr=jp.$0;js=i5["HtmlProvider@33"];jt=i5.get_Body();jq=js.RemoveClass(jt,jr);}else{jq=null;}ju=iY.ValidClass;if(ju.$==1){jw=ju.$0;jx=i5["HtmlProvider@33"];jy=i5.get_Body();jv=jx.AddClass(jy,jw);}else{jv=null;}jz=iY.ValidStyle;if(jz.$==1){jB=jz.$0;jC=i5["HtmlProvider@33"];jD=i5.get_Body();jA=jC.SetStyle(jD,jB);}else{jE=i5["HtmlProvider@33"];jF=i5.get_Body();jA=jE.SetStyle(jF,"");}i8=jA;}return i8;});return;};o.OnAfterRender(i4,i3);return i3;};};return Q.WrapFormlet(i0,iZ);},WithCustomValidationIcon:function(jG,jH){var jI,jJ,jV,jW,jY,j2,j3;jI=s.WithLayoutOrDefault(jH);jJ=function(jK){var jL;jL=function(){var jN,jO,jP,jS,jT,jU;if(jK.$==1){jO=jK.$0;jP=function(jQ){return function(jR){return jQ+" "+jR;};};jS=w.fold(jP,"",jO);jT=f.Attr();jN=o.add(f.Div(g.ofArray([f.Attr().Class(jG.ErrorIconClass),jT.NewAttr("title",jS)])),g.ofArray([f.Div($.New(n,{$:0}))]));}else{jU=f.Attr();jN=o.add(f.Div(g.ofArray([f.Attr().Class(jG.ValidIconClass),jU.NewAttr("title","")])),g.ofArray([f.Div($.New(n,{$:0}))]));}return jN;};return s.OfElement(jL);};jV=s.Do();jW=function(jX){return m.Join(jX);};jY=jV.Delay(function(){return jV.Bind(s.LiftResult(jI),function(j0){return jV.Bind(jJ(j0),function(){return jV.Return(j0);});});});j2=s.MapResult(jW,jY);j3=r.Layout().get_Horizontal();return s.WithLayout(j3,j2);},WithErrorFormlet:function(j4,j5){var j6,j7,j9;j6=s.Do();j7=function(j8){return m.Join(j8);};j9=j6.Delay(function(){return j6.Bind(s.LiftResult(j5),function(j$){var ka,kb,kc;if(j$.$==1){kb=j$.$0;kc=s.Do();ka=kc.Delay(function(){return kc.Bind(j4(kb),function(){return kc.Return(j$);});});}else{j$.$0;ka=s.Return(j$);}return j6.ReturnFrom(ka);});});return s.MapResult(j7,j9);},WithErrorSummary:function(kf,kg){var kh,kr,ks,ku;kh=function(ki){return s.OfElement(function(){var kk,kl,km,kn,kp,kq;kl=g.ofArray([f.Text(kf)]);km=f.Tags();kn=function(ko){return f.LI(g.ofArray([f.Text(ko)]));};kp=g.map(kn,ki);kk=g.ofArray([km.NewTag("legend",kl),f.UL(kp)]);kq=f.Tags();return kq.NewTag("fieldset",kk);});};kr=s.Do();ks=function(kt){return m.Join(kt);};ku=kr.Delay(function(){return kr.Bind(s.LiftResult(kg),function(kw){var kx,ky,kz,kB;if(kw.$==1){ky=kw.$0;kz=function(){return kw;};kB=kh(ky);kx=s.Map(kz,kB);}else{kw.$0;kx=s.Return(kw);}return kr.ReturnFrom(kx);});});return s.MapResult(ks,ku);},WithFormContainer:function(kC){return Q.WithCustomFormContainer(S.get_Default(),kC);},WithJsonPost:function(kD,kE){var kF,kG,kH,kI,kJ,kK,kL,kM,kN,kO,kP,kQ,kR,kS,kT,kU,kV,kW,kX,kY,kZ,k0,k1,k2,k3,k4,k5,la,lb,le;kF=kD.PostUrl;if(kF.$==0){kH=$.New(n,{$:0});}else{kI=kF.$0;kJ=f.Attr();kH=g.ofArray([kJ.NewAttr("action",kI)]);}kG=kH;kK=kD.EncodingType;if(kK.$==0){kM=$.New(n,{$:0});}else{kN=kK.$0;kO=f.Attr();kM=g.ofArray([kO.NewAttr("enctype",kN)]);}kL=kM;kP=f.Tags();kR=f.Attr();kS=f.Attr();kT=kD.ParameterName;kQ=g.ofArray([kR.NewAttr("type","hidden"),kS.NewAttr("name",kT)]);kU=kP.NewTag("input",kQ);kV=f.Tags();kX=f.Attr();kY=f.Attr();kW=g.ofArray([kX.NewAttr("type","submit"),kY.NewAttr("value","Submit")]);kZ=kV.NewTag("input",kW);k1=f.Attr();k2=f.Attr();k0=$.New(n,{$:1,$0:k1.NewAttr("method","POST"),$1:$.New(n,{$:1,$0:k2.NewAttr("style","display:none"),$1:kG})});k3=g.append(k0,kL);k4=o.add(f.Form(k3),g.ofArray([kU,kZ]));k5=function(k6){var k7,k8,k9,k_,k$;k7=kD.EncodingType;if(k7.$==0){k8=null;}else{k9=k7.$0;if(k9==="multipart/form-data"){k$=p(k6.get_Body()).attr("encoding","multipart/form-data");k_=void k$;}else{k_=null;}k8=k_;}return k8;};o.OnAfterRender(k5,k4);la=k4;lb=function(lc){var ld;ld=X.stringify(lc);p(kU.get_Body()).val(ld);return p(kZ.get_Body()).click();};le=s.Map(lb,kE);return f.Div(g.ofArray([la,le]));},WithLabel:function(lf,lg){return s.WithLabel({$:1,$0:lf},lg);},WithLabelAbove:function(lh){var li;li=function(lj){var lk,ll,lm,ln,lo,lp;lk=lj.Label;if(lk.$==0){lm=f.Span($.New(n,{$:0}));}else{ln=lk.$0;lm=ln(null);}ll=lm;lo=f.Table(g.ofArray([f.TBody(g.ofArray([f.TR(g.ofArray([f.TD(g.ofArray([ll]))])),f.TR(g.ofArray([f.TD(g.ofArray([lj.Element]))]))]))]));lp={$:0};return $.New(c,{Element:lo,Label:lp});};return s.MapBody(li,lh);},WithLabelAndInfo:function(lq,lr,ls){var lt;lt=function(){var lv,lw,lx;lv=g.ofArray([f.Text(lq)]);lw=f.Tags();lx=f.Attr();return x.InTable(g.ofArray([g.ofArray([lw.NewTag("label",lv),f.Span(g.ofArray([lx.NewAttr("title",lr),f.Attr().Class("infoIcon")]))])]));};return Q.WithLabel(lt,ls);},WithLabelConfiguration:function(ly,lz){var lA,lB;lA=s.ApplyLayout(lz);lB=r.Layout().LabelLayout(ly);return s.WithLayout(lB,lA);},WithLabelLeft:function(lC){var lD;lD=function(lE){var lF,lG,lH,lI,lJ,lK;lF=lE.Label;if(lF.$==0){lH=f.Span($.New(n,{$:0}));}else{lI=lF.$0;lH=lI(null);}lG=lH;lJ=f.Table(g.ofArray([f.TBody(g.ofArray([f.TR(g.ofArray([f.TD(g.ofArray([lE.Element])),f.TD(g.ofArray([lG]))]))]))]));lK={$:0};return $.New(c,{Element:lJ,Label:lK});};return s.MapBody(lD,lC);},WithLegend:function(lL,lM){var lN;lN=function(lO){var lP,lQ,lR,lS,lT,lU,lV,lW;lQ=g.ofArray([f.Tags().text(lL)]);lR=f.Tags();lS=lO.Label;if(lS.$==0){lT=lO.Element;}else{lU=lS.$0;lT=x.InTable(g.ofArray([g.ofArray([lU(null),lO.Element])]));}lP=g.ofArray([lR.NewTag("legend",lQ),lT]);lV=f.Tags();lW=lV.NewTag("fieldset",lP);return $.New(c,{Element:lW,Label:{$:0}});};return s.MapBody(lN,lM);},WithResetAction:function(lX,lY){var lZ,l4,l5,l6,l7;lZ=function(){var l1,l2;l1=lY.Build();l2=function(l3){return lX(null)?l1.Notify.call(null,l3):null;};return $.New(A,{Body:l1.Body,Dispose1:l1.Dispose1,Notify:l2,State:l1.State});};l4=s.New(lZ);l5=lY.get_Layout();l6=s.WithLayout(l5,l4);l7=r.PropagateRenderFrom(lY,l6);return r.OfIFormlet(l7);},WithResetButton:function(l8){return Q.WithCustomResetButton(R.get_Default(),l8);},WithResetFormlet:function(l9,l_){var l$,ma,mb,mc,md,me,mf,mg,mi,mo,mp;l$=s.WithLayoutOrDefault(l9);ma=s.ApplyLayout(l$);mb=s.InitWithFailure(ma);mc=s.LiftResult(mb);md=s.WithNotificationChannel(mc);me=s.LiftResult(l_);mf=s.Do();mg=function(mh){return m.Join(mh);};mi=mf.Delay(function(){return mf.Bind(md,$.Tupled(function(mk){var ml,mm;ml=mk[0];mm=mk[1];return mf.Bind(me,function(mn){mn.$==0?mm(null):null;return mf.Return(ml);});}));});mo=s.MapResult(mg,mi);mp=r.PropagateRenderFrom(md,mo);return r.OfIFormlet(mp);},WithRowConfiguration:function(mq,mr){var ms,mt;ms=s.ApplyLayout(mr);mt=r.Layout().RowLayout(mq);return s.WithLayout(mt,ms);},WithSubmitAndReset:function(mu,mv){var mw,mx,mF;mw=s.Do();mx=mw.Delay(function(){var mz,mA;mz=s.InitWithFailure(mu);mA=s.LiftResult(mz);return mw.Bind(s.WithNotificationChannel(mA),$.Tupled(function(mB){var mC,mD;mC=mB[0];mD=mB[1];return mw.ReturnFrom((mv(function(mE){return mD(mE);}))(mC));}));});mF=r.PropagateRenderFrom(mu,mx);return r.OfIFormlet(mF);},WithSubmitAndResetButtons:function(mG){var mH,mI,mJ,mK;mH=R.get_Default();mI=$.New(R,{Label:{$:1,$0:"Submit"},Style:mH.Style,Class:mH.Class});mJ=R.get_Default();mK=$.New(R,{Label:{$:1,$0:"Reset"},Style:mJ.Style,Class:mJ.Class});return Q.WithCustomSubmitAndResetButtons(mI,mK,mG);},WithSubmitButton:function(mL){return Q.WithCustomSubmitButton(R.get_Default(),mL);},WithSubmitFormlet:function(mM,mN){var mO,mP,mR,mW,mX;mO=s.Do();mP=function(mQ){return m.Join(mQ);};mR=mO.Delay(function(){var mT;mT=s.InitWithFailure(mM);return mO.Bind(s.LiftResult(mT),function(mU){return mO.Bind(mN(mU),function(){return mO.Return(mU);});});});mW=s.MapResult(mP,mR);mX=r.PropagateRenderFrom(mM,mW);return r.OfIFormlet(mX);},WithTextLabel:function(mY,mZ){return Q.WithLabel(function(){var m1,m2;m1=g.ofArray([f.Text(mY)]);m2=f.Tags();return m2.NewTag("label",m1);},mZ);},WithValidationFrame:function(m3){return Q.WithCustomValidationFrame(V.get_Default(),m3);},WithValidationIcon:function(m4){return Q.WithCustomValidationIcon(W.get_Default(),m4);},WrapFormlet:function(m5,m6){var m7;m7=function(){var m9,m_,m$,na,nb;m9=s.WithLayoutOrDefault(m6);m_=s.BuildForm(m9);m$=m9.get_Layout().Apply.call(null,m_.Body).$0;m$[1];na=m$[0];nb=(m5(m_.State))(na);return[nb,function(){return m_.Notify.call(null,null);},m_.State];};return r.MkFormlet(m7);}},Formlet:{ApplyLayout:function(nd){var ne,nf;ne=r.BaseFormlet().ApplyLayout(nd);nf=r.PropagateRenderFrom(nd,ne);return r.OfIFormlet(nf);},Bind:function(ng,nh){var ni,nj,nm,nn;ni=r.BaseFormlet();nj=function(nk){var nl;nl=nh(nk);return nl;};nm=ni.Bind(ng,nj);nn=r.PropagateRenderFrom(ng,nm);return r.OfIFormlet(nn);},BindWith:function(no,np,nq){var nr,ns,nu,nv;nr=r.BaseFormlet();ns=function(nt){return nq(nt);};nu=nr.BindWith(no,np,ns);nv=r.PropagateRenderFrom(np,nu);return r.OfIFormlet(nv);},BuildForm:function(nw){return r.BaseFormlet().BuildForm(nw);},BuildFormlet:function(nx){return r.MkFormlet(nx);},Choose:function(ny){var nz,nA,nG,nH,nI,nX,nY,n0,n1;nz={contents:0};nA=function(nB){var nC,nE,nF;nC=function(nD){t.Increment(nz);return[nD,nz.contents];};nE=s.Map(nC,nB);nF=s.InitWithFailure(nE);return s.LiftResult(nF);};nG=w.map(nA,ny);nH=s.Sequence(nG);nI=function(nJ){var nK,nO,nP,nS,nT,nU;nK=function(nL){var nM,nN;if(nL.$==0){nN=nL.$0;nM={$:1,$0:nN};}else{nM={$:0};}return nM;};nO=g.choose(nK,nJ);nP=$.Tupled(function(nQ){var nR;nQ[0];nR=nQ[1];return nR;});nS=g.sortBy(nP,nO);nT=g.rev(nS);nU=$.Tupled(function(nV){var nW;nW=nV[0];nV[1];return{$:1,$0:nW};});return w.tryPick(nU,nT);};nX=s.Map(nI,nH);nY=function(nZ){return nZ.$==1;};n0=r.Validator().Is(nY,"",nX);n1=function(n2){return n2.$0;};return s.Map(n1,n0);},Delay:function(n3){var n4;n4=r.BaseFormlet().Delay(function(){return n3(null);});return r.OfIFormlet(n4);},Deletable:function(n6){var n7,n8;n7=r.BaseFormlet().Deletable(n6);n8=r.PropagateRenderFrom(n6,n7);return r.OfIFormlet(n8);},Do:$.Field(function(){return Y.New();}),Empty:function(){var n9;n9=r.BaseFormlet().Empty();return r.OfIFormlet(n9);},FailWith:function(n_){var n$;n$=r.BaseFormlet().FailWith(n_);return r.OfIFormlet(n$);},FlipBody:function(oa){var ob,oc;ob=r.BaseFormlet().FlipBody(oa);oc=r.PropagateRenderFrom(oa,ob);return r.OfIFormlet(oc);},Flowlet:function(od){var oe,of,og,oh;oe=r.BaseFormlet();of=r.Layout().get_Flowlet();og=oe.WithLayout(of,od);oh=r.PropagateRenderFrom(od,og);return r.OfIFormlet(oh);},Horizontal:function(oi){var oj,ok,ol,om;oj=r.BaseFormlet();ok=r.Layout().get_Horizontal();ol=oj.WithLayout(ok,oi);om=r.PropagateRenderFrom(oi,ol);return r.OfIFormlet(om);},InitWith:function(on,oo){var op,oq,or;op=r.BaseFormlet();oq=op.InitWith(on,oo);or=r.PropagateRenderFrom(oo,oq);return r.OfIFormlet(or);},InitWithFailure:function(os){var ot,ou;ot=r.BaseFormlet().InitWithFailure(os);ou=r.PropagateRenderFrom(os,ot);return r.OfIFormlet(ou);},Join:function(ov){var ow,oy,oz,oA,oB;ow=function(ox){return ox;};oy=s.Map(ow,ov);oz=r.BaseFormlet();oA=oz.Join(oy);oB=r.PropagateRenderFrom(ov,oA);return r.OfIFormlet(oB);},LiftResult:function(oC){var oD,oE;oD=r.BaseFormlet().LiftResult(oC);oE=r.PropagateRenderFrom(oC,oD);return r.OfIFormlet(oE);},Map:function(oF,oG){var oH,oI,oJ;oH=r.BaseFormlet();oI=oH.Map(oF,oG);oJ=r.PropagateRenderFrom(oG,oI);return r.OfIFormlet(oJ);},MapBody:function(oK,oL){var oM,oN,oO;oM=r.BaseFormlet();oN=oM.MapBody(oK,oL);oO=r.PropagateRenderFrom(oL,oN);return r.OfIFormlet(oO);},MapElement:function(oP,oQ){var oR,oS,oU,oV;oR=r.BaseFormlet();oS=function(oT){return $.New(c,{Element:oP(oT.Element),Label:oT.Label});};oU=oR.MapBody(oS,oQ);oV=r.PropagateRenderFrom(oQ,oU);return r.OfIFormlet(oV);},MapResult:function(oW,oX){var oY,oZ,o0;oY=r.BaseFormlet();oZ=oY.MapResult(oW,oX);o0=r.PropagateRenderFrom(oX,oZ);return r.OfIFormlet(o0);},Never:function(){var o1;o1=r.BaseFormlet().Never();return r.OfIFormlet(o1);},New:function(o2){var o3;o3=r.BaseFormlet().New(o2);return r.OfIFormlet(o3);},OfElement:function(o4){var o5;o5=function(){var o7;o7=o4(null);return[o7,function(){},r.RX().Return($.New(m,{$:0,$0:null}))];};return r.MkFormlet(o5);},Render:function(o9){var o_;o_=o9.Run(function(){});return r.PropagateRenderFrom(o9,o_);},Replace:function(pa,pb){var pc,pd,pf,pg;pc=r.BaseFormlet();pd=function(pe){return pb(pe);};pf=pc.Replace(pa,pd);pg=r.PropagateRenderFrom(pa,pf);return r.OfIFormlet(pg);},ReplaceFirstWithFailure:function(ph){var pi,pj;pi=r.BaseFormlet().ReplaceFirstWithFailure(ph);pj=r.PropagateRenderFrom(ph,pi);return r.OfIFormlet(pj);},Return:function(pk){var pl;pl=r.BaseFormlet().Return(pk);return r.OfIFormlet(pl);},ReturnEmpty:function(pm){var pn;pn=r.BaseFormlet().ReturnEmpty(pm);return r.OfIFormlet(pn);},Run:function(po,pp){return pp.Run(po);},SelectMany:function(pq){var pr,pt,pu,pv,pw;pr=function(ps){return ps;};pt=s.Map(pr,pq);pu=r.BaseFormlet();pv=pu.SelectMany(pt);pw=r.PropagateRenderFrom(pq,pv);return r.OfIFormlet(pw);},Sequence:function(px){var py,pA,pB,pC;py=function(pz){return pz;};pA=w.map(py,px);pB=r.BaseFormlet();pC=pB.Sequence(pA);return r.OfIFormlet(pC);},Switch:function(pD){var pE,pG,pH,pI,pJ;pE=function(pF){return pF;};pG=s.Map(pE,pD);pH=r.BaseFormlet();pI=pH.Switch(pG);pJ=r.PropagateRenderFrom(pD,pI);return r.OfIFormlet(pJ);},Vertical:function(pK){var pL,pM,pN,pO;pL=r.BaseFormlet();pM=r.Layout().get_Vertical();pN=pL.WithLayout(pM,pK);pO=r.PropagateRenderFrom(pK,pN);return r.OfIFormlet(pO);},WithCancelation:function(pP,pQ){var pR,pS,pT;pR=r.BaseFormlet();pS=pR.WithCancelation(pP,pQ);pT=r.PropagateRenderFrom(pP,pS);return r.OfIFormlet(pT);},WithLabel:function(pU,pV){var pW,pX,pZ,p0;pW=r.BaseFormlet();pX=function(pY){return $.New(c,{Element:pY.Element,Label:pU});};pZ=pW.MapBody(pX,pV);p0=r.PropagateRenderFrom(pV,pZ);return r.OfIFormlet(p0);},WithLayout:function(p1,p2){var p3,p4,p5;p3=r.BaseFormlet();p4=p3.WithLayout(p1,p2);p5=r.PropagateRenderFrom(p2,p4);return r.OfIFormlet(p5);},WithLayoutOrDefault:function(p6){var p7,p8;p7=r.BaseFormlet().WithLayoutOrDefault(p6);p8=r.PropagateRenderFrom(p6,p7);return r.OfIFormlet(p8);},WithNotification:function(p9,p_){var p$,qa,qb;p$=r.BaseFormlet();qa=p$.WithNotification(p9,p_);qb=r.PropagateRenderFrom(p_,qa);return r.OfIFormlet(qb);},WithNotificationChannel:function(qc){var qd,qe;qd=r.BaseFormlet().WithNotificationChannel(qc);qe=r.PropagateRenderFrom(qc,qd);return r.OfIFormlet(qe);}},FormletBuilder:$.Class({Bind:function(qf,qg){var qh,qi,ql,qm;qh=r.BaseFormlet();qi=function(qj){var qk;qk=qg(qj);return qk;};ql=qh.Bind(qf,qi);qm=r.PropagateRenderFrom(qf,ql);return r.OfIFormlet(qm);},Delay:function(qn){var qo;qo=r.BaseFormlet().Delay(function(qp){return qn(qp);});return r.OfIFormlet(qo);},Return:function(qq){var qr;qr=r.BaseFormlet().Return(qq);return r.OfIFormlet(qr);},ReturnFrom:function(qs){return r.OfIFormlet(qs);}},{New:function(){return $.New(this,{});}}),Layout:{FormRowConfiguration:$.Class({},{get_Default:function(){return $.New(_0,{Padding:{$:0},Color:{$:0},Class:{$:0},Style:{$:0},LabelConfiguration:{$:0}});}}),LabelConfiguration:$.Class({},{get_Default:function(){return $.New(_1,{Align:{$:0},VerticalAlign:{$:1},Placement:{$:0}});}}),Padding:$.Class({},{get_Default:function(){return $.New(_2,{Left:{$:0},Right:{$:0},Top:{$:0},Bottom:{$:0}});}})},LayoutProvider:$.Class({ColumnLayout:function(qt){var qu,qv,qF=this;qu=this.LayoutUtils;qv=function(){var qx,qy,qz,qA,qM;qx=f.TR($.New(n,{$:0}));qy=f.Table(g.ofArray([f.TBody(g.ofArray([qx]))]));qz=P.NewElementStore();qA=function(qB){return function(qC){var qD,qE,qG,qH,qI;qD=qC.Element.get_Id();qE=f.TD(g.ofArray([f.Table(g.ofArray([f.TBody(g.ofArray([qF.MakeRow(qt,qB,qC)]))]))]));qG=p(qx.get_Body());qH={contents:0};qI={contents:false};qG.children().each(function(){var qJ,qK;qJ=p(this);if(qB===qH.contents){p(qE.get_Body()).insertBefore(qJ);qE.Render();qK=void(qI.contents=true);}else{qK=null;}return t.Increment(qH);});!qI.contents?qx.AppendI(qE):null;return qz.RegisterElement(qD,function(){return qE["HtmlProvider@33"].Remove(qE.get_Body());});};};qM=function(qN){var qO,qP;qO=_3.Get(qN);while(qO.MoveNext()){qP=qO.get_Current();qz.Remove(qP.Element.get_Id());}return;};return{Body:$.New(c,{Element:qy,Label:{$:0}}),SyncRoot:null,Insert:qA,Remove:qM};};return qu.New(qv);},HorizontalAlignElem:function(qQ,qR){var qS,qT,qU;qS=qQ.$==0?"left":"right";qT=f.Attr();qU="float:"+qS+";";return o.add(f.Div(g.ofArray([qT.NewAttr("style",qU)])),g.ofArray([qR]));},LabelLayout:function(qV){var qW,qX;qW=_0.get_Default();qX={$:1,$0:qV};return this.RowLayout($.New(_0,{Padding:qW.Padding,Color:qW.Color,Class:qW.Class,Style:qW.Style,LabelConfiguration:qX}));},MakeLayout:function(qY){var qZ,q0;qZ=this.LayoutUtils;q0=function(){var q2,q3,q4,ra;q2=qY(null);q3=P.NewElementStore();q4=function(q5){return function(q6){var q7,q8;q7=q6.Element.get_Id();q8=(q2.Insert.call(null,q5))(q6);return q3.RegisterElement(q7,function(){var q_,q$;q_=_3.Get(q8);while(q_.MoveNext()){q$=q_.get_Current();q$["HtmlProvider@33"].Remove(q$.get_Body());}return;});};};ra=function(rb){var rc,rd;rc=_3.Get(rb);while(rc.MoveNext()){rd=rc.get_Current();q3.Remove(rd.Element.get_Id());}return;};return{Body:$.New(c,{Element:q2.Panel,Label:{$:0}}),SyncRoot:null,Insert:q4,Remove:ra};};return qZ.New(q0);},MakeRow:function(re,rf,rg){var rh,ri,rj,rl,rm,ro,rp,rq,rs,rt,ru,rw,rx,ry,rA,rB,rC,r7,r8,r9,r_,r$,sa,sb,sc,se,sf,sg,sh,si,sj,sk,sl,sm,sn,so,sr,ss,st,su,sx,sy,sz,sA,sC,sD,sE,sF,sG,sJ,sK,sL,sM;rh=re.Padding;ri=_2.get_Default();rj=function(rk){return rk;};rl=x.Maybe(ri,rj,rh);rm=function(rn){return rn;};ro=rl.Left;rp=x.Maybe(0,rm,ro);rq=function(rr){return rr;};rs=rl.Top;rt=x.Maybe(0,rq,rs);ru=function(rv){return rv;};rw=rl.Right;rx=x.Maybe(0,ru,rw);ry=function(rz){return rz;};rA=rl.Bottom;rB=x.Maybe(0,ry,rA);rC=function(rD){return function(rE){return function(rF){return function(rG){return function(rH){return function(rI){return function(rJ){var rK,rL,rP,rS,rT,rU,rX,rY,rZ,r0,r1,r2,r3,r4,r5,r6;rK=g.ofArray([["padding-left: ",rD],["padding-top: ",rE],["padding-right: ",rF],["padding-bottom: ",rG]]);rL=$.Tupled(function(rM){var rN,rO;rN=rM[0];rO=rM[1];return rN+$$.String(rO)+"px;";});rP=function(rQ){return function(rR){return rQ+rR;};};rS=g.map(rL,rK);rT=w.reduce(rP,rS);rU=function(rV){var rW;rW=rV.$==1?"middle":rV.$==2?"bottom":"top";return"vertical-align: "+rW+";";};rX=x.Maybe("",rU,rI);rY=f.Attr();rZ=rT+";"+rX;r0=rY.NewAttr("style",rZ);if(rH){r3=f.Attr();r2=g.ofArray([r3.NewAttr("colspan","2")]);}else{r2=$.New(n,{$:0});}r1=r2;r4=$.New(n,{$:1,$0:r0,$1:r1});r5=g.ofArray([rJ]);r6=g.append(r4,r5);return f.TD(r6);};};};};};};};r7=rg.Element;r8=rg.Label;if(r8.$==1){r$=r8.$0;sa=re.LabelConfiguration;sb=_1.get_Default();sc=function(sd){return sd;};se=x.Maybe(sb,sc,sa);sf=se.Align;sg=r$(null);sh=this.HorizontalAlignElem(sf,sg);si=se.Placement;if(si.$==3){sk=x.InTable(g.ofArray([g.ofArray([r7]),g.ofArray([sh])]));sj=g.ofArray([((((((rC(rp))(rt))(rx))(rB))(true))({$:0}))(sk)]);}else{if(si.$==0){sj=g.ofArray([((((((rC(rp))(rt))(0))(rB))(false))({$:1,$0:se.VerticalAlign}))(sh),((((((rC(0))(rt))(rx))(rB))(false))({$:0}))(r7)]);}else{if(si.$==1){sj=g.ofArray([((((((rC(rp))(rt))(0))(rB))(false))({$:1,$0:se.VerticalAlign}))(r7),((((((rC(0))(rt))(rx))(rB))(false))({$:0}))(sh)]);}else{sl=x.InTable(g.ofArray([g.ofArray([sh]),g.ofArray([r7])]));sj=g.ofArray([((((((rC(rp))(rt))(rx))(rB))(true))({$:0}))(sl)]);}}}r_=sj;}else{r_=g.ofArray([((((((rC(rp))(rt))(rx))(rB))(true))({$:0}))(r7)]);}r9=r_;sm=re.Class;sn=$.New(n,{$:0});so=function(sp){var sq;sq=sp(rf);return g.ofArray([f.Attr().Class(sq)]);};sr=x.Maybe(sn,so,sm);ss=re.Color;st=$.New(n,{$:0});su=function(sv){var sw;sw=sv(rf);return g.ofArray(["background-color: "+sw]);};sx=x.Maybe(st,su,ss);sy=re.Style;sz=$.New(n,{$:0});sA=function(sB){return g.ofArray([sB(rf)]);};sC=x.Maybe(sz,sA,sy);sD=g.append(sx,sC);if(sD.$==0){sF=$.New(n,{$:0});}else{sG=w.reduce(function(sH){return function(sI){return sH+";"+sI;};},sD);sJ=f.Attr();sF=g.ofArray([sJ.NewAttr("style",sG)]);}sE=sF;sK=g.append(sE,r9);sL=g.append(sE,sK);sM=g.append(sr,sL);return f.TR(sM);},RowLayout:function(sN){var sO,sP,sZ=this;sO=this.LayoutUtils;sP=function(){var sR,sS,sT,sU,s6;sR=f.TBody($.New(n,{$:0}));sS=f.Table(g.ofArray([sR]));sT=P.NewElementStore();sU=function(sV){return function(sW){var sX,sY,s0,s1,s2;sX=sW.Element.get_Id();sY=sZ.MakeRow(sN,sV,sW);s0=p(sR.get_Body());s1={contents:0};s2={contents:false};s0.children().each(function(){var s3,s4;s3=p(this);if(sV===s1.contents){p(sY.get_Body()).insertBefore(s3);sY.Render();s4=void(s2.contents=true);}else{s4=null;}return t.Increment(s1);});!s2.contents?sR.AppendI(sY):null;return sT.RegisterElement(sX,function(){return sY["HtmlProvider@33"].Remove(sY.get_Body());});};};s6=function(s7){var s8,s9;s8=_3.Get(s7);while(s8.MoveNext()){s9=s8.get_Current();sT.Remove(s9.Element.get_Id());}return;};return{Body:$.New(c,{Element:sS,Label:{$:0}}),SyncRoot:null,Insert:sU,Remove:s6};};return sO.New(sP);},VerticalAlignedTD:function(s_,s$){var ta,tb,tc,td;ta=s_.$==1?"middle":s_.$==2?"bottom":"top";tb=f.TD(g.ofArray([s$]));tc=tb["HtmlProvider@33"];td=tb.get_Body();tc.SetCss(td,"vertical-align",ta);return tb;},get_Flowlet:function(){var te;te=function(){var tg,th;tg=f.Div($.New(n,{$:0}));th=function(){return function(tj){var tk,tl;tk=tj.Label.$==1?tj.Label.$0.call(null,null):f.Span($.New(n,{$:0}));tl=x.InTable(g.ofArray([g.ofArray([tk,f.Div(g.ofArray([tj.Element]))])]));tg["HtmlProvider@33"].Clear(tg.get_Body());tg.AppendI(tl);return g.ofArray([tl]);};};return{Insert:th,Panel:tg};};return this.MakeLayout(te);},get_Horizontal:function(){return this.ColumnLayout(_0.get_Default());},get_Vertical:function(){return this.RowLayout(_0.get_Default());}},{New:function(tm){var tn;tn=$.New(this,{});tn.LayoutUtils=tm;return tn;}}),Utils:{InTable:function(to){var tp,tu,tv;tp=function(tq){var tr,tt;tr=function(ts){return f.TD(g.ofArray([ts]));};tt=g.map(tr,tq);return f.TR(tt);};tu=g.map(tp,to);tv=f.TBody(tu);return f.Table(g.ofArray([tv]));},MapOption:function(tw,tx){var ty,tz;if(tx.$==1){tz=tx.$0;ty={$:1,$0:tw(tz)};}else{ty={$:0};}return ty;},Maybe:function(tA,tB,tC){var tD,tE;if(tC.$==0){tD=tA;}else{tE=tC.$0;tD=tB(tE);}return tD;}}}}}});$.OnInit(function(){a=$.Safe($$.IntelliFactory.WebSharper);b=$.Safe(a.Formlets);c=$.Safe(b.Body);d=$.Safe(a.Html);e=$.Safe(d.Client);f=$.Safe(e.Default);g=$.Safe(a.List);h=$.Safe(b.Controls);i=$.Safe($$.IntelliFactory.Reactive);j=$.Safe(i.HotStream);k=$.Safe($$.IntelliFactory.Formlets);l=$.Safe(k.Base);m=$.Safe(l.Result);n=$.Safe(g.T);o=$.Safe(e.Operators);p=$.Safe($$.jQuery);q=$.Safe(e.EventsPervasives);r=$.Safe(b.Data);s=$.Safe(b.Formlet);t=$.Safe(a.Operators);u=$.Safe(b.CssConstants);v=$.Safe($$.Math);w=$.Safe(a.Seq);x=$.Safe(b.Utils);y=$.Safe(l.Tree);z=$.Safe(y.Edit);A=$.Safe(l.Form);B=$.Safe(a.Arrays);C=$.Safe(a.IntrinsicFunctionProxy);D=$.Safe(l.FormletProvider);E=$.Safe(r.Formlet);F=$.Safe(e.Pagelet);G=$.Safe(a.Util);H=$.Safe(b.LayoutProvider);I=$.Safe(l.LayoutUtils);J=$.Safe(i.Reactive);K=$.Safe(l.Validator);L=$.Safe(r.ValidatorProvidor);M=$.Safe($$.RegExp);N=$.Safe(a.Collections);O=$.Safe(N.Dictionary);P=$.Safe(b.ElementStore);Q=$.Safe(b.Enhance);R=$.Safe(Q.FormButtonConfiguration);S=$.Safe(Q.FormContainerConfiguration);T=$.Safe(Q.Padding);U=$.Safe(Q.ManyConfiguration);V=$.Safe(Q.ValidationFrameConfiguration);W=$.Safe(Q.ValidationIconConfiguration);X=$.Safe($$.JSON);Y=$.Safe(b.FormletBuilder);Z=$.Safe(b.Layout);_0=$.Safe(Z.FormRowConfiguration);_1=$.Safe(Z.LabelConfiguration);_2=$.Safe(Z.Padding);return _3=$.Safe(a.Enumerator);});$.OnLoad(function(){$.Inherit(E,F);s.Do();r.Validator();r.RX();r.Layout();r.DefaultLayout();u.InputTextClass();return;});}());

!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var t;"undefined"!=typeof window?t=window:"undefined"!=typeof global?t=global:"undefined"!=typeof self&&(t=self),t.Promise=e()}}(function(){return function e(t,n,r){function o(s,u){if(!n[s]){if(!t[s]){var c="function"==typeof require&&require;if(!u&&c)return c(s,!0);if(i)return i(s,!0);throw new Error("Cannot find module '"+s+"'")}var a=n[s]={exports:{}};t[s][0].call(a.exports,function(e){var n=t[s][1][e];return o(n?n:e)},a,a.exports,e,t,n,r)}return n[s].exports}for(var i="function"==typeof require&&require,s=0;s<r.length;s++)o(r[s]);return o}({1:[function(e,t){"use strict";function n(){}t.exports=n},{}],2:[function(e,t){"use strict";var n=e("./promise"),r=e("./reject"),o=e("./resolve"),i=e("./INTERNAL"),s=e("./handlers"),u=r(new TypeError("must be an array"));t.exports=function(e){function t(e,t){function n(e){a[t]=e,++l===r&!c&&(c=!0,s.resolve(h,a))}o(e).then(n,function(e){c||(c=!0,s.reject(h,e))})}if("[object Array]"!==Object.prototype.toString.call(e))return u;var r=e.length,c=!1;if(!r)return o([]);for(var a=new Array(r),l=0,f=-1,h=new n(i);++f<r;)t(e[f],f);return h}},{"./INTERNAL":1,"./handlers":3,"./promise":5,"./reject":7,"./resolve":8}],3:[function(e,t,n){"use strict";function r(e){var t=e&&e.then;return e&&"object"==typeof e&&"function"==typeof t?function(){t.apply(e,arguments)}:void 0}var o=e("./tryCatch"),i=e("./resolveThenable"),s=e("./states");n.resolve=function(e,t){var u=o(r,t);if("error"===u.status)return n.reject(e,u.value);var c=u.value;if(c)i.safely(e,c);else{e.state=s.FULFILLED,e.outcome=t;for(var a=-1,l=e.queue.length;++a<l;)e.queue[a].callFulfilled(t)}return e},n.reject=function(e,t){e.state=s.REJECTED,e.outcome=t;for(var n=-1,r=e.queue.length;++n<r;)e.queue[n].callRejected(t);return e}},{"./resolveThenable":9,"./states":10,"./tryCatch":11}],4:[function(e,t,n){t.exports=n=e("./promise"),n.resolve=e("./resolve"),n.reject=e("./reject"),n.all=e("./all")},{"./all":2,"./promise":5,"./reject":7,"./resolve":8}],5:[function(e,t){"use strict";function n(e){if(!(this instanceof n))return new n(e);if("function"!=typeof e)throw new TypeError("reslover must be a function");this.state=s.PENDING,this.queue=[],this.outcome=void 0,e!==o&&i.safely(this,e)}var r=e("./unwrap"),o=e("./INTERNAL"),i=e("./resolveThenable"),s=e("./states"),u=e("./queueItem");t.exports=n,n.prototype["catch"]=function(e){return this.then(null,e)},n.prototype.then=function(e,t){if("function"!=typeof e&&this.state===s.FULFILLED||"function"!=typeof t&&this.state===s.REJECTED)return this;var i=new n(o);if(this.state!==s.PENDING){var c=this.state===s.FULFILLED?e:t;r(i,c,this.outcome)}else this.queue.push(new u(i,e,t));return i}},{"./INTERNAL":1,"./queueItem":6,"./resolveThenable":9,"./states":10,"./unwrap":12}],6:[function(e,t){"use strict";function n(e,t,n){this.promise=e,"function"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),"function"==typeof n&&(this.onRejected=n,this.callRejected=this.otherCallRejected)}var r=e("./handlers"),o=e("./unwrap");t.exports=n,n.prototype.callFulfilled=function(e){r.resolve(this.promise,e)},n.prototype.otherCallFulfilled=function(e){o(this.promise,this.onFulfilled,e)},n.prototype.callRejected=function(e){r.reject(this.promise,e)},n.prototype.otherCallRejected=function(e){o(this.promise,this.onRejected,e)}},{"./handlers":3,"./unwrap":12}],7:[function(e,t){"use strict";function n(e){var t=new r(o);return i.reject(t,e)}var r=e("./promise"),o=e("./INTERNAL"),i=e("./handlers");t.exports=n},{"./INTERNAL":1,"./handlers":3,"./promise":5}],8:[function(e,t){"use strict";function n(e){if(e)return e instanceof r?e:i.resolve(new r(o),e);var t=typeof e;switch(t){case"boolean":return s;case"undefined":return c;case"object":return u;case"number":return a;case"string":return l}}var r=e("./promise"),o=e("./INTERNAL"),i=e("./handlers");t.exports=n;var s=i.resolve(new r(o),!1),u=i.resolve(new r(o),null),c=i.resolve(new r(o),void 0),a=i.resolve(new r(o),0),l=i.resolve(new r(o),"")},{"./INTERNAL":1,"./handlers":3,"./promise":5}],9:[function(e,t,n){"use strict";function r(e,t){function n(t){u||(u=!0,o.reject(e,t))}function r(t){u||(u=!0,o.resolve(e,t))}function s(){t(r,n)}var u=!1,c=i(s);"error"===c.status&&n(c.value)}var o=e("./handlers"),i=e("./tryCatch");n.safely=r},{"./handlers":3,"./tryCatch":11}],10:[function(e,t,n){n.REJECTED=["REJECTED"],n.FULFILLED=["FULFILLED"],n.PENDING=["PENDING"]},{}],11:[function(e,t){"use strict";function n(e,t){var n={};try{n.value=e(t),n.status="success"}catch(r){n.status="error",n.value=r}return n}t.exports=n},{}],12:[function(e,t){"use strict";function n(e,t,n){r(function(){var r;try{r=t(n)}catch(i){return o.reject(e,i)}r===e?o.reject(e,new TypeError("Cannot resolve promise with itself")):o.resolve(e,r)})}var r=e("immediate"),o=e("./handlers");t.exports=n},{"./handlers":3,immediate:13}],13:[function(e,t){"use strict";function n(){o=!0;for(var e,t,n=u.length;n;){for(t=u,u=[],e=-1;++e<n;)t[e]();n=u.length}o=!1}function r(e){1!==u.push(e)||o||i()}for(var o,i,s=[e("./nextTick"),e("./messageChannel"),e("./stateChange"),e("./timeout")],u=[],c=-1,a=s.length;++c<a;)if(s[c].test()){i=s[c].install(n);break}t.exports=r},{"./messageChannel":14,"./nextTick":15,"./stateChange":16,"./timeout":17}],14:[function(e,t,n){(function(e){"use strict";n.test=function(){return e.setImmediate?!1:"undefined"!=typeof e.MessageChannel},n.install=function(t){var n=new e.MessageChannel;return n.port1.onmessage=t,function(){n.port2.postMessage(0)}}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],15:[function(e,t,n){(function(e){"use strict";var t=e.MutationObserver||e.WebKitMutationObserver;n.test=function(){return t},n.install=function(n){var r=0,o=new t(n),i=e.document.createTextNode("");return o.observe(i,{characterData:!0}),function(){i.data=r=++r%2}}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],16:[function(e,t,n){(function(e){"use strict";n.test=function(){return"document"in e&&"onreadystatechange"in e.document.createElement("script")},n.install=function(t){return function(){var n=e.document.createElement("script");return n.onreadystatechange=function(){t(),n.onreadystatechange=null,n.parentNode.removeChild(n),n=null},e.document.documentElement.appendChild(n),t}}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],17:[function(e,t,n){"use strict";n.test=function(){return!0},n.install=function(e){return function(){setTimeout(e,0)}}},{}]},{},[4])(4)});;
//    PouchDB 3.0.5
//    
//    (c) 2012-2014 Dale Harvey and the PouchDB team
//    PouchDB may be freely distributed under the Apache license, version 2.0.
//    For all details and documentation:
//    http://pouchdb.com
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var t;"undefined"!=typeof window?t=window:"undefined"!=typeof global?t=global:"undefined"!=typeof self&&(t=self),t.PouchDB=e()}}(function(){var define,module,exports;return function e(t,n,r){function o(s,a){if(!n[s]){if(!t[s]){var u="function"==typeof require&&require;if(!a&&u)return u(s,!0);if(i)return i(s,!0);throw new Error("Cannot find module '"+s+"'")}var c=n[s]={exports:{}};t[s][0].call(c.exports,function(e){var n=t[s][1][e];return o(n?n:e)},c,c.exports,e,t,n,r)}return n[s].exports}for(var i="function"==typeof require&&require,s=0;s<r.length;s++)o(r[s]);return o}({1:[function(e,t){"use strict";function n(e,t){for(var n=0;n<e.length;n++)if(t(e[n],n)===!0)return e[n];return!1}function r(e){return function(t,n){t||n[0].error?e(t||n[0]):e(null,n[0])}}function o(e){var t={},n=[];return u.traverseRevTree(e,function(e,r,o,i){var s=r+"-"+o;return e&&(t[s]=0),void 0!==i&&n.push({from:i,to:s}),s}),n.reverse(),n.forEach(function(e){t[e.from]=void 0===t[e.from]?1+t[e.to]:Math.min(t[e.from],1+t[e.to])}),t}function i(e,t,n){var r="limit"in t?t.keys.slice(t.skip,t.limit+t.skip):t.skip>0?t.keys.slice(t.skip):t.keys;if(t.descending&&r.reverse(),!r.length)return e._allDocs({limit:0},n);var o={offset:t.skip};return p.all(r.map(function(n){var r=a.extend(!0,{key:n,deleted:"ok"},t);return["limit","skip","keys"].forEach(function(e){delete r[e]}),new p(function(t,i){e._allDocs(r,function(e,r){return e?i(e):(o.total_rows=r.total_rows,void t(r.rows[0]||{key:n,error:"not_found"}))})})})).then(function(e){return o.rows=e,o})}function s(){var e=this;l.call(this),e.autoCompact=function(t){return e.auto_compaction&&"http"!==e.type()?function(n,r){if(n)t(n);else{var o=r.length,i=function(){o--,o||t(null,r)};if(!r.length)return t(null,r);r.forEach(function(t){t.ok&&t.id?e.compactDocument(t.id,1,i):i()})}}:t};var t,n=0,r=["change","delete","create","update"];this.on("newListener",function(o){if(~r.indexOf(o)){if(n)return void n++;n++;var i=0;t=this.changes({conflicts:!0,include_docs:!0,continuous:!0,since:"now",onChange:function(t){t.seq<=i||(i=t.seq,e.emit("change",t),t.doc._deleted?e.emit("delete",t):"1"===t.doc._rev.split("-")[0]?e.emit("create",t):e.emit("update",t))}})}}),this.on("removeListener",function(e){~r.indexOf(e)&&(n--,n||t.cancel())})}var a=e("./utils"),u=e("./merge"),c=e("./deps/errors"),l=e("events").EventEmitter,d=e("./deps/upsert"),f=e("./changes"),p=a.Promise;a.inherits(s,l),t.exports=s,s.prototype.post=a.adapterFun("post",function(e,t,n){return"function"==typeof t&&(n=t,t={}),"object"!=typeof e||Array.isArray(e)?n(c.NOT_AN_OBJECT):void this.bulkDocs({docs:[e]},t,this.autoCompact(r(n)))}),s.prototype.put=a.adapterFun("put",a.getArguments(function(e){var t,n,o,i,s=e.shift(),u="_id"in s;if("object"!=typeof s||Array.isArray(s))return(i=e.pop())(c.NOT_AN_OBJECT);for(s=a.clone(s);;)if(t=e.shift(),n=typeof t,"string"!==n||u?"string"!==n||!u||"_rev"in s?"object"===n?o=t:"function"===n&&(i=t):s._rev=t:(s._id=t,u=!0),!e.length)break;o=o||{};var l=a.invalidIdError(s._id);return l?i(l):a.isLocalId(s._id)&&"function"==typeof this._putLocal?s._deleted?this._removeLocal(s,i):this._putLocal(s,i):void this.bulkDocs({docs:[s]},o,this.autoCompact(r(i)))})),s.prototype.putAttachment=a.adapterFun("putAttachment",function(e,t,n,r,o,i){function s(e){return e._attachments=e._attachments||{},e._attachments[t]={content_type:o,data:r},a.put(e)}var a=this;return"function"==typeof o&&(i=o,o=r,r=n,n=null),"undefined"==typeof o&&(o=r,r=n,n=null),a.get(e).then(function(e){if(e._rev!==n)throw c.REV_CONFLICT;return s(e)},function(t){if(t.error===c.MISSING_DOC.error)return s({_id:e});throw t})}),s.prototype.removeAttachment=a.adapterFun("removeAttachment",function(e,t,n,r){var o=this;o.get(e,function(e,i){return e?void r(e):i._rev!==n?void r(c.REV_CONFLICT):i._attachments?(delete i._attachments[t],0===Object.keys(i._attachments).length&&delete i._attachments,void o.put(i,r)):r()})}),s.prototype.remove=a.adapterFun("remove",function(e,t,n,o){var i;"string"==typeof t?(i={_id:e,_rev:t},"function"==typeof n&&(o=n,n={})):(i=e,"function"==typeof t?(o=t,n={}):(o=n,n=t)),n=a.clone(n||{}),n.was_delete=!0;var s={_id:i._id,_rev:i._rev||n.rev};return s._deleted=!0,a.isLocalId(s._id)&&"function"==typeof this._removeLocal?this._removeLocal(i,o):void this.bulkDocs({docs:[s]},n,r(o))}),s.prototype.revsDiff=a.adapterFun("revsDiff",function(e,t,n){function r(e,t){c.has(e)||c.set(e,{missing:[]}),c.get(e).missing.push(t)}function o(t,n){var o=e[t].slice(0);u.traverseRevTree(n,function(e,n,i,s,a){var u=n+"-"+i,c=o.indexOf(u);-1!==c&&(o.splice(c,1),"available"!==a.status&&r(t,u))}),o.forEach(function(e){r(t,e)})}"function"==typeof t&&(n=t,t={}),t=a.clone(t);var i=Object.keys(e);if(!i.length)return n(null,{});var s=0,c=new a.Map;i.map(function(t){this._getRevisionTree(t,function(r,a){if(r&&404===r.status&&"missing"===r.message)c.set(t,{missing:e[t]});else{if(r)return n(r);o(t,a)}if(++s===i.length){var u={};return c.forEach(function(e,t){u[t]=e}),n(null,u)}})},this)}),s.prototype.compactDocument=a.adapterFun("compactDocument",function(e,t,n){var r=this;this._getRevisionTree(e,function(i,s){if(i)return n(i);var a=o(s),c=[],l=[];Object.keys(a).forEach(function(e){a[e]>t&&c.push(e)}),u.traverseRevTree(s,function(e,t,n,r,o){var i=t+"-"+n;"available"===o.status&&-1!==c.indexOf(i)&&(o.status="missing",l.push(i))}),r._doCompaction(e,s,l,n)})}),s.prototype.compact=a.adapterFun("compact",function(e,t){"function"==typeof e&&(t=e,e={});var n=this;this.changes({complete:function(e,r){if(e)return void t();var o=r.results.length;return o?void r.results.forEach(function(e){n.compactDocument(e.id,0,function(){o--,o||t()})}):void t()}})}),s.prototype.get=a.adapterFun("get",function(e,t,r){function o(){var n=[],o=i.length;return o?void i.forEach(function(i){s.get(e,{rev:i,revs:t.revs,attachments:t.attachments},function(e,t){n.push(e?{missing:i}:{ok:t}),o--,o||r(null,n)})}):r(null,n)}if("function"==typeof t&&(r=t,t={}),"string"!=typeof e)return r(c.INVALID_ID);if(a.isLocalId(e)&&"function"==typeof this._getLocal)return this._getLocal(e,r);var i=[],s=this;if(!t.open_revs)return this._get(e,t,function(e,o){if(t=a.clone(t),e)return r(e);var i=o.doc;if(!i)return r(new Error("no doc!"));var c=o.metadata,l=o.ctx;if(t.conflicts){var d=u.collectConflicts(c);d.length&&(i._conflicts=d)}if(t.revs||t.revs_info){var f=u.rootToLeaf(c.rev_tree),p=n(f,function(e){return-1!==e.ids.map(function(e){return e.id}).indexOf(i._rev.split("-")[1])}),h=p.ids.map(function(e){return e.id}).indexOf(i._rev.split("-")[1])+1,v=p.ids.length-h;if(p.ids.splice(h,v),p.ids.reverse(),t.revs&&(i._revisions={start:p.pos+p.ids.length-1,ids:p.ids.map(function(e){return e.id})}),t.revs_info){var m=p.pos+p.ids.length;i._revs_info=p.ids.map(function(e){return m--,{rev:m+"-"+e.id,status:e.opts.status}})}}if(t.local_seq&&(i._local_seq=o.metadata.seq),t.attachments&&i._attachments){var _=i._attachments,y=Object.keys(_).length;if(0===y)return r(null,i);Object.keys(_).forEach(function(e){this._getAttachment(_[e],{encode:!0,ctx:l},function(t,n){var o=i._attachments[e];o.data=n,delete o.stub,--y||r(null,i)})},s)}else{if(i._attachments)for(var g in i._attachments)i._attachments.hasOwnProperty(g)&&(i._attachments[g].stub=!0);r(null,i)}});if("all"===t.open_revs)this._getRevisionTree(e,function(e,t){e&&(t=[]),i=u.collectLeaves(t).map(function(e){return e.rev}),o()});else{if(!Array.isArray(t.open_revs))return r(c.error(c.UNKNOWN_ERROR,"function_clause"));i=t.open_revs;for(var l=0;l<i.length;l++){var d=i[l];if("string"!=typeof d||!/^\d+-/.test(d))return r(c.error(c.BAD_REQUEST,"Invalid rev format"))}o()}}),s.prototype.getAttachment=a.adapterFun("getAttachment",function(e,t,n,r){var o=this;n instanceof Function&&(r=n,n={}),n=a.clone(n),this._get(e,n,function(e,i){return e?r(e):i.doc._attachments&&i.doc._attachments[t]?(n.ctx=i.ctx,void o._getAttachment(i.doc._attachments[t],n,r)):r(c.MISSING_DOC)})}),s.prototype.allDocs=a.adapterFun("allDocs",function(e,t){if("function"==typeof e&&(t=e,e={}),e=a.clone(e),e.skip="undefined"!=typeof e.skip?e.skip:0,"keys"in e){if(!Array.isArray(e.keys))return t(new TypeError("options.keys must be an array"));var n=["startkey","endkey","key"].filter(function(t){return t in e})[0];if(n)return void t(c.error(c.QUERY_PARSE_ERROR,"Query parameter `"+n+"` is not compatible with multi-get"));if("http"!==this.type())return i(this,e,t)}return this._allDocs(e,t)}),s.prototype.changes=function(e,t){return"function"==typeof e&&(t=e,e={}),new f(this,e,t)},s.prototype.close=a.adapterFun("close",function(e){return this._closed=!0,this._close(e)}),s.prototype.info=a.adapterFun("info",function(e){var t=this;this._info(function(n,r){return n?e(n):(r.db_name=r.db_name||t._db_name,void e(null,r))})}),s.prototype.id=a.adapterFun("id",function(e){return this._id(e)}),s.prototype.type=function(){return"function"==typeof this._type?this._type():this.adapter},s.prototype.bulkDocs=a.adapterFun("bulkDocs",function(e,t,n){if("function"==typeof t&&(n=t,t={}),t=a.clone(t),Array.isArray(e)&&(e={docs:e}),!e||!e.docs||!Array.isArray(e.docs))return n(c.MISSING_BULK_DOCS);for(var r=0;r<e.docs.length;++r)if("object"!=typeof e.docs[r]||Array.isArray(e.docs[r]))return n(c.NOT_AN_OBJECT);return e=a.clone(e),"new_edits"in t||(t.new_edits="new_edits"in e?e.new_edits:!0),this._bulkDocs(e,t,this.autoCompact(n))}),s.prototype.registerDependentDatabase=a.adapterFun("registerDependentDatabase",function(e,t){function n(t){return t.dependentDbs=t.dependentDbs||{},t.dependentDbs[e]?!1:(t.dependentDbs[e]=!0,t)}var r=new this.constructor(e,{adapter:this._adapter});d(this,"_local/_pouch_dependentDbs",n,function(e){return e?t(e):t(null,{db:r})})})},{"./changes":6,"./deps/errors":11,"./deps/upsert":13,"./merge":18,"./utils":23,events:27}],2:[function(e,t){(function(n){"use strict";function r(e){for(var t=r.options,n=t.parser[t.strictMode?"strict":"loose"].exec(e),o={},i=14;i--;)o[t.key[i]]=n[i]||"";return o[t.q.name]={},o[t.key[12]].replace(t.q.parser,function(e,n,r){n&&(o[t.q.name][n]=r)}),o}function o(e){return/^_(design|local)/.test(e)?e:encodeURIComponent(e)}function i(e){return e._attachments&&Object.keys(e._attachments)?d.Promise.all(Object.keys(e._attachments).map(function(t){var r=e._attachments[t];if(r.data&&"string"!=typeof r.data){if(void 0===typeof n||n.browser)return new d.Promise(function(e){var t=new FileReader;t.onloadend=function(t){r.data=d.btoa(d.arrayBufferToBinaryString(t.target.result)),e()},t.readAsArrayBuffer(r.data)});r.data=r.data.toString("base64")}})):d.Promise.resolve()}function s(e,t){if(/http(s?):/.test(e)){var n=r(e);n.remote=!0,(n.user||n.password)&&(n.auth={username:n.user,password:n.password});var o=n.path.replace(/(^\/|\/$)/g,"").split("/");if(n.db=o.pop(),n.path=o.join("/"),t=t||{},t=d.clone(t),n.headers=t.headers||{},t.auth||n.auth){var i=t.auth||n.auth,s=d.btoa(i.username+":"+i.password);n.headers.Authorization="Basic "+s}return t.headers&&(n.headers=t.headers),n}return{host:"",path:"/",db:e,auth:!1}}function a(e,t){return u(e,e.db+"/"+t)}function u(e,t){if(e.remote){var n=e.path?"/":"";return e.protocol+"://"+e.host+":"+e.port+"/"+e.path+n+t}return"/"+t}function c(e,t){function n(e,t){return d.ajax(d.extend({},h,e),t)}var r=this;r.getHost=e.getHost?e.getHost:s;var c=r.getHost(e.name,e),p=a(c,"");r.getUrl=function(){return p},r.getHeaders=function(){return d.clone(c.headers)};var h=e.ajax||{};e=d.clone(e);var v=function(){n({headers:c.headers,method:"PUT",url:p},function(e){e&&401===e.status?n({headers:c.headers,method:"HEAD",url:p},function(e){e?t(e):t(null,r)}):e&&412!==e.status?t(e):t(null,r)})};e.skipSetup||n({headers:c.headers,method:"GET",url:p},function(e){e?404===e.status?v():t(e):t(null,r)}),r.type=function(){return"http"},r.id=d.adapterFun("id",function(e){n({headers:c.headers,method:"GET",url:u(c,"")},function(t,n){var r=n&&n.uuid?n.uuid+c.db:a(c,"");e(null,r)})}),r.request=d.adapterFun("request",function(e,t){e.headers=c.headers,e.url=a(c,e.url),n(e,t)}),r.compact=d.adapterFun("compact",function(e,t){"function"==typeof e&&(t=e,e={}),e=d.clone(e),n({headers:c.headers,url:a(c,"_compact"),method:"POST"},function(){function n(){r.info(function(r,o){o.compact_running?setTimeout(n,e.interval||200):t()})}"function"==typeof t&&n()})}),r._info=function(e){n({headers:c.headers,method:"GET",url:a(c,"")},function(t,n){t?e(t):(n.host=a(c,""),e(null,n))})},r.get=d.adapterFun("get",function(e,t,r){"function"==typeof t&&(r=t,t={}),t=d.clone(t),void 0===t.auto_encode&&(t.auto_encode=!0);var i=[];t.revs&&i.push("revs=true"),t.revs_info&&i.push("revs_info=true"),t.local_seq&&i.push("local_seq=true"),t.open_revs&&("all"!==t.open_revs&&(t.open_revs=JSON.stringify(t.open_revs)),i.push("open_revs="+t.open_revs)),t.attachments&&i.push("attachments=true"),t.rev&&i.push("rev="+t.rev),t.conflicts&&i.push("conflicts="+t.conflicts),i=i.join("&"),i=""===i?"":"?"+i,t.auto_encode&&(e=o(e));var s={headers:c.headers,method:"GET",url:a(c,e+i)},u=e.split("/");(u.length>1&&"_design"!==u[0]&&"_local"!==u[0]||u.length>2&&"_design"===u[0]&&"_local"!==u[0])&&(s.binary=!0),n(s,function(e,t,n){return e?r(e):void r(null,t,n)})}),r.remove=d.adapterFun("remove",function(e,t,r,i){var s;"string"==typeof t?(s={_id:e,_rev:t},"function"==typeof r&&(i=r,r={})):(s=e,"function"==typeof t?(i=t,r={}):(i=r,r=t));var u=s._rev||r.rev;n({headers:c.headers,method:"DELETE",url:a(c,o(s._id))+"?rev="+u},i)}),r.getAttachment=d.adapterFun("getAttachment",function(e,t,n,i){"function"==typeof n&&(i=n,n={}),n=d.clone(n),void 0===n.auto_encode&&(n.auto_encode=!0),n.auto_encode&&(e=o(e)),n.auto_encode=!1,r.get(e+"/"+t,n,i)}),r.removeAttachment=d.adapterFun("removeAttachment",function(e,t,r,i){n({headers:c.headers,method:"DELETE",url:a(c,o(e)+"/"+t)+"?rev="+r},i)}),r.putAttachment=d.adapterFun("putAttachment",function(e,t,r,i,s,u){"function"==typeof s&&(u=s,s=i,i=r,r=null),"undefined"==typeof s&&(s=i,i=r,r=null);var l=o(e)+"/"+t,f=a(c,l);r&&(f+="?rev="+r);var p={headers:d.clone(c.headers),method:"PUT",url:f,processData:!1,body:i,timeout:6e4};p.headers["Content-Type"]=s,n(p,u)}),r.put=d.adapterFun("put",d.getArguments(function(e){var t,r,s,u=e.shift(),l="_id"in u,p=e.pop();return"object"!=typeof u||Array.isArray(u)?p(f.NOT_AN_OBJECT):(u=d.clone(u),void i(u).then(function(){for(;;)if(t=e.shift(),r=typeof t,"string"!==r||l?"string"!==r||!l||"_rev"in u?"object"===r&&(s=d.clone(t)):u._rev=t:(u._id=t,l=!0),!e.length)break;s=s||{};var i=d.invalidIdError(u._id);if(i)throw i;var f=[];s&&"undefined"!=typeof s.new_edits&&f.push("new_edits="+s.new_edits),f=f.join("&"),""!==f&&(f="?"+f),n({headers:c.headers,method:"PUT",url:a(c,o(u._id))+f,body:u},function(e,t){return e?p(e):(t.ok=!0,void p(null,t))})})["catch"](p))})),r.post=d.adapterFun("post",function(e,t,n){return"function"==typeof t&&(n=t,t={}),t=d.clone(t),"object"!=typeof e?n(f.NOT_AN_OBJECT):("_id"in e||(e._id=d.uuid()),void r.put(e,t,function(e,t){return e?n(e):(t.ok=!0,void n(null,t))}))}),r._bulkDocs=function(e,t,r){"undefined"!=typeof t.new_edits&&(e.new_edits=t.new_edits),d.Promise.all(e.docs.map(i)).then(function(){n({headers:c.headers,method:"POST",url:a(c,"_bulk_docs"),body:e},function(e,t){return e?r(e):(t.forEach(function(e){e.ok=!0}),void r(null,t))})})["catch"](r)},r.allDocs=d.adapterFun("allDocs",function(e,t){"function"==typeof e&&(t=e,e={}),e=d.clone(e);var r,o=[],i="GET";if(e.conflicts&&o.push("conflicts=true"),e.descending&&o.push("descending=true"),e.include_docs&&o.push("include_docs=true"),e.key&&o.push("key="+encodeURIComponent(JSON.stringify(e.key))),e.startkey&&o.push("startkey="+encodeURIComponent(JSON.stringify(e.startkey))),e.endkey&&o.push("endkey="+encodeURIComponent(JSON.stringify(e.endkey))),"undefined"!=typeof e.inclusive_end&&o.push("inclusive_end="+!!e.inclusive_end),"undefined"!=typeof e.limit&&o.push("limit="+e.limit),"undefined"!=typeof e.skip&&o.push("skip="+e.skip),o=o.join("&"),""!==o&&(o="?"+o),"undefined"!=typeof e.keys){var s=2e3,u="keys="+encodeURIComponent(JSON.stringify(e.keys));u.length+o.length+1<=s?o+=(-1!==o.indexOf("?")?"&":"?")+u:(i="POST",r=JSON.stringify({keys:e.keys}))}n({headers:c.headers,method:i,url:a(c,"_all_docs"+o),body:r},t)}),r._changes=function(e){var t="batch_size"in e?e.batch_size:l;e=d.clone(e),e.timeout=e.timeout||3e4;var r={timeout:e.timeout-5e3},o="undefined"!=typeof e.limit?e.limit:!1;0===o&&(o=1);var i;i="returnDocs"in e?e.returnDocs:!0;var s=o;if(e.style&&(r.style=e.style),(e.include_docs||e.filter&&"function"==typeof e.filter)&&(r.include_docs=!0),e.continuous&&(r.feed="longpoll"),e.conflicts&&(r.conflicts=!0),e.descending&&(r.descending=!0),e.filter&&"string"==typeof e.filter&&(r.filter=e.filter,"_view"===e.filter&&e.view&&"string"==typeof e.view&&(r.view=e.view)),e.query_params&&"object"==typeof e.query_params)for(var u in e.query_params)e.query_params.hasOwnProperty(u)&&(r[u]=e.query_params[u]);var p,h,v=function(i,u){if(!e.aborted){r.since=i,e.descending?o&&(r.limit=s):r.limit=!o||s>t?t:s;var l="?"+Object.keys(r).map(function(e){return e+"="+r[e]}).join("&"),d={headers:c.headers,method:"GET",url:a(c,"_changes"+l),timeout:e.timeout};h=i,e.aborted||(p=n(d,u))}},m=10,_=0,y={results:[]},g=function(n,r){if(!e.aborted){var a=0;if(r&&r.results){a=r.results.length,y.last_seq=r.last_seq;var u={};u.query=e.query_params,r.results=r.results.filter(function(t){s--;var n=d.filterChange(e)(t);return n&&(i&&y.results.push(t),d.call(e.onChange,t)),n})}else if(n)return e.aborted=!0,void d.call(e.complete,n);r&&r.last_seq&&(h=r.last_seq);var c=o&&0>=s||r&&t>a||e.descending;if((!e.continuous||o&&0>=s)&&c)d.call(e.complete,null,y);else{n?_+=1:_=0;var l=1<<_,p=m*l,b=e.maximumWait||3e4;if(p>b)return void d.call(e.complete,n||f.UNKNOWN_ERROR);setTimeout(function(){v(h,g)},p)}}};return v(e.since||0,g),{cancel:function(){e.aborted=!0,p&&p.abort()}}},r.revsDiff=d.adapterFun("revsDiff",function(e,t,r){"function"==typeof t&&(r=t,t={}),n({headers:c.headers,method:"POST",url:a(c,"_revs_diff"),body:JSON.stringify(e)},r)}),r._close=function(e){e()},r.destroy=d.adapterFun("destroy",function(e){n({url:a(c,""),method:"DELETE",headers:c.headers},function(t,n){t?(r.emit("error",t),e(t)):(r.emit("destroyed"),e(null,n))})})}var l=25,d=e("../utils"),f=e("../deps/errors");r.options={strictMode:!1,key:["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],q:{name:"queryKey",parser:/(?:^|&)([^&=]*)=?([^&]*)/g},parser:{strict:/^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,loose:/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/}},c.destroy=d.toPromise(function(e,t,n){var r=s(e,t);t=t||{},"function"==typeof t&&(n=t,t={}),t=d.clone(t),t.headers=r.headers,t.method="DELETE",t.url=a(r,"");var o=t.ajax||{};t=d.extend({},t,o),d.ajax(t,n)}),c.valid=function(){return!0},t.exports=c}).call(this,e("/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))},{"../deps/errors":11,"../utils":23,"/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":28}],3:[function(e,t){(function(n,r){"use strict";function o(e,t,n){try{e.apply(t,n)}catch(r){window.PouchDB&&window.PouchDB.emit("error",r)}}function i(){if(!y.running&&y.queue.length){y.running=!0;var e=y.queue.shift();e.action(function(t,r){o(e.callback,this,[t,r]),y.running=!1,n.nextTick(i)})}}function s(e){return function(t){var n=t.target&&t.target.error&&t.target.error.name||t.target;e(v.error(v.IDB_ERROR,n,t.type))}}function a(){var e="_pouch__checkModernIdb_"+(r.navigator&&r.navigator.appVersion),t=p.hasLocalStorage()&&r.localStorage[e];if(t)return JSON.parse(t);var n="_pouch__checkModernIdb",o=null===r.indexedDB.open(n,1).onupgradeneeded;return r.indexedDB.deleteDatabase&&r.indexedDB.deleteDatabase(n),p.hasLocalStorage()&&(r.localStorage[e]=JSON.stringify(o)),o}function u(e,t,n){var r={data:m.stringify(e)};return r.winningRev=t,r.deletedOrLocal=n?"1":"0",r.id=e.id,r}function c(e){if(!e)return null;if(!e.data)return e;var t=m.parse(e.data);return t.winningRev=e.winningRev,t.deletedOrLocal="1"===e.deletedOrLocal,t}function l(e,t){var n=this;y.queue.push({action:function(t){d(n,e,t)},callback:t}),i()}function d(e,t,o){function i(e){e.createObjectStore(b,{keyPath:"id"}).createIndex("seq","seq",{unique:!0}),e.createObjectStore(w,{autoIncrement:!0}).createIndex("_doc_id_rev","_doc_id_rev",{unique:!0}),e.createObjectStore(E,{keyPath:"digest"}),e.createObjectStore(S,{keyPath:"id",autoIncrement:!1}),e.createObjectStore(x)}function a(e,t){var n=e.currentTarget.transaction,r=n.objectStore(b);r.createIndex("deletedOrLocal","deletedOrLocal",{unique:!1}),r.openCursor().onsuccess=function(e){var o=e.target.result;if(o){var i=o.value,s=p.isDeleted(i);i.deletedOrLocal=s?"1":"0",r.put(i),o["continue"]()}else t(n)}}function d(e){e.createObjectStore(k,{keyPath:"_id"}).createIndex("_doc_id_rev","_doc_id_rev",{unique:!0})}function f(e,t){t=t||e.currentTarget.transaction;var n=t.objectStore(k),o=t.objectStore(b),i=t.objectStore(w),s=o.openCursor();s.onsuccess=function(e){var t=e.target.result;if(t){var s=t.value,a=s.id,u=p.isLocalId(a),c=h.winningRev(s);if(u){var l=a+"::"+c,d=a+"::",f=a+"::~",v=i.index("_doc_id_rev"),m=r.IDBKeyRange.bound(d,f,!1,!1),_=v.openCursor(m);_.onsuccess=function(e){if(_=e.target.result){var r=_.value;r._doc_id_rev===l&&n.put(r),i["delete"](_.primaryKey),_["continue"]()}else o["delete"](t.primaryKey),t["continue"]()}}else t["continue"]()}}}function m(e,t,n){var o="startkey"in t?t.startkey:!1,i="endkey"in t?t.endkey:!1,s="key"in t?t.key:!1,a=t.skip||0,u="number"==typeof t.limit?t.limit:-1,l=t.inclusive_end!==!1,d="descending"in t&&t.descending?"prev":null,f=!1;d&&o&&i&&(f=i,i=!1);var m=null;try{o&&i?m=r.IDBKeyRange.bound(o,i,!1,!l):o?m=d?r.IDBKeyRange.upperBound(o):r.IDBKeyRange.lowerBound(o):i?m=d?r.IDBKeyRange.lowerBound(i,!l):r.IDBKeyRange.upperBound(i,!l):s&&(m=r.IDBKeyRange.only(s))}catch(_){return"DataError"===_.name&&0===_.code?n(null,{total_rows:e,offset:t.skip,rows:[]}):n(v.error(v.IDB_ERROR,_.name,_.message))}var y=L.transaction([b,w],"readonly");y.oncomplete=function(){n(null,{total_rows:e,offset:t.skip,rows:S})};var g=y.objectStore(b),E=d?g.openCursor(m,d):g.openCursor(m),S=[];E.onsuccess=function(e){function n(e,n){var o={id:e.id,key:e.id,value:{rev:i}};if(t.include_docs){o.doc=n,o.doc._rev=i,o.doc._doc_id_rev&&delete o.doc._doc_id_rev,t.conflicts&&(o.doc._conflicts=h.collectConflicts(e));for(var s in o.doc._attachments)o.doc._attachments.hasOwnProperty(s)&&(o.doc._attachments[s].stub=!0)}var c=p.isDeleted(e,i);if("ok"===t.deleted)c&&(o.value.deleted=!0,o.doc=null),S.push(o);else if(!c&&a--<=0){if(f){if(l&&o.key<f)return;if(!l&&o.key<=f)return}if(S.push(o),0===--u)return}r["continue"]()}if(e.target.result){var r=e.target.result,o=c(r.value),i=o.winningRev||h.winningRev(o);if(t.include_docs){var s=y.objectStore(w).index("_doc_id_rev"),d=o.id+"::"+i;s.get(d).onsuccess=function(e){n(c(r.value),e.target.result)}}else n(o)}}}function y(e){if(-1!==R)return e(null,R);var t,n=L.transaction([b],"readonly"),o=n.objectStore(b).index("deletedOrLocal");o.count(r.IDBKeyRange.only("0")).onsuccess=function(e){t=e.target.result},n.onerror=s(e),n.oncomplete=function(){R=t,e(null,R)}}var g=3,b="document-store",w="by-sequence",E="attach-store",S="meta-store",k="local-store",x="detect-blob-support",q=t.name,T=null,A=null,O=!1,L=null,R=-1;e.type=function(){return"idb"},e._id=p.toPromise(function(e){e(null,A)}),e._bulkDocs=function(t,n,r){function o(e){var t=e.target.result;t.updateSeq=(t.updateSeq||0)+M,j.objectStore(S).put(t)}function i(){++P===C.length&&(j.objectStore(S).get(S).onsuccess=o)}function a(){if(C.length){var t=new p.Map;C.forEach(function(n,r){if(n._id&&p.isLocalId(n._id))return void e[n._deleted?"_removeLocal":"_putLocal"](n,{ctx:j},function(e){F[r]=e?e:{},i()});var o=n.metadata.id;t.has(o)?t.get(o).push([n,r]):t.set(o,[[n,r]])}),t.forEach(function(e,t){function n(){i(),++o<e.length&&r()}function r(){var r=e[o],i=r[0],s=r[1];B.has(t)?g(B.get(t),i,s,n):x(i,s,n)}var o=0;r()})}}function d(e){function t(){++n===C.length&&e()}if(!C.length)return e();var n=0;C.forEach(function(e){if(e._id&&p.isLocalId(e._id))return t();var n=e.metadata.id,r=j.objectStore(b).get(n);r.onsuccess=function(e){var r=c(e.target.result);r&&B.set(n,r),t()}})}function f(){var e=F.map(function(e){if(e._bulk_seq)delete e._bulk_seq;else if(!Object.keys(e).length)return{ok:!0};if(e.error)return e;var t=e.metadata,n=h.winningRev(t);return{ok:!0,id:t.id,rev:n}});l.Changes.notify(q),R=-1,r(null,e)}function m(e,t){if(e.stub)return t();if("string"==typeof e.data){var n;try{n=atob(e.data)}catch(o){var i=v.error(v.BAD_ARG,"Attachments need to be base64 encoded");return r(i)}if(T){var s=e.content_type;n=p.fixBinary(n),e.data=p.createBlob([n],{type:s})}return void p.MD5(n).then(function(n){e.digest="md5-"+n,t()})}var a=new FileReader;a.onloadend=function(){var n=p.arrayBufferToBinaryString(this.result||"");T||(e.data=btoa(n)),p.MD5(n).then(function(n){e.digest="md5-"+n,t()})},a.readAsArrayBuffer(e.data)}function _(e){function t(){n++,C.length===n&&e()}if(!C.length)return e();var n=0;C.forEach(function(e){function n(){o++,o===r.length&&t()}var r=e.data&&e.data._attachments?Object.keys(e.data._attachments):[];if(!r.length)return t();var o=0;for(var i in e.data._attachments)e.data._attachments.hasOwnProperty(i)&&m(e.data._attachments[i],n)})}function y(e,t,n,r,o){function i(e){c||(e?(c=e,r(c)):l===d.length&&a())}function s(e){l++,i(e)}function a(){function i(i){var s=e.metadata;s.seq=i.target.result,delete s.rev;var a=u(s,t,n),c=j.objectStore(b).put(a);c.onsuccess=function(){delete s.deletedOrLocal,delete s.winningRev,F[o]=e,B.set(e.metadata.id,e.metadata),p.call(r)}}M++,e.data._doc_id_rev=e.data._id+"::"+e.data._rev;var s=j.objectStore(w),a=s.index("_doc_id_rev"),c=s.put(e.data);c.onsuccess=i,c.onerror=function(t){t.preventDefault(),t.stopPropagation();var n=a.getKey(e.data._doc_id_rev);n.onsuccess=function(t){var n=s.put(e.data,t.target.result);M--,n.onsuccess=i}}}var c=null,l=0;e.data._id=e.metadata.id,e.data._rev=e.metadata.rev,n&&(e.data._deleted=!0);var d=e.data._attachments?Object.keys(e.data._attachments):[];for(var f in e.data._attachments)if(e.data._attachments[f].stub)l++,i();else{var h=e.data._attachments[f].data;delete e.data._attachments[f].data;var v=e.data._attachments[f].digest;O(e,v,h,s)}d.length||a()}function g(e,t,n,r){var o=h.merge(e.rev_tree,t.metadata.rev_tree[0],1e3),i=p.isDeleted(e),s=p.isDeleted(t.metadata),a=i&&s&&I||!i&&I&&"new_leaf"!==o.conflicts;if(a)return F[n]=A(v.REV_CONFLICT,t._bulk_seq),r();t.metadata.rev_tree=o.tree;var u=h.winningRev(t.metadata);s=p.isDeleted(t.metadata,u),y(t,u,s,r,n)}function x(e,t,r){var o=h.winningRev(e.metadata),i=p.isDeleted(e.metadata,o);return"was_delete"in n&&i?(F[t]=v.MISSING_DOC,r()):void y(e,o,i,r,t)}function A(e,t){return e._bulk_seq=t,e}function O(e,t,n,r){var o=j.objectStore(E);o.get(t).onsuccess=function(i){var s=i.target.result&&i.target.result.refs||{},a=[e.metadata.id,e.metadata.rev].join("@"),u={digest:t,body:n,refs:s};u.refs[a]=!0,o.put(u).onsuccess=function(){p.call(r)}}}var I=n.new_edits,D=t.docs,C=D.map(function(e,t){if(e._id&&p.isLocalId(e._id))return e;var n=p.parseDoc(e,I);return n._bulk_seq=t,n}),N=C.filter(function(e){return e.error});if(N.length)return r(N[0]);var j,F=new Array(C.length),B=new p.Map,M=0,P=0;_(function(){var e=[b,w,E,S,k];j=L.transaction(e,"readwrite"),j.onerror=s(r),j.ontimeout=s(r),j.oncomplete=f,d(a)})},e._get=function(e,t,n){function r(){n(s,{doc:o,metadata:i,ctx:a})}var o,i,s,a;t=p.clone(t),a=t.ctx?t.ctx:L.transaction([b,w,E],"readonly"),a.objectStore(b).get(e).onsuccess=function(e){if(i=c(e.target.result),!i)return s=v.MISSING_DOC,r();if(p.isDeleted(i)&&!t.rev)return s=v.error(v.MISSING_DOC,"deleted"),r();var n=a.objectStore(w),u=t.rev||i.winningRev||h.winningRev(i),l=i.id+"::"+u;n.index("_doc_id_rev").get(l).onsuccess=function(e){return o=e.target.result,o&&o._doc_id_rev&&delete o._doc_id_rev,o?void r():(s=v.MISSING_DOC,r())}}},e._getAttachment=function(e,t,n){var r,o;t=p.clone(t),o=t.ctx?t.ctx:L.transaction([b,w,E],"readonly");var i=e.digest,s=e.content_type;o.objectStore(E).get(i).onsuccess=function(e){var o=e.target.result.body;if(t.encode)if(T){var i=new FileReader;i.onloadend=function(){var e=p.arrayBufferToBinaryString(this.result||"");r=btoa(e),n(null,r)},i.readAsArrayBuffer(o)}else r=o,n(null,r);else T?r=o||p.createBlob([""],{type:s}):(o=p.fixBinary(atob(o)),r=p.createBlob([o],{type:s})),n(null,r)}},e._allDocs=function(e,t){y(function(n,r){return n?t(n):0===e.limit?t(null,{total_rows:r,offset:e.skip,rows:[]}):void m(r,e,t)})},e._info=function(e){y(function(t,n){if(t)return e(t);if(null===L){var r=new Error("db isn't open");return r.id="idbNull",e(r)}var o=0,i=L.transaction([S],"readonly");i.objectStore(S).get(S).onsuccess=function(e){o=e.target.result&&e.target.result.updateSeq||0},i.oncomplete=function(){e(null,{doc_count:n,update_seq:o})}})},e._changes=function(t){function n(){v=L.transaction([b,w],"readonly"),v.oncomplete=i;var e;e=a?v.objectStore(w).openCursor(r.IDBKeyRange.lowerBound(t.since,!0),a):v.objectStore(w).openCursor(r.IDBKeyRange.lowerBound(t.since,!0)),e.onsuccess=o,e.onerror=onerror}function o(e){var n=e.target.result;if(n){var r=n.value;if(t.doc_ids&&-1===t.doc_ids.indexOf(r._id))return n["continue"]();var o=v.objectStore(b);o.get(r._id).onsuccess=function(e){var o=c(e.target.result);u<o.seq&&(u=o.seq);var i=o.winningRev||h.winningRev(o);if(r._rev!==i)return n["continue"]();delete r._doc_id_rev;var s=t.processChange(r,o,t);s.seq=n.key,y(s)&&(_++,f&&m.push(s),t.onChange(s)),_!==d&&n["continue"]()}}}function i(){t.continuous||t.complete(null,{results:m,last_seq:u})}if(t=p.clone(t),t.continuous){var s=q+":"+p.uuid();return l.Changes.addListener(q,s,e,t),l.Changes.notify(q),{cancel:function(){l.Changes.removeListener(q,s)}}}var a=t.descending?"prev":null,u=0;t.since=t.since&&!a?t.since:0;var d="limit"in t?t.limit:-1;0===d&&(d=1);var f;f="returnDocs"in t?t.returnDocs:!0;var v,m=[],_=0,y=p.filterChange(t);n()},e._close=function(e){return null===L?e(v.NOT_OPEN):(L.close(),delete _[q],L=null,void e())},e._getRevisionTree=function(e,t){var n=L.transaction([b],"readonly"),r=n.objectStore(b).get(e);r.onsuccess=function(e){var n=c(e.target.result);n?t(null,n.rev_tree):t(v.MISSING_DOC)}},e._doCompaction=function(e,t,n,r){var o=L.transaction([b,w],"readwrite"),i=o.objectStore(b);i.get(e).onsuccess=function(r){var i=c(r.target.result);i.rev_tree=t;var s=n.length;n.forEach(function(t){var n=o.objectStore(w).index("_doc_id_rev"),r=e+"::"+t;n.getKey(r).onsuccess=function(e){var t=e.target.result;if(t&&(o.objectStore(w)["delete"](t),s--,!s)){var n=i.winningRev||h.winningRev(i),r=i.deletedOrLocal;o.objectStore(b).put(u(i,n,r))}}})},o.oncomplete=function(){p.call(r)}},e._getLocal=function(e,t){var n=L.transaction([k],"readonly"),r=n.objectStore(k).get(e);r.onerror=s(t),r.onsuccess=function(e){var n=e.target.result;n?(delete n._doc_id_rev,t(null,n)):t(v.MISSING_DOC)}},e._putLocal=function(e,t,n){"function"==typeof t&&(n=t,t={}),delete e._revisions;var r=e._rev,o=e._id;e._rev=r?"0-"+(parseInt(r.split("-")[1],10)+1):"0-1",e._doc_id_rev=o+"::"+e._rev;var i,a=t.ctx;a||(a=L.transaction([k],"readwrite"),a.onerror=s(n),a.oncomplete=function(){i&&n(null,i)});var u,c=a.objectStore(k);if(r){var l=c.index("_doc_id_rev"),d=o+"::"+r;u=l.get(d),u.onsuccess=function(r){if(r.target.result){var o=c.put(e);o.onsuccess=function(){i={ok:!0,id:e._id,rev:e._rev},t.ctx&&n(null,i)}}else n(v.REV_CONFLICT)}}else u=c.get(o),u.onsuccess=function(r){if(r.target.result)n(v.REV_CONFLICT);
else{var o=c.put(e);o.onsuccess=function(){i={ok:!0,id:e._id,rev:e._rev},t.ctx&&n(null,i)}}}},e._removeLocal=function(e,t){var n,r=L.transaction([k],"readwrite");r.oncomplete=function(){n&&t(null,n)};var o=e._id+"::"+e._rev,i=r.objectStore(k),a=i.index("_doc_id_rev"),u=a.get(o);u.onerror=s(t),u.onsuccess=function(e){var r=e.target.result;if(r){var s=a.getKey(o);s.onsuccess=function(e){var t=e.target.result;i["delete"](t),n={ok:!0,id:r._id,rev:"0-0"}}}else t(v.MISSING_DOC)}};var I=_[q];if(I)return L=I.idb,T=I.blobSupport,A=I.instanceId,O=I.idStored,void n.nextTick(function(){o(null,e)});var D=r.indexedDB.open(q,g);"openReqList"in l||(l.openReqList={}),l.openReqList[q]=D,D.onupgradeneeded=function(e){var t=e.target.result;e.oldVersion<1&&i(t),e.oldVersion<3&&(d(t),e.oldVersion<2?a(e,function(t){f(e,t)}):f(e))},D.onsuccess=function(t){L=t.target.result,L.onversionchange=function(){L.close(),delete _[q]},L.onabort=function(){L.close(),delete _[q]};var n=L.transaction([S,x],"readwrite"),r=n.objectStore(S).get(S);r.onsuccess=function(t){var r=function(){null!==T&&O&&(_[q]={idb:L,blobSupport:T,instanceId:A,idStored:O,loaded:!0},o(null,e))},i=t.target.result||{id:S};q+"_id"in i?(A=i[q+"_id"],O=!0,r()):(A=p.uuid(),i[q+"_id"]=A,n.objectStore(S).put(i).onsuccess=function(){O=!0,r()});try{var s=p.createBlob([""],{type:"image/png"});n.objectStore(x).put(s,"key"),n.oncomplete=function(){n=L.transaction([S,x],"readwrite");var e=n.objectStore(x).get("key");e.onsuccess=function(e){var t=e.target.result,n=URL.createObjectURL(t);p.ajax({url:n,cache:!0,binary:!0},function(e,t){T=e&&405===e.status?!0:!(!t||"image/png"!==t.type),r()})}}}catch(a){T=!1,r()}}},D.onerror=s(o)}function f(e,t,n){"openReqList"in l||(l.openReqList={}),l.Changes.removeAllListeners(e),l.openReqList[e]&&l.openReqList[e].result&&l.openReqList[e].result.close();var o=r.indexedDB.deleteDatabase(e);o.onsuccess=function(){l.openReqList[e]&&(l.openReqList[e]=null),p.hasLocalStorage()&&e in r.localStorage&&delete r.localStorage[e],delete _[e],n(null,{ok:!0})},o.onerror=s(n)}var p=e("../utils"),h=e("../merge"),v=e("../deps/errors"),m=e("vuvuzela"),_={},y={running:!1,queue:[]};l.valid=function(){return r.indexedDB&&a()},l.destroy=p.toPromise(function(e,t,n){y.queue.push({action:function(n){f(e,t,n)},callback:n}),i()}),l.Changes=new p.Changes,t.exports=l}).call(this,e("/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../deps/errors":11,"../merge":18,"../utils":23,"/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":28,vuvuzela:57}],4:[function(e,t){t.exports=["idb","websql"]},{}],5:[function(e,t){(function(n){"use strict";function r(e){return"'"+e+"'"}function o(e,t,n,r,o){return"SELECT "+e+" FROM "+("string"==typeof t?t:t.join(" JOIN "))+(n?" ON "+n:"")+(r?" WHERE "+("string"==typeof r?r:r.join(" AND ")):"")+(o?" ORDER BY "+o:"")}function i(e){return function(t){var n=t&&t.constructor.toString().match(/function ([^\(]+)/),r=n&&n[1]||t.type,o=t.target||t.message;e(h.error(h.WSQ_ERROR,o,r))}}function s(e){return decodeURIComponent(window.escape(e))}function a(e,t){for(var n="",r="UTF-8"===t?2:4,o=0,i=e.length;i>o;o+=r){var a=e.substring(o,o+r);4===r&&(a=a.substring(2,4)+a.substring(0,2)),n+=String.fromCharCode(parseInt(a,16))}return n="UTF-8"===t?s(n):n}function u(e){return delete e._id,delete e._rev,JSON.stringify(e)}function c(e,t,n){return e=JSON.parse(e),e._id=t,e._rev=n,e}function l(e){if("size"in e)return 1e6*e.size;var t=/Android/.test(window.navigator.userAgent);return t?5e6:1}function d(e,t){function r(){f.hasLocalStorage()&&(n.localStorage["_pouch__websqldb_"+M]=!0),t(null,F)}function s(e,t){e.executeSql(T),e.executeSql("ALTER TABLE "+w+" ADD COLUMN deleted TINYINT(1) DEFAULT 0",[],function(){e.executeSql(x),e.executeSql("ALTER TABLE "+b+" ADD COLUMN local TINYINT(1) DEFAULT 0",[],function(){e.executeSql("CREATE INDEX IF NOT EXISTS 'doc-store-local-idx' ON "+b+" (local, id)");var n="SELECT "+b+".winningseq AS seq, "+b+".json AS metadata FROM "+w+" JOIN "+b+" ON "+w+".seq = "+b+".winningseq";e.executeSql(n,[],function(e,n){for(var r=[],o=[],i=0;i<n.rows.length;i++){var s=n.rows.item(i),a=s.seq,u=JSON.parse(s.metadata);f.isDeleted(u)&&r.push(a),f.isLocalId(u.id)&&o.push(u.id)}e.executeSql("UPDATE "+b+"SET local = 1 WHERE id IN ("+o.map(function(){return"?"}).join(",")+")",o,function(){e.executeSql("UPDATE "+w+" SET deleted = 1 WHERE seq IN ("+r.map(function(){return"?"}).join(",")+")",r,t)})})})})}function m(e,t){var n="CREATE TABLE IF NOT EXISTS "+S+" (id UNIQUE, rev, json)";e.executeSql(n,[],function(){var n="SELECT "+b+".id AS id, "+w+".json AS data FROM "+w+" JOIN "+b+" ON "+w+".seq = "+b+".winningseq WHERE local = 1";e.executeSql(n,[],function(e,n){function r(){if(!o.length)return t();var n=o.shift(),i=JSON.parse(n.data)._rev;e.executeSql("INSERT INTO "+S+" (id, rev, json) VALUES (?,?,?)",[n.id,i,n.data],function(e){e.executeSql("DELETE FROM "+b+" WHERE id=?",[n.id],function(e){e.executeSql("DELETE FROM "+w+" WHERE seq=?",[n.seq],function(){r()})})})}for(var o=[],i=0;i<n.rows.length;i++)o.push(n.rows.item(i));r()})})}function L(e,t){function n(n,r){function o(){if(!n.length)return t();var i=n.shift(),s=a(i.hex,r),u=s.lastIndexOf("::"),c=s.substring(0,u),l=s.substring(u+2),d="UPDATE "+w+" SET doc_id=?, rev=? WHERE doc_id_rev=?";e.executeSql(d,[c,l,s],function(){o()})}o()}var r="ALTER TABLE "+w+" ADD COLUMN doc_id";e.executeSql(r,[],function(e){var t="ALTER TABLE "+w+" ADD COLUMN rev";e.executeSql(t,[],function(e){e.executeSql(q,[],function(e){var t="SELECT hex(doc_id_rev) as hex FROM "+w;e.executeSql(t,[],function(e,t){for(var r=[],o=0;o<t.rows.length;o++)r.push(t.rows.item(o));e.executeSql("SELECT dbid, hex(dbid) AS hexId FROM "+k,[],function(e,t){var o=t.rows.item(0).dbid,i=t.rows.item(0).hexId,s=i.length===2*o.length?"UTF-8":"UTF-16";n(r,s)})})})})})}function R(e){for(;U.length>0;){var t=U.pop();t(null,B)}I(e)}function I(e){e.executeSql("SELECT dbid, hex(dbid) AS hexId FROM "+k,[],function(e,t){var n=t.rows.item(0).dbid,r=t.rows.item(0).hexId;j=r.length===2*n.length?"UTF-8":"UTF-16"})}function D(e,t){if(0===t){var n="CREATE TABLE IF NOT EXISTS "+k+" (update_seq INTEGER, dbid, db_version INTEGER)",r="CREATE TABLE IF NOT EXISTS "+E+" (digest, json, body BLOB)",o="CREATE TABLE IF NOT EXISTS "+b+" (id unique, json, winningseq)",i="CREATE TABLE IF NOT EXISTS "+w+" (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, json, deleted TINYINT(1), doc_id, rev)",a="CREATE TABLE IF NOT EXISTS "+S+" (id UNIQUE, rev, json)";e.executeSql(r),e.executeSql(a),e.executeSql(o,[],function(){e.executeSql(T),e.executeSql(i,[],function(){e.executeSql(x),e.executeSql(q),e.executeSql(n,[],function(){var t="INSERT INTO "+k+" (update_seq, db_version, dbid) VALUES (?, ?, ?)";B=f.uuid();var n=[0,g,B];e.executeSql(t,n,function(e){R(e)})})})})}else{var u=function(){var n=g>t;n&&e.executeSql("UPDATE "+k+" SET db_version = "+g);var r="SELECT dbid FROM "+k;e.executeSql(r,[],function(e,t){B=t.rows.item(0).dbid,R(e)})};switch(t){case 1:s(e,function(){m(e,function(){L(e,u)})});break;case 2:m(e,function(){L(e,u)});break;case 3:L(e,u);break;default:u()}}}function C(){J.transaction(function(e){e.executeSql("SELECT sql FROM sqlite_master WHERE tbl_name = "+k,[],function(e,t){t.rows.length?/db_version/.test(t.rows.item(0).sql)?e.executeSql("SELECT db_version FROM "+k,[],function(e,t){var n=t.rows.item(0).db_version;D(e,n)}):e.executeSql("ALTER TABLE "+k+" ADD COLUMN db_version INTEGER",[],function(){D(e,1)}):D(e,0)})},i(t),r)}function N(e,t){if(-1!==G)return t(G);var n=o("COUNT("+b+".id) AS 'num'",[b,w],A,w+".deleted=0");e.executeSql(n,[],function(e,n){G=n.rows.item(0).num,t(G)})}var j,F=this,B=null,M=e.name,P=l(e),U=[],G=-1,J=_(M,y,M,P);return J?("function"!=typeof J.readTransaction&&(J.readTransaction=J.transaction),f.isCordova()&&"undefined"!=typeof n?n.addEventListener(M+"_pouch",function V(){n.removeEventListener(M+"_pouch",V,!1),C()},!1):C(),F.type=function(){return"websql"},F._id=f.toPromise(function(e){e(null,B)}),F._info=function(e){J.readTransaction(function(t){N(t,function(n){var r="SELECT update_seq FROM "+k;t.executeSql(r,[],function(t,r){var o=r.rows.item(0).update_seq;e(null,{doc_count:n,update_seq:o})})})},i(e))},F._bulkDocs=function(e,t,n){function r(){var e=R.map(function(e){if(e._bulk_seq)delete e._bulk_seq;else if(!Object.keys(e).length)return{ok:!0};if(e.error)return e;var t=e.metadata,n=p.winningRev(t);return{ok:!0,id:t.id,rev:n}});d.Changes.notify(M);var t="SELECT update_seq FROM "+k;L.executeSql(t,[],function(t,r){var o=r.rows.item(0).update_seq+I,i="UPDATE "+k+" SET update_seq=?";t.executeSql(i,[o],function(){n(null,e)})})}function s(e,t){if(e.stub)return t();if("string"==typeof e.data){try{e.data=atob(e.data)}catch(r){var o=h.error(h.BAD_ARG,"Attachments need to be base64 encoded");return n(o)}var i=f.fixBinary(e.data);e.data=f.createBlob([i],{type:e.content_type})}var s=new FileReader;s.onloadend=function(){var n=f.arrayBufferToBinaryString(this.result);e.data=n,f.MD5(n).then(function(n){e.digest="md5-"+n,t()})},s.readAsArrayBuffer(e.data)}function a(e){function t(){n++,A.length===n&&e()}if(!A.length)return e();var n=0;A.forEach(function(e){function n(){o++,o===r.length&&t()}var r=e.data&&e.data._attachments?Object.keys(e.data._attachments):[],o=0;if(!r.length)return t();for(var i in e.data._attachments)e.data._attachments.hasOwnProperty(i)&&s(e.data._attachments[i],n)})}function c(e,t,n,r,i,s){function a(){I++;var t=e.data,r=n?1:0,i=t._id,s=t._rev,a=u(t),c="INSERT INTO "+w+" (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);",l=[i,s,a,r];L.executeSql(c,l,function(e,t){d(e,t.insertId)},function(){var e=o("seq",w,null,"doc_id=? AND rev=?");return L.executeSql(e,[i,s],function(e,t){var n=t.rows.item(0).seq,o="UPDATE "+w+" SET json=?, deleted=? WHERE doc_id=? AND rev=?;",u=[a,r,i,s];e.executeSql(o,u,function(e){I--,d(e,n)})}),!1})}function c(e){f||(e?(f=e,r(f)):p===h.length&&a())}function l(e){p++,c(e)}function d(n,o){e.metadata.seq=o,delete e.metadata.rev;var a=i?"UPDATE "+b+" SET json=?, winningseq=(SELECT seq FROM "+w+" WHERE doc_id="+b+".id AND rev=?) WHERE id=?":"INSERT INTO "+b+" (id, winningseq, json) VALUES (?, ?, ?);",u=v.stringify(e.metadata),c=e.metadata.id,l=i?[u,t,c]:[c,o,u];n.executeSql(a,l,function(){R[s]=e,D.set(c,e.metadata),r()})}var f=null,p=0;e.data._id=e.metadata.id,e.data._rev=e.metadata.rev,n&&(e.data._deleted=!0);var h=e.data._attachments?Object.keys(e.data._attachments):[];for(var m in e.data._attachments)if(e.data._attachments[m].stub)p++,c();else{var _=e.data._attachments[m].data;delete e.data._attachments[m].data;var y=e.data._attachments[m].digest;x(e,y,_,l)}h.length||a()}function l(e,t,n,r){var o=p.merge(e.rev_tree,t.metadata.rev_tree[0],1e3),i=f.isDeleted(t.metadata),s=f.isDeleted(e),a=s&&i&&q||!s&&q&&"new_leaf"!==o.conflicts;if(a)return R[n]=S(h.REV_CONFLICT,t._bulk_seq),r();t.metadata.rev_tree=o.tree;var u=p.winningRev(t.metadata);i=f.isDeleted(t.metadata,u),c(t,u,i,r,!0,n)}function m(e,n,r){var o=p.winningRev(e.metadata),i=f.isDeleted(e.metadata,o);return"was_delete"in t&&i?(R[n]=h.MISSING_DOC,r()):void c(e,o,i,r,!1,n)}function _(){++C===A.length&&r()}function y(){if(!A.length)return r();var e=new f.Map;A.forEach(function(t,n){if(t._id&&f.isLocalId(t._id))return void F[t._deleted?"_removeLocal":"_putLocal"](t,{ctx:L},function(e){R[n]=e?e:{},_()});var r=t.metadata.id;e.has(r)?e.get(r).push([t,n]):e.set(r,[[t,n]])}),e.forEach(function(e,t){function n(){_(),++o<e.length&&r()}function r(){var r=e[o],i=r[0],s=r[1];D.has(t)?l(D.get(t),i,s,n):m(i,s,n)}var o=0;r()})}function g(e){function t(){++n===A.length&&e()}if(!A.length)return e();var n=0;A.forEach(function(e){if(e._id&&f.isLocalId(e._id))return t();var n=e.metadata.id;L.executeSql("SELECT json FROM "+b+" WHERE id = ?",[n],function(e,r){if(r.rows.length){var o=v.parse(r.rows.item(0).json);D.set(n,o)}t()})})}function S(e,t){return e._bulk_seq=t,e}function x(e,t,n,r){var o=[e.metadata.id,e.metadata.rev].join("@"),i={digest:t},s="SELECT digest, json FROM "+E+" WHERE digest=?";L.executeSql(s,[t],function(e,a){a.rows.length?(i.refs=JSON.parse(a.rows.item(0).json).refs,s="UPDATE "+E+" SET json=?, body=? WHERE digest=?",e.executeSql(s,[JSON.stringify(i),n,t],function(){r()})):(i.refs={},i.refs[o]=!0,s="INSERT INTO "+E+"(digest, json, body) VALUES (?, ?, ?)",e.executeSql(s,[t,JSON.stringify(i),n],function(){r()}))})}var q=t.new_edits,T=e.docs,A=T.map(function(e,t){if(e._id&&f.isLocalId(e._id))return e;var n=f.parseDoc(e,q);return n._bulk_seq=t,n}),O=A.filter(function(e){return e.error});if(O.length)return n(O[0]);var L,R=new Array(A.length),I=0,D=new f.Map,C=0;a(function(){J.transaction(function(e){L=e,g(y)},i(n),function(){G=-1})})},F._get=function(e,t,n){function r(){n(a,{doc:i,metadata:s,ctx:d})}t=f.clone(t);var i,s,a;if(!t.ctx)return void J.readTransaction(function(r){t.ctx=r,F._get(e,t,n)});var u,l,d=t.ctx;t.rev?(u=o(O,[b,w],b+".id="+w+".doc_id",[w+".doc_id=?",w+".rev=?"]),l=[e,t.rev]):(u=o(O,[b,w],A,b+".id=?"),l=[e]),d.executeSql(u,l,function(e,n){if(!n.rows.length)return a=h.MISSING_DOC,r();var o=n.rows.item(0);return s=v.parse(o.metadata),o.deleted&&!t.rev?(a=h.error(h.MISSING_DOC,"deleted"),r()):(i=c(o.data,s.id,o.rev),void r())})},F._allDocs=function(e,t){var n,r=[],s="startkey"in e?e.startkey:!1,a="endkey"in e?e.endkey:!1,u="key"in e?e.key:!1,l="descending"in e?e.descending:!1,d="limit"in e?e.limit:-1,f="skip"in e?e.skip:0,h=e.inclusive_end!==!1,m=[],_=[];if(u!==!1)_.push(b+".id = ?"),m.push(u);else if(s!==!1||a!==!1){if(s!==!1&&(_.push(b+".id "+(l?"<=":">=")+" ?"),m.push(s)),a!==!1){var y=l?">":"<";h&&(y+="="),_.push(b+".id "+y+" ?"),m.push(a)}u!==!1&&(_.push(b+".id = ?"),m.push(u))}"ok"!==e.deleted&&_.push(w+".deleted = 0"),J.readTransaction(function(t){N(t,function(i){if(n=i,0!==d){var s=o(O,[b,w],A,_,b+".id "+(l?"DESC":"ASC"));s+=" LIMIT "+d+" OFFSET "+f,t.executeSql(s,m,function(t,n){for(var o=0,i=n.rows.length;i>o;o++){var s=n.rows.item(o),a=v.parse(s.metadata),u=c(s.data,a.id,s.rev),l=u._rev,d={id:a.id,key:a.id,value:{rev:l}};if(e.include_docs){d.doc=u,d.doc._rev=l,e.conflicts&&(d.doc._conflicts=p.collectConflicts(a));for(var f in d.doc._attachments)d.doc._attachments.hasOwnProperty(f)&&(d.doc._attachments[f].stub=!0)}if(s.deleted){if("ok"!==e.deleted)continue;d.value.deleted=!0,d.doc=null}r.push(d)}})}})},i(t),function(){t(null,{total_rows:n,offset:e.skip,rows:r})})},F._changes=function(e){function t(){var t=[b+".winningseq > "+e.since],n=[];e.doc_ids&&(t.push(b+".id IN ("+e.doc_ids.map(function(){return"?"}).join(",")+")"),n=e.doc_ids);var l=o(O,[b,w],A,t,b+".winningseq "+(r?"DESC":"ASC")),d=f.filterChange(e);e.view||e.filter||(l+=" LIMIT "+i),J.readTransaction(function(t){t.executeSql(l,n,function(t,n){for(var r=0,o=0,l=n.rows.length;l>o;o++){var f=n.rows.item(o),p=v.parse(f.metadata);r<f.seq&&(r=f.seq);var h=c(f.data,p.id,f.rev),m=e.processChange(h,p,e);if(m.seq=f.seq,d(m)&&(u++,s&&a.push(m),e.onChange(m)),u===i)break}e.continuous||e.complete(null,{results:a,last_seq:r})})})}if(e=f.clone(e),e.continuous){var n=M+":"+f.uuid();return d.Changes.addListener(M,n,F,e),d.Changes.notify(M),{cancel:function(){d.Changes.removeListener(M,n)}}}var r=e.descending;e.since=e.since&&!r?e.since:0;var i="limit"in e?e.limit:-1;0===i&&(i=1);var s;s="returnDocs"in e?e.returnDocs:!0;var a=[],u=0;t()},F._close=function(e){e()},F._getAttachment=function(e,t,n){var r,o=t.ctx,i=e.digest,s=e.content_type,u="SELECT hex(body) as body FROM "+E+" WHERE digest=?";o.executeSql(u,[i],function(e,o){var i=a(o.rows.item(0).body,j);t.encode?r=btoa(i):(i=f.fixBinary(i),r=f.createBlob([i],{type:s})),n(null,r)})},F._getRevisionTree=function(e,t){J.readTransaction(function(n){var r="SELECT json AS metadata FROM "+b+" WHERE id = ?";n.executeSql(r,[e],function(e,n){if(n.rows.length){var r=v.parse(n.rows.item(0).metadata);t(null,r.rev_tree)}else t(h.MISSING_DOC)})})},F._doCompaction=function(e,t,n,r){return n.length?void J.transaction(function(o){var i="SELECT json AS metadata FROM "+b+" WHERE id = ?";o.executeSql(i,[e],function(o,i){if(!i.rows.length)return f.call(r);var s=v.parse(i.rows.item(0).metadata);s.rev_tree=t;var a=0;n.forEach(function(t){var i="DELETE FROM "+w+" WHERE doc_id=? AND rev=?";o.executeSql(i,[e,t],function(t){if(++a===n.length){var o="UPDATE "+b+" SET json = ? WHERE id = ?";t.executeSql(o,[v.stringify(s),e],function(){r()})}})})})}):r()},F._getLocal=function(e,t){J.readTransaction(function(n){var r="SELECT json, rev FROM "+S+" WHERE id=?";n.executeSql(r,[e],function(n,r){if(r.rows.length){var o=r.rows.item(0),i=c(o.json,e,o.rev);t(null,i)}else t(h.MISSING_DOC)})})},F._putLocal=function(e,t,n){function r(e){var r,i;s?(r="UPDATE "+S+" SET rev=?, json=? WHERE id=? AND rev=?",i=[o,l,a,s]):(r="INSERT INTO "+S+" (id, rev, json) VALUES (?,?,?)",i=[a,o,l]),e.executeSql(r,i,function(e,r){r.rowsAffected?(c={ok:!0,id:a,rev:o},t.ctx&&n(null,c)):n(h.REV_CONFLICT)},function(){return n(h.REV_CONFLICT),!1})}"function"==typeof t&&(n=t,t={}),delete e._revisions;var o,s=e._rev,a=e._id;o=e._rev=s?"0-"+(parseInt(s.split("-")[1],10)+1):"0-1";var c,l=u(e);t.ctx?r(t.ctx):J.transaction(function(e){r(e)},i(n),function(){c&&n(null,c)})},void(F._removeLocal=function(e,t){var n;J.transaction(function(r){var o="DELETE FROM "+S+" WHERE id=? AND rev=?",i=[e._id,e._rev];r.executeSql(o,i,function(r,o){return o.rowsAffected?void(n={ok:!0,id:e._id,rev:"0-0"}):t(h.REV_CONFLICT)})},i(t),function(){t(null,n)})})):t(h.UNKNOWN_ERROR)}var f=e("../utils"),p=e("../merge"),h=e("../deps/errors"),v=e("vuvuzela"),m={},_=f.getArguments(function(e){if("undefined"!=typeof n){if(n.navigator&&n.navigator.sqlitePlugin&&n.navigator.sqlitePlugin.openDatabase)return navigator.sqlitePlugin.openDatabase.apply(navigator.sqlitePlugin,e);if(n.sqlitePlugin&&n.sqlitePlugin.openDatabase)return n.sqlitePlugin.openDatabase.apply(n.sqlitePlugin,e);var t=m[e[0]];return t||(t=m[e[0]]=n.openDatabase.apply(n,e)),t}}),y=1,g=4,b=r("document-store"),w=r("by-sequence"),E=r("attach-store"),S=r("local-store"),k=r("metadata-store"),x="CREATE INDEX IF NOT EXISTS 'by-seq-deleted-idx' ON "+w+" (seq, deleted)",q="CREATE UNIQUE INDEX IF NOT EXISTS 'by-seq-doc-id-rev' ON "+w+" (doc_id, rev)",T="CREATE INDEX IF NOT EXISTS 'doc-winningseq-idx' ON "+b+" (winningseq)",A=w+".seq = "+b+".winningseq",O=w+".seq AS seq, "+w+".deleted AS deleted, "+w+".json AS data, "+w+".rev AS rev, "+b+".json AS metadata";d.valid=function(){if("undefined"!=typeof n){if(n.navigator&&n.navigator.sqlitePlugin&&n.navigator.sqlitePlugin.openDatabase)return!0;if(n.sqlitePlugin&&n.sqlitePlugin.openDatabase)return!0;if(n.openDatabase)return!0}return!1},d.destroy=f.toPromise(function(e,t,r){d.Changes.removeAllListeners(e);var o=l(t),s=_(e,y,e,o);s.transaction(function(e){var t=[b,w,E,k,S];t.forEach(function(t){e.executeSql("DROP TABLE IF EXISTS "+t,[])})},i(r),function(){f.hasLocalStorage()&&(delete n.localStorage["_pouch__websqldb_"+e],delete n.localStorage[e]),r(null,{ok:!0})})}),d.Changes=new f.Changes,t.exports=d}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../deps/errors":11,"../merge":18,"../utils":23,vuvuzela:57}],6:[function(e,t){"use strict";function n(e,t,n){function r(){i.cancel()}a.call(this);var i=this;this.db=e,t=t?o.clone(t):{};var s=n||t.complete||function(){},u=t.complete=o.once(function(t,n){t?i.emit("error",t):i.emit("complete",n),i.removeAllListeners(),e.removeListener("destroyed",r)});s&&(i.on("complete",function(e){s(null,e)}),i.on("error",function(e){s(e)}));var c=t.onChange;c&&i.on("change",c),e.once("destroyed",r),t.onChange=function(e){t.isCancelled||(i.emit("change",e),i.startSeq&&i.startSeq<=e.seq&&(i.emit("uptodate"),i.startSeq=!1),e.deleted?i.emit("delete",e):1===e.changes.length&&"1-"===e.changes[0].rev.slice(0,2)?i.emit("create",e):i.emit("update",e))};var l=new o.Promise(function(e,n){t.complete=function(t,r){t?n(t):e(r)}});i.once("cancel",function(){c&&i.removeListener("change",c),t.complete(null,{status:"cancelled"})}),this.then=l.then.bind(l),this["catch"]=l["catch"].bind(l),this.then(function(e){u(null,e)},u),e.taskqueue.isReady?i.doChanges(t):e.taskqueue.addTask(function(){i.isCancelled?i.emit("cancel"):i.doChanges(t)})}function r(e,t,n){var r=[{rev:e._rev}];"all_docs"===n.style&&(r=i.collectLeaves(t.rev_tree).map(function(e){return{rev:e.rev}}));var s={id:t.id,changes:r,doc:e};return o.isDeleted(t,e._rev)&&(s.deleted=!0),n.conflicts&&(s.doc._conflicts=i.collectConflicts(t),s.doc._conflicts.length||delete s.doc._conflicts),s}var o=e("./utils"),i=e("./merge"),s=e("./deps/errors"),a=e("events").EventEmitter,u=e("./evalFilter"),c=e("./evalView");t.exports=n,o.inherits(n,a),n.prototype.cancel=function(){this.isCancelled=!0,this.db.taskqueue.isReady&&this.emit("cancel")},n.prototype.doChanges=function(e){var t=this,n=e.complete;if(e=o.clone(e),"live"in e&&!("continuous"in e)&&(e.continuous=e.live),e.processChange=r,"latest"===e.since&&(e.since="now"),e.since||(e.since=0),"now"===e.since)return void this.db.info().then(function(r){return t.isCancelled?void n(null,{status:"cancelled"}):(e.since=r.update_seq-1,void t.doChanges(e))},n);if(e.continuous&&"now"!==e.since&&this.db.info().then(function(e){t.startSeq=e.update_seq-1},function(e){if("idbNull"!==e.id)throw e}),"http"!==this.db.type()&&e.filter&&"string"==typeof e.filter)return this.filterChanges(e);"descending"in e||(e.descending=!1),e.limit=0===e.limit?1:e.limit,e.complete=n;var i=this.db._changes(e);if(i&&"function"==typeof i.cancel){var s=t.cancel;t.cancel=o.getArguments(function(e){i.cancel(),s.apply(this,e)})}},n.prototype.filterChanges=function(e){var t=this,n=e.complete;if("_view"===e.filter){if(!e.view||"string"!=typeof e.view){var r=new Error("`view` filter parameter is not provided.");return r.status=s.BAD_REQUEST.status,r.name=s.BAD_REQUEST.name,r.error=!0,void n(r)}var o=e.view.split("/");this.db.get("_design/"+o[0],function(r,i){if(t.isCancelled)return void n(null,{status:"cancelled"});if(r)return void n(r);if(i&&i.views&&i.views[o[1]]){var a=c(i.views[o[1]].map);return e.filter=a,void t.doChanges(e)}var u=i.views?"missing json key: "+o[1]:"missing json key: views";r||(r=new Error(u),r.status=s.MISSING_DOC.status,r.name=s.MISSING_DOC.name,r.error=!0),n(r)})}else{var i=e.filter.split("/");this.db.get("_design/"+i[0],function(r,o){if(t.isCancelled)return void n(null,{status:"cancelled"});if(r)return void n(r);if(o&&o.filters&&o.filters[i[1]]){var a=u(o.filters[i[1]]);return e.filter=a,void t.doChanges(e)}var c=o&&o.filters?"missing json key: "+i[1]:"missing json key: filters";return r||(r=new Error(c),r.status=s.MISSING_DOC.status,r.name=s.MISSING_DOC.name,r.error=!0),void n(r)})}}},{"./deps/errors":11,"./evalFilter":15,"./evalView":16,"./merge":18,"./utils":23,events:27}],7:[function(e,t){(function(n){"use strict";function r(e){e&&n.debug&&console.error(e)}function o(e,t,n){if(!(this instanceof o))return new o(e,t,n);var c=this;("function"==typeof t||"undefined"==typeof t)&&(n=t,t={}),e&&"object"==typeof e&&(t=e,e=void 0),"undefined"==typeof n&&(n=r),t=t||{};var l=n;c.auto_compaction=t.auto_compaction,c.prefix=o.prefix,i.call(c),c.taskqueue=new a;var d=new u(function(r,i){n=function(e,t){return e?i(e):(delete t.then,void r(t))},t=s.clone(t);var a,u,l=t.name||e;return function(){try{if("string"!=typeof l)throw u=new Error("Missing/invalid DB name"),u.code=400,u;if(a=o.parseAdapter(l,t),t.originalName=l,t.name=a.name,t.prefix&&"http"!==a.adapter&&"https"!==a.adapter&&(t.name=t.prefix+t.name),t.adapter=t.adapter||a.adapter,c._adapter=t.adapter,c._db_name=l,!o.adapters[t.adapter])throw u=new Error("Adapter is missing"),u.code=404,u;if(!o.adapters[t.adapter].valid())throw u=new Error("Invalid Adapter"),u.code=404,u}catch(e){c.taskqueue.fail(e),c.changes=s.toPromise(function(t){t.complete&&t.complete(e)})}}(),u?i(u):(c.adapter=t.adapter,c.replicate={},c.replicate.from=function(e,t,n){return c.constructor.replicate(e,c,t,n)},c.replicate.to=function(e,t,n){return c.constructor.replicate(c,e,t,n)},c.sync=function(e,t,n){return c.constructor.sync(c,e,t,n)},c.replicate.sync=c.sync,c.destroy=s.adapterFun("destroy",function(e){var t=this;t.info(function(n,r){return n?e(n):void t.constructor.destroy(r.db_name,e)})}),o.adapters[t.adapter].call(c,t,function(e){function r(e){"destroyed"===e&&(c.emit("destroyed"),o.removeListener(l,r))}return e?void(n&&(c.taskqueue.fail(e),n(e))):(o.on(l,r),c.emit("created",c),o.emit("created",t.originalName),c.taskqueue.ready(c),void n(null,c))}),t.skipSetup&&c.taskqueue.ready(c),void(s.isCordova()&&cordova.fireWindowEvent(t.name+"_pouch",{})))});d.then(function(e){l(null,e)},l),c.then=d.then.bind(d),c["catch"]=d["catch"].bind(d)}var i=e("./adapter"),s=e("./utils"),a=e("./taskqueue"),u=s.Promise;s.inherits(o,i),t.exports=o}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./adapter":1,"./taskqueue":22,"./utils":23}],8:[function(e,t){"use strict";function n(e,t){function n(t,n,r){if(e.binary||e.json||!e.processData||"string"==typeof t){if(!e.binary&&e.json&&"string"==typeof t)try{t=JSON.parse(t)}catch(o){return r(o)}}else t=JSON.stringify(t);Array.isArray(t)&&(t=t.map(function(e){var t;return e.ok?e:e.error&&"conflict"===e.error?(t=i.REV_CONFLICT,t.id=e.id,t):e.error&&"forbidden"===e.error?(t=i.FORBIDDEN,t.id=e.id,t.reason=e.reason,t):e.missing?(t=i.MISSING_DOC,t.missing=e.missing,t):e})),r(null,t,n)}function a(e,t){var n,r,o,s;try{n=JSON.parse(e.responseText);for(s in i)if(i.hasOwnProperty(s)&&i[s].name===n.error){o=i[s];break}o||(o=i.UNKNOWN_ERROR,e.status&&(o.status=e.status),e.statusText&&(e.name=e.statusText)),r=i.error(o,n.reason)}catch(a){for(var s in i)if(i.hasOwnProperty(s)&&i[s].status===e.status){o=i[s];break}o||(o=i.UNKNOWN_ERROR,e.status&&(o.status=e.status),e.statusText&&(e.name=e.statusText)),r=i.error(o)}e.withCredentials&&0===e.status&&(r.status=405,r.statusText="Method Not Allowed"),t(r)}var u=!1,c=s.getArguments(function(e){u||(t.apply(this,e),u=!0)});"function"==typeof e&&(c=e,e={}),e=s.clone(e);var l={method:"GET",headers:{},json:!0,processData:!0,timeout:1e4,cache:!1};if(e=s.extend(!0,l,e),"GET"===e.method&&!e.cache){var d=-1!==e.url.indexOf("?");e.url+=(d?"&":"?")+"_nonce="+s.uuid(16)}var f,p;p=e.xhr?new e.xhr:new XMLHttpRequest,p.open(e.method,e.url),p.withCredentials=!0,e.json&&(e.headers.Accept="application/json",e.headers["Content-Type"]=e.headers["Content-Type"]||"application/json",e.body&&e.processData&&"string"!=typeof e.body&&(e.body=JSON.stringify(e.body))),e.binary&&(p.responseType="arraybuffer");var h=function(e,t,n){var r="";if(n){var o=new Date;o.setTime(o.getTime()+24*n*60*60*1e3),r="; expires="+o.toGMTString()}document.cookie=e+"="+t+r+"; path=/"};for(var v in e.headers)if("Cookie"===v){var m=e.headers[v].split("=");h(m[0],m[1],10)}else p.setRequestHeader(v,e.headers[v]);"body"in e||(e.body=null);var _=function(){u||(p.abort(),a(p,c))};if(p.onreadystatechange=function(){if(4===p.readyState&&!u)if(clearTimeout(f),p.status>=200&&p.status<300){var t;t=e.binary?o([p.response||""],{type:p.getResponseHeader("Content-Type")}):p.responseText,n(t,p,c)}else a(p,c)},e.timeout>0&&(f=setTimeout(_,e.timeout),p.onprogress=function(){clearTimeout(f),f=setTimeout(_,e.timeout)},"undefined"==typeof r&&(r=-1!==Object.keys(p).indexOf("upload")),r&&(p.upload.onprogress=p.onprogress)),e.body&&e.body instanceof Blob){var y=new FileReader;y.onloadend=function(){for(var e="",t=new Uint8Array(this.result),n=t.byteLength,r=0;n>r;r++)e+=String.fromCharCode(t[r]);e=s.fixBinary(e),p.send(e)},y.readAsArrayBuffer(e.body)}else p.send(e.body);return{abort:_}}var r,o=e("./blob.js"),i=e("./errors"),s=e("../utils");t.exports=n},{"../utils":23,"./blob.js":9,"./errors":11}],9:[function(e,t){(function(e){"use strict";function n(t,n){t=t||[],n=n||{};try{return new Blob(t,n)}catch(r){if("TypeError"!==r.name)throw r;for(var o=e.BlobBuilder||e.MSBlobBuilder||e.MozBlobBuilder||e.WebKitBlobBuilder,i=new o,s=0;s<t.length;s+=1)i.append(t[s]);return i.getBlob(n.type)}}t.exports=n}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],10:[function(e,t,n){"use strict";function r(){this.store={}}function o(){this.store=new r}n.Map=r,n.Set=o,r.prototype.mangle=function(e){if("string"!=typeof e)throw new TypeError("key must be a string but Got "+e);return"$"+e},r.prototype.unmangle=function(e){return e.substring(1)},r.prototype.get=function(e){var t=this.mangle(e);return t in this.store?this.store[t]:void 0},r.prototype.set=function(e,t){var n=this.mangle(e);return this.store[n]=t,!0},r.prototype.has=function(e){var t=this.mangle(e);return t in this.store},r.prototype["delete"]=function(e){var t=this.mangle(e);return t in this.store?(delete this.store[t],!0):!1},r.prototype.forEach=function(e){var t=this,n=Object.keys(t.store);n.forEach(function(n){var r=t.store[n];n=t.unmangle(n),e(r,n)})},o.prototype.add=function(e){return this.store.set(e,!0)},o.prototype.has=function(e){return this.store.has(e)},o.prototype["delete"]=function(e){return this.store["delete"](e)}},{}],11:[function(e,t,n){"use strict";function r(e){this.status=e.status,this.name=e.error,this.message=e.reason,this.error=!0}r.prototype__proto__=Error.prototype,r.prototype.toString=function(){return JSON.stringify({status:this.status,name:this.name,message:this.message})},n.UNAUTHORIZED=new r({status:401,error:"unauthorized",reason:"Name or password is incorrect."}),n.MISSING_BULK_DOCS=new r({status:400,error:"bad_request",reason:"Missing JSON list of 'docs'"}),n.MISSING_DOC=new r({status:404,error:"not_found",reason:"missing"}),n.REV_CONFLICT=new r({status:409,error:"conflict",reason:"Document update conflict"}),n.INVALID_ID=new r({status:400,error:"invalid_id",reason:"_id field must contain a string"}),n.MISSING_ID=new r({status:412,error:"missing_id",reason:"_id is required for puts"}),n.RESERVED_ID=new r({status:400,error:"bad_request",reason:"Only reserved document ids may start with underscore."}),n.NOT_OPEN=new r({status:412,error:"precondition_failed",reason:"Database not open"}),n.UNKNOWN_ERROR=new r({status:500,error:"unknown_error",reason:"Database encountered an unknown error"}),n.BAD_ARG=new r({status:500,error:"badarg",reason:"Some query argument is invalid"}),n.INVALID_REQUEST=new r({status:400,error:"invalid_request",reason:"Request was invalid"}),n.QUERY_PARSE_ERROR=new r({status:400,error:"query_parse_error",reason:"Some query parameter is invalid"}),n.DOC_VALIDATION=new r({status:500,error:"doc_validation",reason:"Bad special document member"}),n.BAD_REQUEST=new r({status:400,error:"bad_request",reason:"Something wrong with the request"}),n.NOT_AN_OBJECT=new r({status:400,error:"bad_request",reason:"Document must be a JSON object"}),n.DB_MISSING=new r({status:404,error:"not_found",reason:"Database not found"}),n.IDB_ERROR=new r({status:500,error:"indexed_db_went_bad",reason:"unknown"}),n.WSQ_ERROR=new r({status:500,error:"web_sql_went_bad",reason:"unknown"}),n.LDB_ERROR=new r({status:500,error:"levelDB_went_went_bad",reason:"unknown"}),n.FORBIDDEN=new r({status:403,error:"forbidden",reason:"Forbidden by design doc validate_doc_update function"}),n.error=function(e,t,n){function r(){this.message=t,n&&(this.name=n)}return r.prototype=e,new r(t)}},{}],12:[function(e,t){(function(n,r){"use strict";function o(e,t,n){if("function"==typeof e.slice)return t?n?e.slice(t,n):e.slice(t):e.slice();t=Math.floor(t||0),n=Math.floor(n||0);var r=e.byteLength;if(t=0>t?Math.max(t+r,0):Math.min(r,t),n=0>n?Math.max(n+r,0):Math.min(r,n),0>=n-t)return new ArrayBuffer(0);var o=new ArrayBuffer(n-t),i=new Uint8Array(o),s=new Uint8Array(e,t,n-t);return i.set(s),o}function i(e){var t=[255&e,e>>>8&255,e>>>16&255,e>>>24&255];return t.map(function(e){return String.fromCharCode(e)}).join("")}function s(e){for(var t="",n=0;n<e.length;n++)t+=i(e[n]);
return r.btoa(t)}var a=e("crypto"),u=e("spark-md5"),c=r.setImmediate||r.setTimeout;t.exports=function(e,t){function r(e,t,n,r){d?e.appendBinary(t.substring(n,r)):e.append(o(t,n,r))}function i(){var n=v*p,o=n+p;if(n+p>=e.size&&(o=e.size),v++,h>v)r(m,e,n,o),c(i);else{r(m,e,n,o);var a=m.end(!0),u=s(a);t(null,u),m.destroy()}}if(!n.browser){var l=a.createHash("md5").update(e).digest("base64");return void t(null,l)}var d="string"==typeof e,f=d?e.length:e.byteLength,p=Math.min(524288,f),h=Math.ceil(f/p),v=0,m=d?new u:new u.ArrayBuffer;i()}}).call(this,e("/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":28,crypto:26,"spark-md5":56}],13:[function(e,t){"use strict";function n(e,t,n){return new o(function(o,i){return t&&"object"==typeof t&&(t=t._id),"string"!=typeof t?i(new Error("doc id is required")):void e.get(t,function(s,a){if(s)return 404!==s.status?i(s):o(r(e,n({_id:t}),n));var u=n(a);return u?void o(r(e,u,n)):o(a)})})}function r(e,t,r){return e.put(t)["catch"](function(o){if(409!==o.status)throw o;return n(e,t,r)})}var o=e("../utils").Promise;t.exports=function(e,t,r,o){return"function"!=typeof o?n(e,t,r):void n(e,t,r).then(function(e){o(null,e)},o)}},{"../utils":23}],14:[function(e,t){"use strict";function n(e){return 0|Math.random()*e}function r(e,t){t=t||o.length;var r="",i=-1;if(e){for(;++i<e;)r+=o[n(t)];return r}for(;++i<36;)switch(i){case 8:case 13:case 18:case 23:r+="-";break;case 19:r+=o[3&n(16)|8];break;default:r+=o[n(16)]}return r}var o="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");t.exports=r},{}],15:[function(_dereq_,module,exports){"use strict";function evalFilter(input){return eval(["(function () { return ",input," })()"].join(""))}module.exports=evalFilter},{}],16:[function(_dereq_,module,exports){"use strict";function evalView(input){return eval(["(function () {","  return function (doc) {","    var emitted = false;","    var emit = function (a, b) {","      emitted = true;","    };","    var view = "+input+";","    view(doc);","    if (emitted) {","      return true;","    }","  }","})()"].join("\n"))}module.exports=evalView},{}],17:[function(e,t){(function(n){"use strict";var r=e("./setup");t.exports=r,r.ajax=e("./deps/ajax"),r.extend=e("pouchdb-extend"),r.utils=e("./utils"),r.Errors=e("./deps/errors"),r.replicate=e("./replicate").replicate,r.sync=e("./sync"),r.version=e("./version");var o=e("./adapters/http");if(r.adapter("http",o),r.adapter("https",o),r.adapter("idb",e("./adapters/idb")),r.adapter("websql",e("./adapters/websql")),r.plugin(e("pouchdb-mapreduce")),!n.browser){var i=e("./adapters/leveldb");r.adapter("ldb",i),r.adapter("leveldb",i)}}).call(this,e("/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))},{"./adapters/http":2,"./adapters/idb":3,"./adapters/leveldb":26,"./adapters/websql":5,"./deps/ajax":8,"./deps/errors":11,"./replicate":19,"./setup":20,"./sync":21,"./utils":23,"./version":24,"/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":28,"pouchdb-extend":47,"pouchdb-mapreduce":50}],18:[function(e,t){"use strict";function n(e){for(var t,n=e.shift(),r=[n.id,n.opts,[]],o=r;e.length;)n=e.shift(),t=[n.id,n.opts,[]],o[2].push(t),o=t;return r}function r(e,t){for(var n=[{tree1:e,tree2:t}],r=!1;n.length>0;){var o=n.pop(),i=o.tree1,s=o.tree2;(i[1].status||s[1].status)&&(i[1].status="available"===i[1].status||"available"===s[1].status?"available":"missing");for(var a=0;a<s[2].length;a++)if(i[2][0]){for(var u=!1,c=0;c<i[2].length;c++)i[2][c][0]===s[2][a][0]&&(n.push({tree1:i[2][c],tree2:s[2][a]}),u=!0);u||(r="new_branch",i[2].push(s[2][a]),i[2].sort())}else r="new_leaf",i[2][0]=s[2][a]}return{conflicts:r,tree:e}}function o(e,t,n){var o,i=[],s=!1,a=!1;return e.length?(e.forEach(function(e){if(e.pos===t.pos&&e.ids[0]===t.ids[0])o=r(e.ids,t.ids),i.push({pos:e.pos,ids:o.tree}),s=s||o.conflicts,a=!0;else if(n!==!0){var u=e.pos<t.pos?e:t,c=e.pos<t.pos?t:e,l=c.pos-u.pos,d=[],f=[];for(f.push({ids:u.ids,diff:l,parent:null,parentIdx:null});f.length>0;){var p=f.pop();0!==p.diff?p.ids&&p.ids[2].forEach(function(e,t){f.push({ids:e,diff:p.diff-1,parent:p.ids,parentIdx:t})}):p.ids[0]===c.ids[0]&&d.push(p)}var h=d[0];h?(o=r(h.ids,c.ids),h.parent[2][h.parentIdx]=o.tree,i.push({pos:u.pos,ids:u.ids}),s=s||o.conflicts,a=!0):i.push(e)}else i.push(e)}),a||i.push(t),i.sort(function(e,t){return e.pos-t.pos}),{tree:i,conflicts:s||"internal_node"}):{tree:[t],conflicts:"new_leaf"}}function i(e,t){var r=a.rootToLeaf(e).map(function(e){var r=e.ids.slice(-t);return{pos:e.pos+(e.ids.length-r.length),ids:n(r)}});return r.reduce(function(e,t){return o(e,t,!0).tree},[r.shift()])}var s=e("pouchdb-extend"),a={};a.merge=function(e,t,n){e=s(!0,[],e),t=s(!0,{},t);var r=o(e,t);return{tree:i(r.tree,n),conflicts:r.conflicts}},a.winningRev=function(e){var t=[];return a.traverseRevTree(e.rev_tree,function(e,n,r,o,i){e&&t.push({pos:n,id:r,deleted:!!i.deleted})}),t.sort(function(e,t){return e.deleted!==t.deleted?e.deleted>t.deleted?1:-1:e.pos!==t.pos?t.pos-e.pos:e.id<t.id?1:-1}),t[0].pos+"-"+t[0].id},a.traverseRevTree=function(e,t){for(var n,r=e.slice();n=r.pop();)for(var o=n.pos,i=n.ids,s=i[2],a=t(0===s.length,o,i[0],n.ctx,i[1]),u=0,c=s.length;c>u;u++)r.push({pos:o+1,ids:s[u],ctx:a})},a.collectLeaves=function(e){var t=[];return a.traverseRevTree(e,function(e,n,r,o,i){e&&t.unshift({rev:n+"-"+r,pos:n,opts:i})}),t.sort(function(e,t){return t.pos-e.pos}),t.map(function(e){delete e.pos}),t},a.collectConflicts=function(e){var t=a.winningRev(e),n=a.collectLeaves(e.rev_tree),r=[];return n.forEach(function(e){e.rev===t||e.opts.deleted||r.push(e.rev)}),r},a.rootToLeaf=function(e){var t=[];return a.traverseRevTree(e,function(e,n,r,o,i){if(o=o?o.slice(0):[],o.push({id:r,opts:i}),e){var s=n+1-o.length;t.unshift({pos:s,ids:o})}return o}),t},t.exports=a},{"pouchdb-extend":47}],19:[function(e,t,n){"use strict";function r(){d.call(this),this.cancelled=!1;var e=this,t=new l.Promise(function(t,n){e.once("complete",t),e.once("error",n)});e.then=function(e,n){return t.then(e,n)},e["catch"]=function(e){return t["catch"](e)},e["catch"](function(){})}function o(e,t,n){var r=n.filter?n.filter.toString():"";return e.id().then(function(e){return t.id().then(function(t){var o=e+t+r+JSON.stringify(n.query_params)+n.doc_ids;return l.MD5(o).then(function(e){return e=e.replace(/\//g,".").replace(/\+/g,"_"),"_local/"+e})})})}function i(e,t,n,r){return e.get(t)["catch"](function(e){if(404===e.status)return{_id:t};throw e}).then(function(t){return r.cancelled?void 0:(t.last_seq=n,e.put(t))})}function s(e,t,n,r){this.src=e,this.target=t,this.id=n,this.returnValue=r}function a(e,t,n,r,o){function i(){if(0!==k.docs.length){var e=k.docs;return n.bulkDocs({docs:e},{new_edits:!1}).then(function(e){if(o.cancelled)throw y(),new Error("cancelled");var t=[];if(e.forEach(function(e){e.ok||(B.doc_write_failures++,t.push(new Error(e.reason||e.message||"Unknown reason")))}),t.length>0){var n=new Error("bulkDocs error");throw n.other_errors=t,_("target.bulkDocs failed to write docs",n),new Error("bulkWrite partial failure")}},function(t){throw B.doc_write_failures+=e.length,t})}}function a(){for(var e=k.diffs,n=Object.keys(e)[0],r=e[n].missing,i=[],s=0;s<r.length;s+=f)i.push(r.slice(s,Math.min(r.length,s+f)));return l.Promise.all(i.map(function(r){return t.get(n,{revs:!0,open_revs:r,attachments:!0}).then(function(t){t.forEach(function(t){return o.cancelled?y():void(t.ok&&(B.docs_read++,k.pendingRevs++,k.docs.push(t.ok),delete e[t.ok._id]))})})}))}function u(){return Object.keys(k.diffs).length>0?a().then(u):l.Promise.resolve()}function c(){var e=Object.keys(k.diffs).filter(function(e){var t=k.diffs[e].missing;return 1===t.length&&"1-"===t[0].slice(0,2)});return t.allDocs({keys:e,include_docs:!0}).then(function(e){if(o.cancelled)throw y(),new Error("cancelled");e.rows.forEach(function(e){!e.doc||e.deleted||"1-"!==e.value.rev.slice(0,2)||e.doc._attachments&&0!==Object.keys(e.doc._attachments).length||(B.docs_read++,k.pendingRevs++,k.docs.push(e.doc),delete k.diffs[e.id])})})}function d(){return c().then(u)}function p(){return T=!0,F.writeCheckpoint(k.seq).then(function(){if(T=!1,o.cancelled)throw y(),new Error("cancelled");B.last_seq=L=k.seq,B.docs_written+=k.docs.length,o.emit("change",l.clone(B)),k=void 0,E()})["catch"](function(e){throw T=!1,_("writeCheckpoint completed with error",e),e})}function h(){var e={};return k.changes.forEach(function(t){e[t.id]=t.changes.map(function(e){return e.rev})}),n.revsDiff(e).then(function(e){if(o.cancelled)throw y(),new Error("cancelled");k.diffs=e,k.pendingRevs=0})}function v(){if(!o.cancelled&&!k){if(0===x.length)return void m(!0);k=x.shift(),h().then(d).then(i).then(p).then(v)["catch"](function(e){_("batch processing terminated with error",e)})}}function m(e){return 0===q.changes.length?void(0!==x.length||k||((R&&M.live||A)&&o.emit("uptodate",l.clone(B)),A&&y())):void((e||A||q.changes.length>=I)&&(x.push(q),q={seq:0,changes:[],docs:[]},v()))}function _(e,t){O||(B.ok=!1,B.status="aborted",B.errors.push(t),x=[],q={seq:0,changes:[],docs:[]},y())}function y(){if(!(O||o.cancelled&&(B.status="cancelled",T))){if(B.status=B.status||"complete",B.end_time=new Date,B.last_seq=L,O=o.cancelled=!0,B.errors.length>0){var e=B.errors.pop();B.errors.length>0&&(e.other_errors=B.errors),e.result=B,o.emit("error",e)}else o.emit("complete",B);o.removeAllListeners()}}function g(e){return o.cancelled?y():(N++,0!==q.changes.length||0!==x.length||k||o.emit("outofdate",l.clone(B)),q.seq=e.seq,q.changes.push(e),void m(0===x.length))}function b(e){return C=!1,o.cancelled?y():(N>0?(M.since=e.last_seq,E()):R?(M.live=!0,E()):A=!0,void m(!0))}function w(e){return C=!1,o.cancelled?y():void _("changes rejected",e)}function E(){function e(){r.cancel()}function n(){o.removeListener("cancel",e)}if(!C&&!A&&x.length<D){C=!0,N=0,o.once("cancel",e);var r=t.changes(M).on("change",g);r.then(n,n),r.then(b)["catch"](w)}}function S(){F.getCheckpoint().then(function(e){L=e,M={since:L,limit:I,batch_size:I,style:"all_docs",doc_ids:j,returnDocs:!1},r.filter&&(M.filter=r.filter),r.query_params&&(M.query_params=r.query_params),E()})["catch"](function(e){_("getCheckpoint rejected with ",e)})}var k,x=[],q={seq:0,changes:[],docs:[]},T=!1,A=!1,O=!1,L=0,R=r.continuous||r.live||!1,I=r.batch_size||100,D=r.batches_limit||10,C=!1,N=0,j=r.doc_ids,F=new s(t,n,e,o),B={ok:!0,start_time:new Date,docs_read:0,docs_written:0,doc_write_failures:0,errors:[]},M={};o.ready(t,n),o.once("cancel",y),"function"==typeof r.onChange&&o.on("change",r.onChange),"function"==typeof r.complete&&(o.once("error",r.complete),o.once("complete",function(e){r.complete(null,e)})),"undefined"==typeof r.since?S():(T=!0,F.writeCheckpoint(r.since).then(function(){return T=!1,o.cancelled?void y():(L=r.since,void S())})["catch"](function(e){throw T=!1,_("writeCheckpoint completed with error",e),e}))}function u(e,t){var n=t.PouchConstructor;return"string"==typeof e?new n(e):e.then?e:l.Promise.resolve(e)}function c(e,t,n,i){"function"==typeof n&&(i=n,n={}),"undefined"==typeof n&&(n={}),n.complete||(n.complete=i||function(){}),n=l.clone(n),n.continuous=n.continuous||n.live,n.PouchConstructor=n.PouchConstructor||this;var s=new r(n);return u(e,n).then(function(e){return u(t,n).then(function(t){return o(e,t,n).then(function(r){a(r,e,t,n,s)})})})["catch"](function(e){s.emit("error",e),n.complete(e)}),s}var l=e("./utils"),d=e("events").EventEmitter,f=50;l.inherits(r,d),r.prototype.cancel=function(){this.cancelled=!0,this.emit("cancel")},r.prototype.ready=function(e,t){function n(){o.cancel()}function r(){e.removeListener("destroyed",n),t.removeListener("destroyed",n)}var o=this;e.once("destroyed",n),t.once("destroyed",n),this.then(r,r)},s.prototype.writeCheckpoint=function(e){var t=this;return this.updateTarget(e).then(function(){return t.updateSource(e)})},s.prototype.updateTarget=function(e){return i(this.target,this.id,e,this.returnValue)},s.prototype.updateSource=function(e){var t=this;return this.readOnlySource?l.Promise.resolve(!0):i(this.src,this.id,e,this.returnValue)["catch"](function(e){var n="number"==typeof e.status&&4===Math.floor(e.status/100);if(n)return t.readOnlySource=!0,!0;throw e})},s.prototype.getCheckpoint=function(){var e=this;return e.target.get(e.id).then(function(t){return e.src.get(e.id).then(function(e){return t.last_seq===e.last_seq?e.last_seq:0},function(n){if(404===n.status&&t.last_seq)return e.src.put({_id:e.id,last_seq:0}).then(function(){return 0},function(n){return 401===n.status?(e.readOnlySource=!0,t.last_seq):0});throw n})})["catch"](function(e){if(404!==e.status)throw e;return 0})},n.toPouch=u,n.replicate=c},{"./utils":23,events:27}],20:[function(e,t){(function(n){"use strict";var r=e("./constructor"),o=e("./utils"),i=o.Promise,s=e("events").EventEmitter;r.adapters={},r.preferredAdapters=e("./adapters/preferredAdapters.js"),r.prefix="_pouch_";var a=new s,u=["on","addListener","emit","listeners","once","removeAllListeners","removeListener","setMaxListeners"];u.forEach(function(e){r[e]=a[e].bind(a)}),r.setMaxListeners(0),r.parseAdapter=function(e,t){var i,s,a=e.match(/([a-z\-]*):\/\/(.*)/);if(a){if(e=/http(s?)/.test(a[1])?a[1]+"://"+a[2]:a[2],i=a[1],!r.adapters[i].valid())throw"Invalid adapter";return{name:e,adapter:a[1]}}var u="idb"in r.adapters&&"websql"in r.adapters&&o.hasLocalStorage()&&n.localStorage["_pouch__websqldb_"+r.prefix+e];if("undefined"!=typeof t&&t.db)s="leveldb";else for(var c=0;c<r.preferredAdapters.length;++c)if(s=r.preferredAdapters[c],s in r.adapters){if(u&&"idb"===s)continue;break}if(i=r.adapters[s],s&&i){var l="use_prefix"in i?i.use_prefix:!0;return{name:l?r.prefix+e:e,adapter:s}}throw"No valid adapter found"},r.destroy=o.toPromise(function(e,t,n){function s(){c.destroy(f,t,function(t,o){t?n(t):(r.emit("destroyed",e),r.emit(e,"destroyed"),n(null,o||{ok:!0}))})}("function"==typeof t||"undefined"==typeof t)&&(n=t,t={}),e&&"object"==typeof e&&(t=e,e=void 0);var a=r.parseAdapter(t.name||e,t),u=a.name,c=r.adapters[a.adapter],l="use_prefix"in c?c.use_prefix:!0,d=l?u.replace(new RegExp("^"+r.prefix),""):u,f=("http"===a.adapter||"https"===a.adapter?"":t.prefix||"")+u,p=o.extend(!0,{},t,{adapter:a.adapter});new r(d,p,function(e,u){return e?n(e):void u.get("_local/_pouch_dependentDbs",function(e,u){if(e)return 404!==e.status?n(e):s();var c=u.dependentDbs,d=Object.keys(c).map(function(e){var n=l?e.replace(new RegExp("^"+r.prefix),""):e,i=o.extend(!0,t,{adapter:a.adapter});return r.destroy(n,i)});i.all(d).then(s,function(e){n(e)})})})}),r.allDbs=o.toPromise(function(e){var t=new Error("allDbs method removed");t.stats="400",e(t)}),r.adapter=function(e,t){t.valid()&&(r.adapters[e]=t)},r.plugin=function(e){Object.keys(e).forEach(function(t){r.prototype[t]=e[t]})},r.defaults=function(e){function t(t,n,i){("function"==typeof n||"undefined"==typeof n)&&(i=n,n={}),t&&"object"==typeof t&&(n=t,t=void 0),n=o.extend(!0,{},e,n),r.call(this,t,n,i)}return o.inherits(t,r),t.destroy=o.toPromise(function(t,n,i){return("function"==typeof n||"undefined"==typeof n)&&(i=n,n={}),t&&"object"==typeof t&&(n=t,t=void 0),n=o.extend(!0,{},e,n),r.destroy(t,n,i)}),u.forEach(function(e){t[e]=a[e].bind(a)}),t.setMaxListeners(0),t.preferredAdapters=r.preferredAdapters.slice(),Object.keys(r).forEach(function(e){e in t||(t[e]=r[e])}),t},t.exports=r}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./adapters/preferredAdapters.js":4,"./constructor":7,"./utils":23,events:27}],21:[function(e,t){"use strict";function n(e,t,n,s){return"function"==typeof n&&(s=n,n={}),"undefined"==typeof n&&(n={}),n=o.clone(n),n.PouchConstructor=n.PouchConstructor||this,e=i.toPouch(e,n),t=i.toPouch(t,n),new r(e,t,n,s)}function r(e,t,n,r){function i(e){p||(p=!0,l.emit("cancel",e))}function a(e){l.emit("change",{direction:"pull",change:e})}function u(e){l.emit("change",{direction:"push",change:e})}function c(e){return function(t,n){var r="change"===t&&(n===a||n===u),o="cancel"===t&&n===i,s=t in h&&n===h[t];(r||o||s)&&(t in v||(v[t]={}),v[t][e]=!0,2===Object.keys(v[t]).length&&l.removeAllListeners(t))}}var l=this;this.canceled=!1;var d,f;"onChange"in n&&(d=n.onChange,delete n.onChange),"function"!=typeof r||n.complete?"complete"in n&&(f=n.complete,delete n.complete):f=r,this.push=s(e,t,n),this.pull=s(t,e,n);var p=!1,h={},v={};this.on("newListener",function(e){"change"===e?(l.pull.on("change",a),l.push.on("change",u)):"cancel"===e?(l.pull.on("cancel",i),l.push.on("cancel",i)):"error"===e||"removeListener"===e||"complete"===e||e in h||(h[e]=function(t){l.emit(e,t)},l.pull.on(e,h[e]),l.push.on(e,h[e]))}),this.on("removeListener",function(e){"change"===e?(l.pull.removeListener("change",a),l.push.removeListener("change",u)):"cancel"===e?(l.pull.removeListener("cancel",i),l.push.removeListener("cancel",i)):e in h&&"function"==typeof h[e]&&(l.pull.removeListener(e,h[e]),l.push.removeListener(e,h[e]),delete h[e])}),this.pull.on("removeListener",c("pull")),this.push.on("removeListener",c("push"));var m=o.Promise.all([this.push,this.pull]).then(function(e){var t={push:e[0],pull:e[1]};return l.emit("complete",t),f&&f(null,t),l.removeAllListeners(),t},function(e){throw l.cancel(),l.emit("error",e),f&&f(e),l.removeAllListeners(),e});this.then=function(e,t){return m.then(e,t)},this["catch"]=function(e){return m["catch"](e)}}var o=e("./utils"),i=e("./replicate"),s=i.replicate,a=e("events").EventEmitter;o.inherits(r,a),t.exports=n,r.prototype.cancel=function(){this.canceled||(this.canceled=!0,this.push.cancel(),this.pull.cancel())}},{"./replicate":19,"./utils":23,events:27}],22:[function(e,t){"use strict";function n(){this.isReady=!1,this.failed=!1,this.queue=[]}t.exports=n,n.prototype.execute=function(){var e,t;if(this.failed)for(;e=this.queue.shift();)"function"!=typeof e?(t=e.parameters[e.parameters.length-1],"function"==typeof t?t(this.failed):"changes"===e.name&&"function"==typeof t.complete&&t.complete(this.failed)):e(this.failed);else if(this.isReady)for(;e=this.queue.shift();)"function"==typeof e?e():e.task=this.db[e.name].apply(this.db,e.parameters)},n.prototype.fail=function(e){this.failed=e,this.execute()},n.prototype.ready=function(e){return this.failed?!1:0===arguments.length?this.isReady:(this.isReady=e?!0:!1,this.db=e,void this.execute())},n.prototype.addTask=function(e,t){if("function"!=typeof e){var n={name:e,parameters:t};return this.queue.push(n),this.failed&&this.execute(),n}this.queue.push(e),this.failed&&this.execute()}},{}],23:[function(e,t,n){(function(t,r){function o(e){var t={};return e.forEach(function(e){t[e]=!0}),t}function i(){return"undefined"!=typeof chrome&&"undefined"!=typeof chrome.storage&&"undefined"!=typeof chrome.storage.local}function s(){if(!(this instanceof s))return new s;var e=this;l.call(this),this.isChrome=i(),this.listeners={},this.hasLocal=!1,this.isChrome||(this.hasLocal=n.hasLocalStorage()),this.isChrome?chrome.storage.onChanged.addListener(function(t){null!=t.db_name&&e.emit(t.dbName.newValue)}):this.hasLocal&&(r.addEventListener?r.addEventListener("storage",function(t){e.emit(t.key)}):r.attachEvent("storage",function(t){e.emit(t.key)}))}var a=e("./merge");n.extend=e("pouchdb-extend"),n.ajax=e("./deps/ajax"),n.createBlob=e("./deps/blob"),n.uuid=e("./deps/uuid"),n.getArguments=e("argsarray");var u=e("./deps/buffer"),c=e("./deps/errors"),l=e("events").EventEmitter,d=e("./deps/collections");n.Map=d.Map,n.Set=d.Set,n.Promise="function"==typeof r.Promise?r.Promise:e("bluebird");var f=n.Promise,p=o(["_id","_rev","_attachments","_deleted","_revisions","_revs_info","_conflicts","_deleted_conflicts","_local_seq","_rev_tree","_replication_id","_replication_state","_replication_state_time","_replication_state_reason","_replication_stats"]);n.clone=function(e){return n.extend(!0,{},e)},n.inherits=e("inherits"),n.invalidIdError=function(e){var t;if(e?"string"!=typeof e?(t=new TypeError(c.INVALID_ID.message),t.status=400):/^_/.test(e)&&!/^_(design|local)/.test(e)&&(t=new TypeError(c.RESERVED_ID.message),t.status=400):(t=new TypeError(c.MISSING_ID.message),t.status=412),t)throw t},n.call=n.getArguments(function(e){if(e.length){var t=e.shift();"function"==typeof t&&t.apply(this,e)}}),n.isLocalId=function(e){return/^_local/.test(e)},n.isDeleted=function(e,t){t||(t=a.winningRev(e));var n=t.indexOf("-");-1!==n&&(t=t.substring(n+1));var r=!1;return a.traverseRevTree(e.rev_tree,function(e,n,o,i,s){o===t&&(r=!!s.deleted)}),r},n.filterChange=function(e){return function(t){var n={},r=e.filter&&"function"==typeof e.filter;if(n.query=e.query_params,e.filter&&r&&!e.filter.call(this,t.doc,n))return!1;if(e.doc_ids&&-1===e.doc_ids.indexOf(t.id))return!1;if(e.include_docs)for(var o in t.doc._attachments)t.doc._attachments.hasOwnProperty(o)&&(t.doc._attachments[o].stub=!0);else delete t.doc;return!0}},n.parseDoc=function(e,t){var r,o,i,s,a={status:"available"};if(e._deleted&&(a.deleted=!0),t)if(e._id||(e._id=n.uuid()),o=n.uuid(32,16).toLowerCase(),e._rev){if(i=/^(\d+)-(.+)$/.exec(e._rev),!i){var u=new TypeError("invalid value for property '_rev'");u.status=400}e._rev_tree=[{pos:parseInt(i[1],10),ids:[i[2],{status:"missing"},[[o,a,[]]]]}],r=parseInt(i[1],10)+1}else e._rev_tree=[{pos:1,ids:[o,a,[]]}],r=1;else if(e._revisions&&(e._rev_tree=[{pos:e._revisions.start-e._revisions.ids.length+1,ids:e._revisions.ids.reduce(function(e,t){return null===e?[t,a,[]]:[t,{status:"missing"},[e]]},null)}],r=e._revisions.start,o=e._revisions.ids[0]),!e._rev_tree){if(i=/^(\d+)-(.+)$/.exec(e._rev),!i)throw s=new TypeError(c.BAD_ARG.message),s.status=c.BAD_ARG.status,s;r=parseInt(i[1],10),o=i[2],e._rev_tree=[{pos:parseInt(i[1],10),ids:[i[2],a,[]]}]}n.invalidIdError(e._id),e._rev=[r,o].join("-");var l={metadata:{},data:{}};for(var d in e)if(e.hasOwnProperty(d)){var f="_"===d[0];if(f&&!p[d])throw s=new Error(c.DOC_VALIDATION.message+": "+d),s.status=c.DOC_VALIDATION.status,s;f&&"_attachments"!==d?l.metadata[d.slice(1)]=e[d]:l.data[d]=e[d]}return l},n.isCordova=function(){return"undefined"!=typeof cordova||"undefined"!=typeof PhoneGap||"undefined"!=typeof phonegap},n.hasLocalStorage=function(){if(i())return!1;try{return r.localStorage}catch(e){return!1}},n.Changes=s,n.inherits(s,l),s.prototype.addListener=function(e,t,r,o){function i(){r.changes({include_docs:o.include_docs,conflicts:o.conflicts,continuous:!1,descending:!1,filter:o.filter,view:o.view,since:o.since,query_params:o.query_params,onChange:function(e){e.seq>o.since&&!o.cancelled&&(o.since=e.seq,n.call(o.onChange,e))}})}this.listeners[t]||(this.listeners[t]=i,this.on(e,i))},s.prototype.removeListener=function(e,t){t in this.listeners&&l.prototype.removeListener.call(this,e,this.listeners[t])},s.prototype.notifyLocalWindows=function(e){this.isChrome?chrome.storage.local.set({dbName:e}):this.hasLocal&&(localStorage[e]="a"===localStorage[e]?"b":"a")},s.prototype.notify=function(e){this.emit(e),this.notifyLocalWindows(e)},n.atob=t.browser&&"atob"in r?function(e){return atob(e)}:function(e){var t=new u(e,"base64");if(t.toString("base64")!==e)throw"Cannot base64 encode full string";return t.toString("binary")},n.btoa=t.browser&&"btoa"in r?function(e){return btoa(e)}:function(e){return new u(e,"binary").toString("base64")},n.fixBinary=function(e){if(!t.browser)return e;for(var n=e.length,r=new ArrayBuffer(n),o=new Uint8Array(r),i=0;n>i;i++)o[i]=e.charCodeAt(i);return r},n.once=function(e){var t=!1;return n.getArguments(function(n){if(t)throw"function"==typeof console.trace&&console.trace(),new Error("once called  more than once");t=!0,e.apply(this,n)})},n.toPromise=function(e){return n.getArguments(function(r){var o,i=this,s="function"==typeof r[r.length-1]?r.pop():!1;s&&(o=function(e,n){t.nextTick(function(){s(e,n)})});var a=new f(function(t,o){var s;try{var a=n.once(function(e,n){e?o(e):t(n)});r.push(a),s=e.apply(i,r),s&&"function"==typeof s.then&&t(s)}catch(u){o(u)}});return o&&a.then(function(e){o(null,e)},o),a.cancel=function(){return this},a})},n.adapterFun=function(e,t){return n.toPromise(n.getArguments(function(r){if(this._closed)return f.reject(new Error("database is closed"));var o=this;return this.taskqueue.isReady?t.apply(this,r):new n.Promise(function(t,n){o.taskqueue.addTask(function(i){i?n(i):t(o[e].apply(o,r))})})}))},n.arrayBufferToBinaryString=function(e){for(var t="",n=new Uint8Array(e),r=n.byteLength,o=0;r>o;o++)t+=String.fromCharCode(n[o]);return t},n.cancellableFun=function(e,t,r){r=r?n.clone(!0,{},r):{};var o=new l,i=r.complete||function(){},s=r.complete=n.once(function(e,t){e?i(e):(o.emit("end",t),i(null,t)),o.removeAllListeners()}),a=r.onChange||function(){},u=0;t.on("destroyed",function(){o.removeAllListeners()}),r.onChange=function(e){a(e),e.seq<=u||(u=e.seq,o.emit("change",e),e.deleted?o.emit("delete",e):1===e.changes.length&&"1-"===e.changes[0].rev.slice(0,1)?o.emit("create",e):o.emit("update",e))};var c=new f(function(e,t){r.complete=function(n,r){n?t(n):e(r)}});return c.then(function(e){s(null,e)},s),c.cancel=function(){c.isCancelled=!0,t.taskqueue.isReady&&r.complete(null,{status:"cancelled"})},t.taskqueue.isReady?e(t,r,c):t.taskqueue.addTask(function(){c.isCancelled?r.complete(null,{status:"cancelled"}):e(t,r,c)}),c.on=o.on.bind(o),c.once=o.once.bind(o),c.addListener=o.addListener.bind(o),c.removeListener=o.removeListener.bind(o),c.removeAllListeners=o.removeAllListeners.bind(o),c.setMaxListeners=o.setMaxListeners.bind(o),c.listeners=o.listeners.bind(o),c.emit=o.emit.bind(o),c},n.MD5=n.toPromise(e("./deps/md5"))}).call(this,e("/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./deps/ajax":8,"./deps/blob":9,"./deps/buffer":26,"./deps/collections":10,"./deps/errors":11,"./deps/md5":12,"./deps/uuid":14,"./merge":18,"/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":28,argsarray:25,bluebird:33,events:27,inherits:29,"pouchdb-extend":47}],24:[function(e,t){t.exports="3.0.5"},{}],25:[function(e,t){"use strict";function n(e){return function(){var t=arguments.length;if(t){for(var n=[],r=-1;++r<t;)n[r]=arguments[r];return e.call(this,n)}return e.call(this,[])}}t.exports=n},{}],26:[function(){},{}],27:[function(e,t){function n(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function r(e){return"function"==typeof e}function o(e){return"number"==typeof e}function i(e){return"object"==typeof e&&null!==e}function s(e){return void 0===e}t.exports=n,n.EventEmitter=n,n.prototype._events=void 0,n.prototype._maxListeners=void 0,n.defaultMaxListeners=10,n.prototype.setMaxListeners=function(e){if(!o(e)||0>e||isNaN(e))throw TypeError("n must be a positive number");return this._maxListeners=e,this},n.prototype.emit=function(e){var t,n,o,a,u,c;if(this._events||(this._events={}),"error"===e&&(!this._events.error||i(this._events.error)&&!this._events.error.length)){if(t=arguments[1],t instanceof Error)throw t;throw TypeError('Uncaught, unspecified "error" event.')}if(n=this._events[e],s(n))return!1;if(r(n))switch(arguments.length){case 1:n.call(this);break;case 2:n.call(this,arguments[1]);break;case 3:n.call(this,arguments[1],arguments[2]);break;default:for(o=arguments.length,a=new Array(o-1),u=1;o>u;u++)a[u-1]=arguments[u];n.apply(this,a)}else if(i(n)){for(o=arguments.length,a=new Array(o-1),u=1;o>u;u++)a[u-1]=arguments[u];for(c=n.slice(),o=c.length,u=0;o>u;u++)c[u].apply(this,a)}return!0},n.prototype.addListener=function(e,t){var o;if(!r(t))throw TypeError("listener must be a function");if(this._events||(this._events={}),this._events.newListener&&this.emit("newListener",e,r(t.listener)?t.listener:t),this._events[e]?i(this._events[e])?this._events[e].push(t):this._events[e]=[this._events[e],t]:this._events[e]=t,i(this._events[e])&&!this._events[e].warned){var o;o=s(this._maxListeners)?n.defaultMaxListeners:this._maxListeners,o&&o>0&&this._events[e].length>o&&(this._events[e].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[e].length),"function"==typeof console.trace&&console.trace())}return this},n.prototype.on=n.prototype.addListener,n.prototype.once=function(e,t){function n(){this.removeListener(e,n),o||(o=!0,t.apply(this,arguments))}if(!r(t))throw TypeError("listener must be a function");var o=!1;return n.listener=t,this.on(e,n),this},n.prototype.removeListener=function(e,t){var n,o,s,a;if(!r(t))throw TypeError("listener must be a function");if(!this._events||!this._events[e])return this;if(n=this._events[e],s=n.length,o=-1,n===t||r(n.listener)&&n.listener===t)delete this._events[e],this._events.removeListener&&this.emit("removeListener",e,t);else if(i(n)){for(a=s;a-->0;)if(n[a]===t||n[a].listener&&n[a].listener===t){o=a;break}if(0>o)return this;1===n.length?(n.length=0,delete this._events[e]):n.splice(o,1),this._events.removeListener&&this.emit("removeListener",e,t)}return this},n.prototype.removeAllListeners=function(e){var t,n;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[e]&&delete this._events[e],this;if(0===arguments.length){for(t in this._events)"removeListener"!==t&&this.removeAllListeners(t);return this.removeAllListeners("removeListener"),this._events={},this}if(n=this._events[e],r(n))this.removeListener(e,n);else for(;n.length;)this.removeListener(e,n[n.length-1]);return delete this._events[e],this},n.prototype.listeners=function(e){var t;return t=this._events&&this._events[e]?r(this._events[e])?[this._events[e]]:this._events[e].slice():[]},n.listenerCount=function(e,t){var n;return n=e._events&&e._events[t]?r(e._events[t])?1:e._events[t].length:0}},{}],28:[function(e,t){var n=t.exports={};n.nextTick=function(){var e="undefined"!=typeof window&&window.setImmediate,t="undefined"!=typeof window&&window.postMessage&&window.addEventListener;if(e)return function(e){return window.setImmediate(e)};if(t){var n=[];return window.addEventListener("message",function(e){var t=e.source;if((t===window||null===t)&&"process-tick"===e.data&&(e.stopPropagation(),n.length>0)){var r=n.shift();r()}},!0),function(e){n.push(e),window.postMessage("process-tick","*")}}return function(e){setTimeout(e,0)}}(),n.title="browser",n.browser=!0,n.env={},n.argv=[],n.binding=function(){throw new Error("process.binding is not supported")},n.cwd=function(){return"/"},n.chdir=function(){throw new Error("process.chdir is not supported")}},{}],29:[function(e,t){t.exports="function"==typeof Object.create?function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:function(e,t){e.super_=t;var n=function(){};n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e}},{}],30:[function(e,t){"use strict";function n(){}t.exports=n},{}],31:[function(e,t){"use strict";var n=e("./promise"),r=e("./reject"),o=e("./resolve"),i=e("./INTERNAL"),s=e("./handlers"),a=r(new TypeError("must be an array"));t.exports=function(e){function t(e,t){function n(e){c[t]=e,++l===r&!u&&(u=!0,s.resolve(f,c))}o(e).then(n,function(e){u||(u=!0,s.reject(f,e))})}if("[object Array]"!==Object.prototype.toString.call(e))return a;var r=e.length,u=!1;if(!r)return o([]);for(var c=new Array(r),l=0,d=-1,f=new n(i);++d<r;)t(e[d],d);return f}},{"./INTERNAL":30,"./handlers":32,"./promise":34,"./reject":36,"./resolve":37}],32:[function(e,t,n){"use strict";function r(e){var t=e&&e.then;return e&&"object"==typeof e&&"function"==typeof t?function(){t.apply(e,arguments)}:void 0}var o=e("./tryCatch"),i=e("./resolveThenable"),s=e("./states");
n.resolve=function(e,t){var a=o(r,t);if("error"===a.status)return n.reject(e,a.value);var u=a.value;if(u)i.safely(e,u);else{e.state=s.FULFILLED,e.outcome=t;for(var c=-1,l=e.queue.length;++c<l;)e.queue[c].callFulfilled(t)}return e},n.reject=function(e,t){e.state=s.REJECTED,e.outcome=t;for(var n=-1,r=e.queue.length;++n<r;)e.queue[n].callRejected(t);return e}},{"./resolveThenable":38,"./states":39,"./tryCatch":40}],33:[function(e,t,n){t.exports=n=e("./promise"),n.resolve=e("./resolve"),n.reject=e("./reject"),n.all=e("./all")},{"./all":31,"./promise":34,"./reject":36,"./resolve":37}],34:[function(e,t){"use strict";function n(e){if(!(this instanceof n))return new n(e);if("function"!=typeof e)throw new TypeError("reslover must be a function");this.state=s.PENDING,this.queue=[],this.outcome=void 0,e!==o&&i.safely(this,e)}var r=e("./unwrap"),o=e("./INTERNAL"),i=e("./resolveThenable"),s=e("./states"),a=e("./queueItem");t.exports=n,n.prototype["catch"]=function(e){return this.then(null,e)},n.prototype.then=function(e,t){if("function"!=typeof e&&this.state===s.FULFILLED||"function"!=typeof t&&this.state===s.REJECTED)return this;var i=new n(o);if(this.state!==s.PENDING){var u=this.state===s.FULFILLED?e:t;r(i,u,this.outcome)}else this.queue.push(new a(i,e,t));return i}},{"./INTERNAL":30,"./queueItem":35,"./resolveThenable":38,"./states":39,"./unwrap":41}],35:[function(e,t){"use strict";function n(e,t,n){this.promise=e,"function"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),"function"==typeof n&&(this.onRejected=n,this.callRejected=this.otherCallRejected)}var r=e("./handlers"),o=e("./unwrap");t.exports=n,n.prototype.callFulfilled=function(e){r.resolve(this.promise,e)},n.prototype.otherCallFulfilled=function(e){o(this.promise,this.onFulfilled,e)},n.prototype.callRejected=function(e){r.reject(this.promise,e)},n.prototype.otherCallRejected=function(e){o(this.promise,this.onRejected,e)}},{"./handlers":32,"./unwrap":41}],36:[function(e,t){"use strict";function n(e){var t=new r(o);return i.reject(t,e)}var r=e("./promise"),o=e("./INTERNAL"),i=e("./handlers");t.exports=n},{"./INTERNAL":30,"./handlers":32,"./promise":34}],37:[function(e,t){"use strict";function n(e){if(e)return e instanceof r?e:i.resolve(new r(o),e);var t=typeof e;switch(t){case"boolean":return s;case"undefined":return u;case"object":return a;case"number":return c;case"string":return l}}var r=e("./promise"),o=e("./INTERNAL"),i=e("./handlers");t.exports=n;var s=i.resolve(new r(o),!1),a=i.resolve(new r(o),null),u=i.resolve(new r(o),void 0),c=i.resolve(new r(o),0),l=i.resolve(new r(o),"")},{"./INTERNAL":30,"./handlers":32,"./promise":34}],38:[function(e,t,n){"use strict";function r(e,t){function n(t){a||(a=!0,o.reject(e,t))}function r(t){a||(a=!0,o.resolve(e,t))}function s(){t(r,n)}var a=!1,u=i(s);"error"===u.status&&n(u.value)}var o=e("./handlers"),i=e("./tryCatch");n.safely=r},{"./handlers":32,"./tryCatch":40}],39:[function(e,t,n){n.REJECTED=["REJECTED"],n.FULFILLED=["FULFILLED"],n.PENDING=["PENDING"]},{}],40:[function(e,t){"use strict";function n(e,t){var n={};try{n.value=e(t),n.status="success"}catch(r){n.status="error",n.value=r}return n}t.exports=n},{}],41:[function(e,t){"use strict";function n(e,t,n){r(function(){var r;try{r=t(n)}catch(i){return o.reject(e,i)}r===e?o.reject(e,new TypeError("Cannot resolve promise with itself")):o.resolve(e,r)})}var r=e("immediate"),o=e("./handlers");t.exports=n},{"./handlers":32,immediate:42}],42:[function(e,t){"use strict";function n(){o=!0;for(var e,t,n=a.length;n;){for(t=a,a=[],e=-1;++e<n;)t[e]();n=a.length}o=!1}function r(e){1!==a.push(e)||o||i()}for(var o,i,s=[e("./nextTick"),e("./mutation.js"),e("./messageChannel"),e("./stateChange"),e("./timeout")],a=[],u=-1,c=s.length;++u<c;)if(s[u]&&s[u].test&&s[u].test()){i=s[u].install(n);break}t.exports=r},{"./messageChannel":43,"./mutation.js":44,"./nextTick":26,"./stateChange":45,"./timeout":46}],43:[function(e,t,n){(function(e){"use strict";n.test=function(){return e.setImmediate?!1:"undefined"!=typeof e.MessageChannel},n.install=function(t){var n=new e.MessageChannel;return n.port1.onmessage=t,function(){n.port2.postMessage(0)}}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],44:[function(e,t,n){(function(e){"use strict";var t=e.MutationObserver||e.WebKitMutationObserver;n.test=function(){return t},n.install=function(n){var r=0,o=new t(n),i=e.document.createTextNode("");return o.observe(i,{characterData:!0}),function(){i.data=r=++r%2}}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],45:[function(e,t,n){(function(e){"use strict";n.test=function(){return"document"in e&&"onreadystatechange"in e.document.createElement("script")},n.install=function(t){return function(){var n=e.document.createElement("script");return n.onreadystatechange=function(){t(),n.onreadystatechange=null,n.parentNode.removeChild(n),n=null},e.document.documentElement.appendChild(n),t}}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],46:[function(e,t,n){"use strict";n.test=function(){return!0},n.install=function(e){return function(){setTimeout(e,0)}}},{}],47:[function(e,t){"use strict";function n(e){return null===e?String(e):"object"==typeof e||"function"==typeof e?u[f.call(e)]||"object":typeof e}function r(e){return null!==e&&e===e.window}function o(e){if(!e||"object"!==n(e)||e.nodeType||r(e))return!1;try{if(e.constructor&&!p.call(e,"constructor")&&!p.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(t){return!1}var o;for(o in e);return void 0===o||p.call(e,o)}function i(e){return"function"===n(e)}function s(){for(var e=[],t=-1,n=arguments.length,r=new Array(n);++t<n;)r[t]=arguments[t];var o={};e.push({args:r,result:{container:o,key:"key"}});for(var i;i=e.pop();)a(e,i.args,i.result);return o.key}function a(e,t,n){var r,s,a,u,c,l,d,f=t[0]||{},p=1,v=t.length,m=!1,_=/\d+/;for("boolean"==typeof f&&(m=f,f=t[1]||{},p=2),"object"==typeof f||i(f)||(f={}),v===p&&(f=this,--p);v>p;p++)if(null!=(r=t[p])){d=h(r);for(s in r)if(!(s in Object.prototype)){if(d&&!_.test(s))continue;if(a=f[s],u=r[s],f===u)continue;m&&u&&(o(u)||(c=h(u)))?(c?(c=!1,l=a&&h(a)?a:[]):l=a&&o(a)?a:{},e.push({args:[m,l,u],result:{container:f,key:s}})):void 0!==u&&(h(r)&&i(u)||(f[s]=u))}}n.container[n.key]=f}for(var u={},c=["Boolean","Number","String","Function","Array","Date","RegExp","Object","Error"],l=0;l<c.length;l++){var d=c[l];u["[object "+d+"]"]=d.toLowerCase()}var f=u.toString,p=u.hasOwnProperty,h=Array.isArray||function(e){return"array"===n(e)};t.exports=s},{}],48:[function(e,t){"use strict";var n=e("./upsert"),r=e("./utils"),o=r.Promise;t.exports=function(e){var t=e.db,i=e.viewName,s=e.map,a=e.reduce,u=e.temporary,c=s.toString()+(a&&a.toString())+"undefined";if(!u&&t._cachedViews){var l=t._cachedViews[c];if(l)return o.resolve(l)}return t.info().then(function(e){function o(e){e.views=e.views||{};var t=i;-1===t.indexOf("/")&&(t=i+"/"+i);var n=e.views[t]=e.views[t]||{};if(!n[l])return n[l]=!0,e}var l=e.db_name+"-mrview-"+(u?"temp":r.MD5(c));return n(t,"_local/mrviews",o).then(function(){return t.registerDependentDatabase(l).then(function(e){var n=e.db;n.auto_compaction=!0;var r={name:l,db:n,sourceDB:t,adapter:t.adapter,mapFun:s,reduceFun:a};return r.db.get("_local/lastSeq")["catch"](function(e){if(404!==e.status)throw e}).then(function(e){return r.seq=e?e.seq:0,u||(t._cachedViews=t._cachedViews||{},t._cachedViews[c]=r,r.db.on("destroyed",function(){delete t._cachedViews[c]})),r})})})})}},{"./upsert":54,"./utils":55}],49:[function(_dereq_,module,exports){"use strict";module.exports=function(func,emit,sum,log,isArray,toJSON){return eval("'use strict'; ("+func.replace(/;\s*$/,"")+");")}},{}],50:[function(e,t,n){(function(t){"use strict";function r(e){return-1===e.indexOf("/")?[e,e]:e.split("/")}function o(e,t,n){try{return{output:t.apply(null,n)}}catch(r){return e.emit("error",r),{error:r}}}function i(e,t){var n=S(e.key,t.key);return 0!==n?n:S(e.value,t.value)}function s(e,t,n){return n=n||0,"number"==typeof t?e.slice(n,t+n):n>0?e.slice(n):e}function a(e){var t=new Error("builtin "+e+" function requires map values to be numbers or number arrays");return t.name="invalid_value",t.status=500,t}function u(e){for(var t=0,n=0,r=e.length;r>n;n++){var o=e[n];if("number"!=typeof o){if(!Array.isArray(o))throw a("_sum");t="number"==typeof t?[t]:t;for(var i=0,s=o.length;s>i;i++){var u=o[i];if("number"!=typeof u)throw a("_sum");"undefined"==typeof t[i]?t.push(u):t[i]+=u}}else"number"==typeof t?t+=o:t[0]+=o}return t}function c(e,t,n,r){var o=t[e];"undefined"!=typeof o&&(r&&(o=encodeURIComponent(JSON.stringify(o))),n.push(e+"="+o))}function l(e,t){var n=e.descending?"endkey":"startkey",r=e.descending?"startkey":"endkey";if("undefined"!=typeof e[n]&&"undefined"!=typeof e[r]&&S(e[n],e[r])>0)throw new y("No rows can match your key range, reverse your start_key and end_key or set {descending : true}");if(t.reduce&&e.reduce!==!1){if(e.include_docs)throw new y("{include_docs:true} is invalid for reduce");if(e.keys&&e.keys.length>1&&!e.group&&!e.group_level)throw new y("Multi-key fetches for reduce views must use {group: true}")}if(e.group_level){if("number"!=typeof e.group_level)throw new y('Invalid value for integer: "'+e.group_level+'"');if(e.group_level<0)throw new y('Invalid value for positive integer: "'+e.group_level+'"')}}function d(e,t,n){var o,i=[],s="GET";if(c("reduce",n,i),c("include_docs",n,i),c("limit",n,i),c("descending",n,i),c("group",n,i),c("group_level",n,i),c("skip",n,i),c("stale",n,i),c("startkey",n,i,!0),c("endkey",n,i,!0),c("inclusive_end",n,i),c("key",n,i,!0),i=i.join("&"),i=""===i?"":"?"+i,"undefined"!=typeof n.keys){var a=2e3,u="keys="+encodeURIComponent(JSON.stringify(n.keys));u.length+i.length+1<=a?i+=("?"===i[0]?"&":"?")+u:(s="POST","string"==typeof t?o=JSON.stringify({keys:n.keys}):t.keys=n.keys)}if("string"==typeof t){var l=r(t);return e.request({method:s,url:"_design/"+l[0]+"/_view/"+l[1]+i,body:o})}return o=o||{},Object.keys(t).forEach(function(e){o[e]=Array.isArray(t[e])?t[e]:t[e].toString()}),e.request({method:"POST",url:"_temp_view"+i,body:o})}function f(e){return function(t){if(404===t.status)return e;throw t}}function p(e,t,n){var r="_local/doc_"+e;return t.db.get(r)["catch"](f({_id:r,keys:[]})).then(function(r){return O.resolve().then(function(){return r.keys.length?t.db.allDocs({keys:r.keys,include_docs:!0}):{rows:[]}}).then(function(t){var o=t.rows.map(function(e){return e.doc}).filter(function(e){return e}),i=n[e],s={};o.forEach(function(e){if(s[e._id]=!0,e._deleted=!i[e._id],!e._deleted){var t=i[e._id];"value"in t&&(e.value=t.value)}});var a=Object.keys(i);return a.forEach(function(e){if(!s[e]){var t={_id:e},n=i[e];"value"in n&&(t.value=n.value),o.push(t)}}),r.keys=A.uniq(a.concat(r.keys)),o.splice(0,0,r),o})})}function h(e,t,n){var r="_local/lastSeq";return e.db.get(r)["catch"](f({_id:r,seq:0})).then(function(r){var o=Object.keys(t);return O.all(o.map(function(n){return p(n,e,t)})).then(function(t){var o=[];return t.forEach(function(e){o=o.concat(e)}),r.seq=n,o.push(r),e.db.bulkDocs({docs:o})})})}function v(e,t,n){0===n.group_level&&delete n.group_level;var r,i=n.group||n.group_level;r=D[e.reduceFun]?D[e.reduceFun]:T(e.reduceFun.toString(),null,u,b,Array.isArray,JSON.parse);var a=[],c=n.group_level;t.forEach(function(e){var t=a[a.length-1],n=i?e.key:null;return i&&Array.isArray(n)&&"number"==typeof c&&(n=n.length>c?n.slice(0,c):n),t&&0===S(t.key[0][0],n)?(t.key.push([n,e.id]),void t.value.push(e.value)):void a.push({key:[[n,e.id]],value:[e.value]})});for(var l=0,d=a.length;d>l;l++){var f=a[l],p=o(e.sourceDB,r,[f.key,f.value,!1]);f.value=p.error?null:p.output,f.key=f.key[0][0]}return{rows:s(a,n.limit,n.skip)}}function m(e){return e.request({method:"POST",url:"_view_cleanup"})}function _(e,n,o){if("http"===e.type())return d(e,n,o);if("string"!=typeof n){l(o,n);var i={db:e,viewName:"temp_view/temp_view",map:n.map,reduce:n.reduce,temporary:!0};return R.add(function(){return q(i).then(function(e){function t(){return e.db.destroy()}return A.fin(C(e).then(function(){return N(e,o)}),t)})}),R.finish()}var s=n,a=r(s),u=a[0],c=a[1];return e.get("_design/"+u).then(function(n){var r=n.views&&n.views[c];if(!r||"string"!=typeof r.map)throw new g("ddoc "+u+" has no view named "+c);l(o,r);var i={db:e,viewName:s,map:r.map,reduce:r.reduce};return q(i).then(function(e){return"ok"===o.stale||"update_after"===o.stale?("update_after"===o.stale&&t.nextTick(function(){C(e)}),N(e,o)):C(e).then(function(){return N(e,o)})})})}function y(e){this.status=400,this.name="query_parse_error",this.message=e,this.error=!0;try{Error.captureStackTrace(this,y)}catch(t){}}function g(e){this.status=404,this.name="not_found",this.message=e,this.error=!0;try{Error.captureStackTrace(this,g)}catch(t){}}var b,w=e("pouchdb-collate"),E=e("./taskqueue"),S=w.collate,k=w.toIndexableString,x=w.normalizeKey,q=e("./create-view"),T=e("./evalfunc");b="undefined"!=typeof console&&"function"==typeof console.log?Function.prototype.bind.call(console.log,console):function(){};var A=e("./utils"),O=A.Promise,L=new E,R=new E,I=50,D={_sum:function(e,t){return u(t)},_count:function(e,t){return t.length},_stats:function(e,t){function n(e){for(var t=0,n=0,r=e.length;r>n;n++){var o=e[n];t+=o*o}return t}return{sum:u(t),min:Math.min.apply(null,t),max:Math.max.apply(null,t),count:t.length,sumsqr:n(t)}}},C=A.sequentialize(L,function(e){function t(e,t){var n={id:s._id,key:x(e)};"undefined"!=typeof t&&null!==t&&(n.value=x(t)),r.push(n)}function n(t,n){return function(){return h(e,t,n)}}var r,s,a;if("function"==typeof e.mapFun&&2===e.mapFun.length){var c=e.mapFun;a=function(e){return c(e,t)}}else a=T(e.mapFun.toString(),t,u,b,Array.isArray,JSON.parse);var l=e.seq||0,d=new E;return new O(function(t,u){function c(){d.finish().then(function(){e.seq=l,t()})}function f(){function t(e){u(e)}e.sourceDB.changes({conflicts:!0,include_docs:!0,since:l,limit:I}).on("complete",function(t){var u=t.results;if(!u.length)return c();for(var p={},h=0,v=u.length;v>h;h++){var m=u[h];if("_"!==m.doc._id[0]){r=[],s=m.doc,s._deleted||o(e.sourceDB,a,[s]),r.sort(i);for(var _,y={},g=0,b=r.length;b>g;g++){var w=r[g],E=[w.key,w.id];w.key===_&&E.push(g);var S=k(E);y[S]=w,_=w.key}p[m.doc._id]=y}l=m.seq}return d.add(n(p,l)),u.length<I?c():f()}).on("error",t)}f()})}),N=A.sequentialize(L,function(e,t){function n(t){return t.include_docs=!0,e.db.allDocs(t).then(function(e){return o=e.total_rows,e.rows.map(function(e){if("value"in e.doc&&"object"==typeof e.doc.value&&null!==e.doc.value){var t=Object.keys(e.doc.value).sort(),n=["id","key","value"];if(!(n>t||t>n))return e.doc.value}var r=w.parseIndexableString(e.doc._id);return{key:r[0],id:r[1],value:"value"in e.doc?e.doc.value:null}})})}function r(n){var r;if(r=i?v(e,n,t):{total_rows:o,offset:s,rows:n},t.include_docs){var a=n.map(function(t){var n=t.value,r=n&&"object"==typeof n&&n._id||t.id;return e.sourceDB.get(r).then(function(e){t.doc=e},function(){})});return O.all(a).then(function(){return r})}return r}var o,i=e.reduceFun&&t.reduce!==!1,s=t.skip||0;"undefined"==typeof t.keys||t.keys.length||(t.limit=0,delete t.keys);var a=function(e){return e.reduce(function(e,t){return e.concat(t)})};if("undefined"!=typeof t.keys){var u=t.keys,c=u.map(function(e){var t={startkey:k([e]),endkey:k([e,{}])};return n(t)});return O.all(c).then(a).then(r)}var l={descending:t.descending};if("undefined"!=typeof t.startkey&&(l.startkey=k(t.descending?[t.startkey,{}]:[t.startkey])),"undefined"!=typeof t.endkey){var d=t.inclusive_end!==!1;t.descending&&(d=!d),l.endkey=k(d?[t.endkey,{}]:[t.endkey])}if("undefined"!=typeof t.key){var f=k([t.key]),p=k([t.key,{}]);l.descending?(l.endkey=f,l.startkey=p):(l.startkey=f,l.endkey=p)}return i||("number"==typeof t.limit&&(l.limit=t.limit),l.skip=s),n(l).then(r)}),j=A.sequentialize(L,function(e){return e.get("_local/mrviews").then(function(t){var n={};Object.keys(t.views).forEach(function(e){var t=r(e),o="_design/"+t[0],i=t[1];n[o]=n[o]||{},n[o][i]=!0});var o={keys:Object.keys(n),include_docs:!0};return e.allDocs(o).then(function(r){var o={};r.rows.forEach(function(e){var r=e.key.substring(8);Object.keys(n[e.key]).forEach(function(n){var i=r+"/"+n;t.views[i]||(i=n);var s=Object.keys(t.views[i]),a=e.doc&&e.doc.views&&e.doc.views[n];s.forEach(function(e){o[e]=o[e]||a})})});var i=Object.keys(o).filter(function(e){return!o[e]}),s=i.map(function(t){return e.constructor.destroy(t,{adapter:e.adapter})});return O.all(s).then(function(){return{ok:!0}})})},f({ok:!0}))});n.viewCleanup=A.callbackify(function(){var e=this;return"http"===e.type()?m(e):j(e)}),n.query=function(e,t,n){"function"==typeof t&&(n=t,t={}),t=A.extend(!0,{},t),"function"==typeof e&&(e={map:e});var r=this,o=O.resolve().then(function(){return _(r,e,t)});return A.promisedCallback(o,n),o},A.inherits(y,Error),A.inherits(g,Error)}).call(this,e("/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))},{"./create-view":48,"./evalfunc":49,"./taskqueue":53,"./utils":55,"/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":28,"pouchdb-collate":51}],51:[function(e,t,n){"use strict";function r(e){if(null!==e)switch(typeof e){case"boolean":return e?1:0;case"number":return l(e);case"string":return e.replace(/\u0002/g,"").replace(/\u0001/g,"").replace(/\u0000/g,"");case"object":var t=Array.isArray(e),r=t?e:Object.keys(e),o=-1,i=r.length,s="";if(t)for(;++o<i;)s+=n.toIndexableString(r[o]);else for(;++o<i;){var a=r[o];s+=n.toIndexableString(a)+n.toIndexableString(e[a])}return s}return""}function o(e,t){var n,r=t,o="1"===e[t];if(o)n=0,t++;else{var i="0"===e[t];t++;var s="",a=e.substring(t,t+f),u=parseInt(a,10)+d;for(i&&(u=-u),t+=f;;){var c=e[t];if("\x00"===c)break;s+=c,t++}s=s.split("."),n=1===s.length?parseInt(s,10):parseFloat(s[0]+"."+s[1]),i&&(n-=10),0!==u&&(n=parseFloat(n+"e"+u))}return{num:n,length:t-r}}function i(e,t){var n=e.pop();if(t.length){var r=t[t.length-1];n===r.element&&(t.pop(),r=t[t.length-1]);var o=r.element,i=r.index;if(Array.isArray(o))o.push(n);else if(i===e.length-2){var s=e.pop();o[s]=n}else e.push(n)}}function s(e,t){for(var r=Math.min(e.length,t.length),o=0;r>o;o++){var i=n.collate(e[o],t[o]);if(0!==i)return i}return e.length===t.length?0:e.length>t.length?1:-1}function a(e,t){return e===t?0:e>t?1:-1}function u(e,t){for(var r=Object.keys(e),o=Object.keys(t),i=Math.min(r.length,o.length),s=0;i>s;s++){var a=n.collate(r[s],o[s]);if(0!==a)return a;if(a=n.collate(e[r[s]],t[o[s]]),0!==a)return a}return r.length===o.length?0:r.length>o.length?1:-1}function c(e){var t=["boolean","number","string","object"],n=t.indexOf(typeof e);return~n?null===e?1:Array.isArray(e)?5:3>n?n+2:n+3:Array.isArray(e)?5:void 0}function l(e){if(0===e)return"1";var t=e.toExponential().split(/e\+?/),n=parseInt(t[1],10),r=0>e,o=r?"0":"2",i=(r?-n:n)-d,s=h.padLeft(i.toString(),"0",f);o+=p+s;var a=Math.abs(parseFloat(t[0]));r&&(a=10-a);var u=a.toFixed(20);return u=u.replace(/\.?0+$/,""),o+=p+u}var d=-324,f=3,p="",h=e("./utils");n.collate=function(e,t){if(e===t)return 0;e=n.normalizeKey(e),t=n.normalizeKey(t);var r=c(e),o=c(t);if(r-o!==0)return r-o;if(null===e)return 0;switch(typeof e){case"number":return e-t;case"boolean":return e===t?0:t>e?-1:1;case"string":return a(e,t)}return Array.isArray(e)?s(e,t):u(e,t)},n.normalizeKey=function(e){switch(typeof e){case"undefined":return null;case"number":return 1/0===e||e===-1/0||isNaN(e)?null:e;case"object":var t=e;if(Array.isArray(e)){var r=e.length;e=new Array(r);for(var o=0;r>o;o++)e[o]=n.normalizeKey(t[o])}else{if(e instanceof Date)return e.toJSON();if(null!==e){e={};for(var i in t)if(t.hasOwnProperty(i)){var s=t[i];"undefined"!=typeof s&&(e[i]=n.normalizeKey(s))}}}}return e},n.toIndexableString=function(e){var t="\x00";return e=n.normalizeKey(e),c(e)+p+r(e)+t},n.parseIndexableString=function(e){for(var t=[],n=[],r=0;;){var s=e[r++];if("\x00"!==s)switch(s){case"1":t.push(null);break;case"2":t.push("1"===e[r]),r++;break;case"3":var a=o(e,r);t.push(a.num),r+=a.length;break;case"4":for(var u="";;){var c=e[r];if("\x00"===c)break;u+=c,r++}u=u.replace(/\u0001\u0001/g,"\x00").replace(/\u0001\u0002/g,"").replace(/\u0002\u0002/g,""),t.push(u);break;case"5":var l={element:[],index:t.length};t.push(l.element),n.push(l);break;case"6":var d={element:{},index:t.length};t.push(d.element),n.push(d);break;default:throw new Error("bad collationIndex or unexpectedly reached end of input: "+s)}else{if(1===t.length)return t.pop();i(t,n)}}}},{"./utils":52}],52:[function(e,t,n){"use strict";function r(e,t,n){for(var r="",o=n-e.length;r.length<o;)r+=t;return r}n.padLeft=function(e,t,n){var o=r(e,t,n);return o+e},n.padRight=function(e,t,n){var o=r(e,t,n);return e+o},n.stringLexCompare=function(e,t){var n,r=e.length,o=t.length;for(n=0;r>n;n++){if(n===o)return 1;var i=e.charAt(n),s=t.charAt(n);if(i!==s)return s>i?-1:1}return o>r?-1:0},n.intToDecimalForm=function(e){var t=0>e,n="";do{var r=t?-Math.ceil(e%10):Math.floor(e%10);n=r+n,e=t?Math.ceil(e/10):Math.floor(e/10)}while(e);return t&&"0"!==n&&(n="-"+n),n}},{}],53:[function(e,t){"use strict";function n(){this.promise=new r(function(e){e()})}var r=e("./utils").Promise;n.prototype.add=function(e){return this.promise=this.promise["catch"](function(){}).then(function(){return e()}),this.promise},n.prototype.finish=function(){return this.promise},t.exports=n},{"./utils":55}],54:[function(e,t){"use strict";function n(e,t,n){return new o(function(o,i){return t&&"object"==typeof t&&(t=t._id),"string"!=typeof t?i(new Error("doc id is required")):void e.get(t,function(s,a){if(s)return 404!==s.status?i(s):o(r(e,n({_id:t}),n));var u=n(a);return u?void o(r(e,u,n)):o(a)})})}function r(e,t,r){return e.put(t)["catch"](function(o){if(409!==o.status)throw o;return n(e,t,r)})}var o=e("./utils").Promise;t.exports=n},{"./utils":55}],55:[function(e,t,n){(function(t,r){"use strict";n.Promise="function"==typeof r.Promise?r.Promise:e("lie"),n.uniq=function(e){var t={};return e.forEach(function(e){t[e]=!0}),Object.keys(t)},n.inherits=e("inherits"),n.extend=e("pouchdb-extend");var o=e("argsarray");n.promisedCallback=function(e,n){return n&&e.then(function(e){t.nextTick(function(){n(null,e)})},function(e){t.nextTick(function(){n(e)})}),e},n.callbackify=function(e){return o(function(t){var r=t.pop(),o=e.apply(this,t);return"function"==typeof r&&n.promisedCallback(o,r),o})},n.fin=function(e,t){return e.then(function(e){var n=t();return"function"==typeof n.then?n.then(function(){return e}):e},function(e){var n=t();if("function"==typeof n.then)return n.then(function(){throw e});throw e})},n.sequentialize=function(e,t){return function(){var n=arguments,r=this;return e.add(function(){return t.apply(r,n)})}};var i=e("crypto"),s=e("spark-md5");n.MD5=function(e){return t.browser?s.hash(e):i.createHash("md5").update(e).digest("hex")}}).call(this,e("/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":28,argsarray:25,crypto:26,inherits:29,lie:33,"pouchdb-extend":47,"spark-md5":56}],56:[function(e,t,n){!function(e){if("object"==typeof n)t.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var r;try{r=window}catch(o){r=self}r.SparkMD5=e()}}(function(){"use strict";var e=function(e,t){return e+t&4294967295},t=function(t,n,r,o,i,s){return n=e(e(n,t),e(o,s)),e(n<<i|n>>>32-i,r)},n=function(e,n,r,o,i,s,a){return t(n&r|~n&o,e,n,i,s,a)},r=function(e,n,r,o,i,s,a){return t(n&o|r&~o,e,n,i,s,a)},o=function(e,n,r,o,i,s,a){return t(n^r^o,e,n,i,s,a)},i=function(e,n,r,o,i,s,a){return t(r^(n|~o),e,n,i,s,a)},s=function(t,s){var a=t[0],u=t[1],c=t[2],l=t[3];a=n(a,u,c,l,s[0],7,-680876936),l=n(l,a,u,c,s[1],12,-389564586),c=n(c,l,a,u,s[2],17,606105819),u=n(u,c,l,a,s[3],22,-1044525330),a=n(a,u,c,l,s[4],7,-176418897),l=n(l,a,u,c,s[5],12,1200080426),c=n(c,l,a,u,s[6],17,-1473231341),u=n(u,c,l,a,s[7],22,-45705983),a=n(a,u,c,l,s[8],7,1770035416),l=n(l,a,u,c,s[9],12,-1958414417),c=n(c,l,a,u,s[10],17,-42063),u=n(u,c,l,a,s[11],22,-1990404162),a=n(a,u,c,l,s[12],7,1804603682),l=n(l,a,u,c,s[13],12,-40341101),c=n(c,l,a,u,s[14],17,-1502002290),u=n(u,c,l,a,s[15],22,1236535329),a=r(a,u,c,l,s[1],5,-165796510),l=r(l,a,u,c,s[6],9,-1069501632),c=r(c,l,a,u,s[11],14,643717713),u=r(u,c,l,a,s[0],20,-373897302),a=r(a,u,c,l,s[5],5,-701558691),l=r(l,a,u,c,s[10],9,38016083),c=r(c,l,a,u,s[15],14,-660478335),u=r(u,c,l,a,s[4],20,-405537848),a=r(a,u,c,l,s[9],5,568446438),l=r(l,a,u,c,s[14],9,-1019803690),c=r(c,l,a,u,s[3],14,-187363961),u=r(u,c,l,a,s[8],20,1163531501),a=r(a,u,c,l,s[13],5,-1444681467),l=r(l,a,u,c,s[2],9,-51403784),c=r(c,l,a,u,s[7],14,1735328473),u=r(u,c,l,a,s[12],20,-1926607734),a=o(a,u,c,l,s[5],4,-378558),l=o(l,a,u,c,s[8],11,-2022574463),c=o(c,l,a,u,s[11],16,1839030562),u=o(u,c,l,a,s[14],23,-35309556),a=o(a,u,c,l,s[1],4,-1530992060),l=o(l,a,u,c,s[4],11,1272893353),c=o(c,l,a,u,s[7],16,-155497632),u=o(u,c,l,a,s[10],23,-1094730640),a=o(a,u,c,l,s[13],4,681279174),l=o(l,a,u,c,s[0],11,-358537222),c=o(c,l,a,u,s[3],16,-722521979),u=o(u,c,l,a,s[6],23,76029189),a=o(a,u,c,l,s[9],4,-640364487),l=o(l,a,u,c,s[12],11,-421815835),c=o(c,l,a,u,s[15],16,530742520),u=o(u,c,l,a,s[2],23,-995338651),a=i(a,u,c,l,s[0],6,-198630844),l=i(l,a,u,c,s[7],10,1126891415),c=i(c,l,a,u,s[14],15,-1416354905),u=i(u,c,l,a,s[5],21,-57434055),a=i(a,u,c,l,s[12],6,1700485571),l=i(l,a,u,c,s[3],10,-1894986606),c=i(c,l,a,u,s[10],15,-1051523),u=i(u,c,l,a,s[1],21,-2054922799),a=i(a,u,c,l,s[8],6,1873313359),l=i(l,a,u,c,s[15],10,-30611744),c=i(c,l,a,u,s[6],15,-1560198380),u=i(u,c,l,a,s[13],21,1309151649),a=i(a,u,c,l,s[4],6,-145523070),l=i(l,a,u,c,s[11],10,-1120210379),c=i(c,l,a,u,s[2],15,718787259),u=i(u,c,l,a,s[9],21,-343485551),t[0]=e(a,t[0]),t[1]=e(u,t[1]),t[2]=e(c,t[2]),t[3]=e(l,t[3])},a=function(e){var t,n=[];for(t=0;64>t;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n},u=function(e){var t,n=[];for(t=0;64>t;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n},c=function(e){var t,n,r,o,i,u,c=e.length,l=[1732584193,-271733879,-1732584194,271733878];for(t=64;c>=t;t+=64)s(l,a(e.substring(t-64,t)));for(e=e.substring(t-64),n=e.length,r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;n>t;t+=1)r[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(r[t>>2]|=128<<(t%4<<3),t>55)for(s(l,r),t=0;16>t;t+=1)r[t]=0;return o=8*c,o=o.toString(16).match(/(.*?)(.{0,8})$/),i=parseInt(o[2],16),u=parseInt(o[1],16)||0,r[14]=i,r[15]=u,s(l,r),l},l=function(e){var t,n,r,o,i,a,c=e.length,l=[1732584193,-271733879,-1732584194,271733878];for(t=64;c>=t;t+=64)s(l,u(e.subarray(t-64,t)));for(e=c>t-64?e.subarray(t-64):new Uint8Array(0),n=e.length,r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;n>t;t+=1)r[t>>2]|=e[t]<<(t%4<<3);if(r[t>>2]|=128<<(t%4<<3),t>55)for(s(l,r),t=0;16>t;t+=1)r[t]=0;return o=8*c,o=o.toString(16).match(/(.*?)(.{0,8})$/),i=parseInt(o[2],16),a=parseInt(o[1],16)||0,r[14]=i,r[15]=a,s(l,r),l},d=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"],f=function(e){var t,n="";for(t=0;4>t;t+=1)n+=d[e>>8*t+4&15]+d[e>>8*t&15];return n},p=function(e){var t;for(t=0;t<e.length;t+=1)e[t]=f(e[t]);return e.join("")},h=function(e){return p(c(e))},v=function(){this.reset()};return"5d41402abc4b2a76b9719d911017c592"!==h("hello")&&(e=function(e,t){var n=(65535&e)+(65535&t),r=(e>>16)+(t>>16)+(n>>16);return r<<16|65535&n}),v.prototype.append=function(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),this.appendBinary(e),this},v.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var t,n=this._buff.length;for(t=64;n>=t;t+=64)s(this._state,a(this._buff.substring(t-64,t)));return this._buff=this._buff.substr(t-64),this},v.prototype.end=function(e){var t,n,r=this._buff,o=r.length,i=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;o>t;t+=1)i[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(i,o),n=e?this._state:p(this._state),this.reset(),n},v.prototype._finish=function(e,t){var n,r,o,i=t;if(e[i>>2]|=128<<(i%4<<3),i>55)for(s(this._state,e),i=0;16>i;i+=1)e[i]=0;n=8*this._length,n=n.toString(16).match(/(.*?)(.{0,8})$/),r=parseInt(n[2],16),o=parseInt(n[1],16)||0,e[14]=r,e[15]=o,s(this._state,e)},v.prototype.reset=function(){return this._buff="",this._length=0,this._state=[1732584193,-271733879,-1732584194,271733878],this},v.prototype.destroy=function(){delete this._state,delete this._buff,delete this._length},v.hash=function(e,t){/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e)));var n=c(e);return t?n:p(n)},v.hashBinary=function(e,t){var n=c(e);return t?n:p(n)},v.ArrayBuffer=function(){this.reset()},v.ArrayBuffer.prototype.append=function(e){var t,n=this._concatArrayBuffer(this._buff,e),r=n.length;for(this._length+=e.byteLength,t=64;r>=t;t+=64)s(this._state,u(n.subarray(t-64,t)));return this._buff=r>t-64?n.subarray(t-64):new Uint8Array(0),this},v.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,i=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;o>t;t+=1)i[t>>2]|=r[t]<<(t%4<<3);return this._finish(i,o),n=e?this._state:p(this._state),this.reset(),n},v.ArrayBuffer.prototype._finish=v.prototype._finish,v.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._state=[1732584193,-271733879,-1732584194,271733878],this},v.ArrayBuffer.prototype.destroy=v.prototype.destroy,v.ArrayBuffer.prototype._concatArrayBuffer=function(e,t){var n=e.length,r=new Uint8Array(n+t.byteLength);return r.set(e),r.set(new Uint8Array(t),n),r},v.ArrayBuffer.hash=function(e,t){var n=l(new Uint8Array(e));return t?n:p(n)},v})},{}],57:[function(e,t,n){"use strict";function r(e,t,n){var r=n[n.length-1];e===r.element&&(n.pop(),r=n[n.length-1]);var o=r.element,i=r.index;if(Array.isArray(o))o.push(e);else if(i===t.length-2){var s=t.pop();o[s]=e}else t.push(e)}n.stringify=function(e){var t=[];t.push({obj:e});for(var n,r,o,i,s,a,u,c,l,d,f,p="";n=t.pop();)if(r=n.obj,o=n.prefix||"",i=n.val||"",p+=o,i)p+=i;else if("object"!=typeof r)p+="undefined"==typeof r?null:JSON.stringify(r);else if(null===r)p+="null";else if(Array.isArray(r)){for(t.push({val:"]"}),s=r.length-1;s>=0;s--)a=0===s?"":",",t.push({obj:r[s],prefix:a});t.push({val:"["})}else{u=[];for(c in r)r.hasOwnProperty(c)&&u.push(c);for(t.push({val:"}"}),s=u.length-1;s>=0;s--)l=u[s],d=r[l],f=s>0?",":"",f+=JSON.stringify(l)+":",t.push({obj:d,prefix:f});t.push({val:"{"})}return p},n.parse=function(e){for(var t,n,o,i,s,a,u,c,l,d=[],f=[],p=0;;)if(t=e[p++],"}"!==t&&"]"!==t&&"undefined"!=typeof t)switch(t){case" ":case"	":case"\n":case":":case",":break;case"n":p+=3,r(null,d,f);break;case"t":p+=3,r(!0,d,f);break;case"f":p+=4,r(!1,d,f);break;case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case"-":for(n="",p--;;){if(o=e[p++],!/[\d\.\-e\+]/.test(o)){p--;break}n+=o}r(parseFloat(n),d,f);break;case'"':for(i="",s=void 0,a=0;;){if(u=e[p++],'"'===u&&("\\"!==s||a%2!==1))break;i+=u,s=u,"\\"===s?a++:a=0}r(JSON.parse('"'+i+'"'),d,f);break;case"[":c={element:[],index:d.length},d.push(c.element),f.push(c);break;case"{":l={element:{},index:d.length},d.push(l.element),f.push(l);break;default:throw new Error("unexpectedly reached end of input: "+t)}else{if(1===d.length)return d.pop();r(d.pop(),d,f)}}},{}]},{},[17])(17)});;
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    module.exports = mod();
  else if (typeof define == "function" && define.amd) // AMD
    return define([], mod);
  else // Plain browser env
    this.CodeMirror = mod();
})(function() {
  "use strict";

  // BROWSER SNIFFING

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.

  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  // ie_uptoN means Internet Explorer version N or lower
  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var ie = ie_upto10 || ie_11up;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var presto = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var khtml = /KHTML\//.test(navigator.userAgent);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);

  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /win/i.test(navigator.platform);

  var presto_version = presto && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) presto_version = Number(presto_version[1]);
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  // EDITOR CONSTRUCTOR

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);

    var doc = options.value;
    if (typeof doc == "string") doc = new Doc(doc, options.mode);
    this.doc = doc;

    var display = this.display = new Display(place, doc);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += " CodeMirror-wrap";
    if (options.autofocus && !mobile) focusInput(this);
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false, focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in readInput
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null  // Unfinished key sequence
    };

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) setTimeout(bind(resetInput, this, true), 20);

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || activeElt() == display.input)
      setTimeout(bind(onFocus, this), 20);
    else
      onBlur(this);

    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
      optionHandlers[opt](this, options[opt], Init);
    maybeUpdateLineNumberWidth(this);
    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
    endOperation(this);
  }

  // DISPLAY CONSTRUCTOR

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc) {
    var d = this;

    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) input.style.width = "1000px";
    else input.setAttribute("wrap", "off");
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) input.style.border = "1px solid black";
    input.setAttribute("autocorrect", "off"); input.setAttribute("autocapitalize", "off"); input.setAttribute("spellcheck", "false");

    // Wraps and hides input textarea
    d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = elt("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.inputDiv, d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    // Needed to hide big blue blinking cursor on Mobile Safari
    if (ios) input.style.width = "0px";
    if (!webkit) d.scroller.draggable = true;
    // Needed to handle Tab key in KHTML
    if (khtml) { d.inputDiv.style.height = "1px"; d.inputDiv.style.position = "absolute"; }

    if (place) {
      if (place.appendChild) place.appendChild(d.wrapper);
      else place(d.wrapper);
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // See readInput and resetInput
    d.prevInput = "";
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;
    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    d.pollingFast = false;
    // Self-resetting timeout for the poller
    d.poll = new Delayed();

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks when resetInput has punted to just putting a short
    // string into the textarea instead of the full selection.
    d.inaccurateSelection = false;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;
  }

  // STATE UPDATES

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function(line) {
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) regChange(cm);
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function(){updateScrollbars(cm);}, 100);
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line)) return 0;

      var widgetsHeight = 0;
      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
      }

      if (wrapping)
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return widgetsHeight + th;
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function(){alignHorizontally(cm);}, 20);
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  }

  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find(0, true);
      len -= cur.text.length - found.from.ch;
      cur = found.to.line;
      len += cur.text.length - found.to.ch;
    }
    return len;
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function(line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }

  function NativeScrollbars(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    place(vert); place(horiz);

    on(vert, "scroll", function() {
      if (vert.clientHeight) scroll(vert.scrollTop, "vertical");
    });
    on(horiz, "scroll", function() {
      if (horiz.clientWidth) scroll(horiz.scrollLeft, "horizontal");
    });

    this.checkedOverlay = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
  }

  NativeScrollbars.prototype = copyObj({
    update: function(measure) {
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      var sWidth = measure.nativeBarWidth;

      if (needsV) {
        this.vert.style.display = "block";
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
        // A bug in IE8 can cause this value to be negative, so guard it.
        this.vert.firstChild.style.height =
          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
      } else {
        this.vert.style.display = "";
        this.vert.firstChild.style.height = "0";
      }

      if (needsH) {
        this.horiz.style.display = "block";
        this.horiz.style.right = needsV ? sWidth + "px" : "0";
        this.horiz.style.left = measure.barLeft + "px";
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
        this.horiz.firstChild.style.width =
          (measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
      } else {
        this.horiz.style.display = "";
        this.horiz.firstChild.style.width = "0";
      }

      if (!this.checkedOverlay && measure.clientHeight > 0) {
        if (sWidth == 0) this.overlayHack();
        this.checkedOverlay = true;
      }

      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};
    },
    setScrollLeft: function(pos) {
      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;
    },
    setScrollTop: function(pos) {
      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;
    },
    overlayHack: function() {
      var w = mac && !mac_geMountainLion ? "12px" : "18px";
      this.horiz.style.minHeight = this.vert.style.minWidth = w;
      var self = this;
      var barMouseDown = function(e) {
        if (e_target(e) != self.vert && e_target(e) != self.horiz)
          operation(self.cm, onMouseDown)(e);
      };
      on(this.vert, "mousedown", barMouseDown);
      on(this.horiz, "mousedown", barMouseDown);
    },
    clear: function() {
      var parent = this.horiz.parentNode;
      parent.removeChild(this.horiz);
      parent.removeChild(this.vert);
    }
  }, NativeScrollbars.prototype);

  function NullScrollbars() {}

  NullScrollbars.prototype = copyObj({
    update: function() { return {bottom: 0, right: 0}; },
    setScrollLeft: function() {},
    setScrollTop: function() {},
    clear: function() {}
  }, NullScrollbars.prototype);

  CodeMirror.scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }

    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      on(node, "mousedown", function() {
        if (cm.state.focused) setTimeout(bind(focusInput, cm), 0);
      });
      node.setAttribute("not-content", "true");
    }, function(pos, axis) {
      if (axis == "horizontal") setScrollLeft(cm, pos);
      else setScrollTop(cm, pos);
    }, cm);
    if (cm.display.scrollbars.addClass)
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
  }

  function updateScrollbars(cm, measure) {
    if (!measure) measure = measureForScrollbars(cm);
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        updateHeightsInViewport(cm);
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else d.scrollbarFiller.style.display = "";
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else d.gutterFiller.style.display = "";
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)};
  }

  // LINE NUMBERS

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
      if (cm.options.fixedGutter && view[i].gutter)
        view[i].gutter.style.left = left;
      var align = view[i].alignable;
      if (align) for (var j = 0; j < align.length; j++)
        align[j].style.left = left;
    }
    if (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + "px";
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true;
    }
    return false;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }

  // DISPLAY DRAWING

  function DisplayUpdate(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
  }

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      return false;

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      return false;

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var focused = activeElt();
    if (toUpdate > 4) display.lineDiv.style.display = "none";
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) display.lineDiv.style.display = "";
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.heightForcer.style.top = display.gutters.style.height = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true;
  }

  function postUpdateDisplay(cm, update) {
    var force = update.force, viewport = update.viewport;
    for (var first = true;; first = false) {
      if (first && cm.options.lineWrapping && update.oldDisplayWidth != displayWidth(cm)) {
        force = true;
      } else {
        force = false;
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          break;
      }
      if (!updateDisplayIfNeeded(cm, update)) break;
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      setDocumentHeight(cm, barMeasure);
      updateScrollbars(cm, barMeasure);
    }

    signalLater(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      signalLater(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      setDocumentHeight(cm, barMeasure);
      updateScrollbars(cm, barMeasure);
    }
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    var plusGap = measure.docHeight + scrollGap(cm);
    cm.display.heightForcer.style.top = plusGap + "px";
    cm.display.gutters.style.height = Math.max(plusGap, measure.clientHeight) + "px";
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], height;
      if (cur.hidden) continue;
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      var diff = cur.line.height - height;
      if (height < 2) height = textHeight(display);
      if (diff > .001 || diff < -.001) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
          updateWidgetHeight(cur.rest[j]);
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
      line.widgets[i].height = line.widgets[i].node.offsetHeight;
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[cm.options.gutters[i]] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        node.style.display = "none";
      else
        node.parentNode.removeChild(node);
      return next;
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) {
      } else if (!lineView.node) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) cur = rm(cur);
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) cur = rm(cur);
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") updateLineText(cm, lineView);
      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
      else if (type == "class") updateLineClasses(lineView);
      else if (type == "widget") updateLineWidgets(lineView, dims);
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;
    }
    return lineView.node;
  }

  function updateLineBackground(lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) cls += " CodeMirror-linebackground";
    if (lineView.background) {
      if (cls) lineView.background.className = cls;
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) lineView.node = built.pre;
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(lineView) {
    updateLineBackground(lineView);
    if (lineView.line.wrapClass)
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    else if (lineView.node != lineView.text)
      lineView.node.className = "";
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter =
        wrap.insertBefore(elt("div", null, "CodeMirror-gutter-wrapper", "left: " +
                              (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +
                              "px; width: " + dims.gutterTotalWidth + "px"),
                          lineView.text);
      if (lineView.line.gutterClass)
        gutterWrap.className += " " + lineView.line.gutterClass;
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
              + cm.display.lineNumInnerWidth + "px"));
      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
      }
    }
  }

  function updateLineWidgets(lineView, dims) {
    if (lineView.alignable) lineView.alignable = null;
    for (var node = lineView.node.firstChild, next; node; node = next) {
      var next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        lineView.node.removeChild(node);
    }
    insertLineWidgets(lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) lineView.bgClass = built.bgClass;
    if (built.textClass) lineView.textClass = built.textClass;

    updateLineClasses(lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(lineView, dims);
    return lineView.node;
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(lineView, dims) {
    insertLineWidgetsFor(lineView.line, lineView, dims, true);
    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
      insertLineWidgetsFor(lineView.rest[i], lineView, dims, false);
  }

  function insertLineWidgetsFor(line, lineView, dims, allowAbove) {
    if (!line.widgets) return;
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) node.setAttribute("cm-ignore-events", "true");
      positionLineWidget(widget, node, lineView, dims);
      if (allowAbove && widget.above)
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      else
        wrap.appendChild(node);
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
    }
  }

  // POSITION OBJECT

  // A Pos instance represents a position within the text.
  var Pos = CodeMirror.Pos = function(line, ch) {
    if (!(this instanceof Pos)) return new Pos(line, ch);
    this.line = line; this.ch = ch;
  };

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };

  function copyPos(x) {return Pos(x.line, x.ch);}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }

  // SELECTION / CURSOR

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  function Selection(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  }

  Selection.prototype = {
    primary: function() { return this.ranges[this.primIndex]; },
    equals: function(other) {
      if (other == this) return true;
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
      for (var i = 0; i < this.ranges.length; i++) {
        var here = this.ranges[i], there = other.ranges[i];
        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
      }
      return true;
    },
    deepCopy: function() {
      for (var out = [], i = 0; i < this.ranges.length; i++)
        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
      return new Selection(out, this.primIndex);
    },
    somethingSelected: function() {
      for (var i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].empty()) return true;
      return false;
    },
    contains: function(pos, end) {
      if (!end) end = pos;
      for (var i = 0; i < this.ranges.length; i++) {
        var range = this.ranges[i];
        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
          return i;
      }
      return -1;
    }
  };

  function Range(anchor, head) {
    this.anchor = anchor; this.head = head;
  }

  Range.prototype = {
    from: function() { return minPos(this.anchor, this.head); },
    to: function() { return maxPos(this.anchor, this.head); },
    empty: function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    }
  };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) --primIndex;
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
    else if (ch < 0) return Pos(pos.line, 0);
    else return pos;
  }
  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
  function clipPosArray(doc, array) {
    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
    return out;
  }

  // SELECTION UPDATES

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(doc, range, head, other) {
    if (doc.cm && doc.cm.display.shift || doc.extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options) {
    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head));
      }
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    else return sel;
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      sel = filterSelectionChange(doc, sel);

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      ensureCursorVisible(doc.cm);
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) return;

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) out = sel.ranges.slice(0, i);
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search: for (;;) {
      var line = getLine(doc, curPos.line);
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var sp = line.markedSpans[i], m = sp.marker;
          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&
              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
            if (mayClear) {
              signal(m, "beforeCursorEnter");
              if (m.explicitlyCleared) {
                if (!line.markedSpans) break;
                else {--i; continue;}
              }
            }
            if (!m.atomic) continue;
            var newPos = m.find(dir < 0 ? -1 : 1);
            if (cmp(newPos, curPos) == 0) {
              newPos.ch += dir;
              if (newPos.ch < 0) {
                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));
                else newPos = null;
              } else if (newPos.ch > line.text.length) {
                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);
                else newPos = null;
              }
              if (!newPos) {
                if (flipped) {
                  // Driven in a corner -- no valid cursor position found at all
                  // -- try again *with* clearing, if we didn't already
                  if (!mayClear) return skipAtomic(doc, pos, bias, true);
                  // Otherwise, turn off editing until further notice, and return the start of the doc
                  doc.cantEdit = true;
                  return Pos(doc.first, 0);
                }
                flipped = true; newPos = pos; dir = -dir;
              }
            }
            curPos = newPos;
            continue search;
          }
        }
      }
      return curPos;
    }
  }

  // SELECTION DRAWING

  // Redraw the selection and/or cursor
  function drawSelection(cm) {
    var display = cm.display, doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      var collapsed = range.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        drawSelectionCursor(cm, range, curFragment);
      if (!collapsed)
        drawSelectionRange(cm, range, selFragment);
    }

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                          headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                           headPos.left + lineOff.left - wrapOff.left));
    }

    return result;
  }

  function showSelection(cm, drawn) {
    removeChildrenAndAdd(cm.display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(cm.display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      cm.display.inputDiv.style.top = drawn.teTop + "px";
      cm.display.inputDiv.style.left = drawn.teLeft + "px";
    }
  }

  function updateSelection(cm) {
    showSelection(cm, drawSelection(cm));
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, range, output) {
    var pos = cursorCoords(cm, range.head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;

    function add(left, top, width, bottom) {
      if (top < 0) top = 0;
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
                               "px; height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
        var leftPos = coords(from, "left"), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, "right");
          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0) left = leftSide;
        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = leftSide;
          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen) right = rightSide;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < leftSide + 1) left = leftSide;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {start: start, end: end};
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(leftSide, leftEnd.bottom, null, rightStart.top);
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      display.blinker = setInterval(function() {
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    else if (cm.options.cursorBlinkRate < 0)
      display.cursorDiv.style.visibility = "hidden";
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) doc.frontier = doc.first;
    if (doc.frontier >= cm.display.viewTo) return;
    var end = +new Date + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changedLines = [];

    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
      if (doc.frontier >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var highlighted = highlightLine(cm, line, state, true);
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) line.styleClasses = newCls;
        else if (oldCls) line.styleClasses = null;
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        if (ischange) changedLines.push(doc.frontier);
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line.text, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changedLines.length) runInOp(cm, function() {
      for (var i = 0; i < changedLines.length; i++)
        regLineChange(cm, changedLines[i], "text");
    });
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
    if (!state) state = startState(doc.mode);
    else state = copyState(doc.mode, state);
    doc.iter(pos, n, function(line) {
      processLine(cm, line.text, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    if (precise) doc.frontier = pos;
    return state;
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop;}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
  function paddingH(display) {
    if (display.cachedPaddingH) return display.cachedPaddingH;
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
    return data;
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            heights.push((cur.bottom + next.top) / 2 - rect.top);
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      return {map: lineView.measure.map, cache: lineView.measure.cache};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineView.rest[i] == line)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineNo(lineView.rest[i]) > lineN)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      return cm.display.view[findViewIndex(cm, lineN)];
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      return ext;
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text)
      view = null;
    else if (view && view.changes)
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
    if (!view)
      view = updateExternalMeasurement(cm, line);

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    };
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) ch = -1;
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        prepared.rect = prepared.view.text.getBoundingClientRect();
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) prepared.cache[key] = found;
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom};
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function measureCharInner(cm, prepared, ch, bias) {
    var map = prepared.map;

    var node, start, end, collapse;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      var mStart = map[i], mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) collapse = "right";
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          collapse = bias;
        if (bias == "left" && start == 0)
          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          }
        if (bias == "right" && start == mEnd - mStart)
          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          }
        break;
      }
    }

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(mStart + start))) --start;
        while (mStart + end < mEnd && isExtendingChar(prepared.line.text.charAt(mStart + end))) ++end;
        if (ie && ie_version < 9 && start == 0 && end == mEnd - mStart) {
          rect = node.parentNode.getBoundingClientRect();
        } else if (ie && cm.options.lineWrapping) {
          var rects = range(node, start, end).getClientRects();
          if (rects.length)
            rect = rects[bias == "right" ? rects.length - 1 : 0];
          else
            rect = nullRect;
        } else {
          rect = range(node, start, end).getBoundingClientRect() || nullRect;
        }
        if (rect.left || rect.right || start == 0) break;
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) collapse = bias = "right";
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      else
        rect = node.getBoundingClientRect();
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
      else
        rect = nullRect;
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    for (var i = 0; i < heights.length - 1; i++)
      if (mid < heights[i]) break;
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) result.bogus = true;
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result;
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      return rect;
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY};
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
        lineView.measure.caches[i] = {};
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      clearLineMeasurementCacheFor(cm.display.view[i]);
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }

  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"/null (editor), or "page".
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
      var size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    if (context == "line") return rect;
    if (!context) context = "local";
    var yOff = heightAtLine(lineObj);
    if (context == "local") yOff += paddingTop(cm.display);
    else yOff -= cm.display.viewOffset;
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect;
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"/null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) m.left = m.right; else m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from) return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order) return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
    return val;
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0, pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height};
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, outside, xRel) {
    var pos = Pos(line, ch);
    pos.xRel = xRel;
    if (outside) pos.outside = true;
    return pos;
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0) x = 0;

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find(0, true);
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineN = lineNo(lineObj = mergedPos.to.line);
      else
        return found;
    }
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);

    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
      wrongLine = true;
      if (innerOff > sp.bottom) return sp.left - adjust;
      else if (innerOff < sp.top) return sp.left + adjust;
      else wrongLine = false;
      return sp.left;
    }

    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var xDiff = x - (ch == from ? fromX : toX);
        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var operationGroup = null;

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: null,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      id: ++nextOpId           // Unique ID
    };
    if (operationGroup) {
      operationGroup.ops.push(cm.curOp);
    } else {
      cm.curOp.ownsGroup = operationGroup = {
        ops: [cm.curOp],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        callbacks[i]();
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            op.cursorActivityHandlers[op.cursorActivityCalled++](op.cm);
      }
    } while (i < callbacks.length);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp, group = op.ownsGroup;
    if (!group) return;

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      for (var i = 0; i < group.ops.length; i++)
        group.ops[i].cm.curOp = null;
      endOperations(group);
    }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_finish(ops[i]);
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) findMaxLine(cm);

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) updateHeightsInViewport(cm);

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      op.newSelectionNodes = drawSelection(cm);
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      cm.display.maxLineChanged = false;
    }

    if (op.newSelectionNodes)
      showSelection(cm, op.newSelectionNodes);
    if (op.updatedDisplay)
      setDocumentHeight(cm, op.barMeasure);
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      updateScrollbars(cm, op.barMeasure);

    if (op.selectionChanged) restartBlink(cm);

    if (cm.state.focused && op.updateInput)
      resetInput(cm, op.typing);
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      display.wheelStartX = display.wheelStartY = null;

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
      display.scrollbars.setScrollTop(doc.scrollTop);
      display.scroller.scrollTop = doc.scrollTop;
    }
    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));
      display.scrollbars.setScrollLeft(doc.scrollLeft);
      display.scroller.scrollLeft = doc.scrollLeft;
      alignHorizontally(cm);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) for (var i = 0; i < hidden.length; ++i)
      if (!hidden[i].lines.length) signal(hidden[i], "hide");
    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

    if (display.wrapper.offsetHeight)
      doc.scrollTop = cm.display.scroller.scrollTop;

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      signal(cm, "changes", cm, op.changeObjs);
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) return f();
    startOperation(cm);
    try { return f(); }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) return f.apply(cm, arguments);
      startOperation(cm);
      try { return f.apply(cm, arguments); }
      finally { endOperation(cm); }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) return f.apply(this, arguments);
      startOperation(this);
      try { return f.apply(this, arguments); }
      finally { endOperation(this); }
    };
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) return f.apply(this, arguments);
      startOperation(cm);
      try { return f.apply(this, arguments); }
      finally { endOperation(cm); }
    };
  }

  // VIEW TRACKING

  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) from = cm.doc.first;
    if (to == null) to = cm.doc.first + cm.doc.size;
    if (!lendiff) lendiff = 0;

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      display.updateLineNumbers = from;

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        resetView(cm);
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut = viewCuttingPoint(cm, from, from, -1);
      if (cut) {
        display.view = display.view.slice(0, cut.index);
        display.viewTo = cut.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        ext.lineN += lendiff;
      else if (from < ext.lineN + ext.size)
        display.externalMeasured = null;
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      display.externalMeasured = null;

    if (line < display.viewFrom || line >= display.viewTo) return;
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) return;
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) arr.push(type);
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) return null;
    n -= cm.display.viewFrom;
    if (n < 0) return null;
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) return i;
    }
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      return {index: index, lineN: newN};
    for (var i = 0, n = cm.display.viewFrom; i < index; i++)
      n += view[i].size;
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) return null;
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) return null;
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN};
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      else if (display.viewFrom < from)
        display.view = display.view.slice(findViewIndex(cm, from));
      display.viewFrom = from;
      if (display.viewTo < to)
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      else if (display.viewTo > to)
        display.view = display.view.slice(0, findViewIndex(cm, to));
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
    }
    return dirty;
  }

  // INPUT HANDLING

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  function slowPoll(cm) {
    if (cm.display.pollingFast) return;
    cm.display.poll.set(cm.options.pollInterval, function() {
      readInput(cm);
      if (cm.state.focused) slowPoll(cm);
    });
  }

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  function fastPoll(cm) {
    var missed = false;
    cm.display.pollingFast = true;
    function p() {
      var changed = readInput(cm);
      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}
      else {cm.display.pollingFast = false; slowPoll(cm);}
    }
    cm.display.poll.set(20, p);
  }

  // This will be set to an array of strings when copying, so that,
  // when pasting, we know what kind of selections the copied text
  // was made out of.
  var lastCopied = null;

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  function readInput(cm) {
    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (!cm.state.focused || (hasSelection(input) && !prevInput) || isReadOnly(cm) || cm.options.disableInput || cm.state.keySeq)
      return false;
    // See paste handler for more on the fakedLastChar kludge
    if (cm.state.pasteIncoming && cm.state.fakedLastChar) {
      input.value = input.value.substring(0, input.value.length - 1);
      cm.state.fakedLastChar = false;
    }
    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) return false;
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && cm.display.inputHasSelection === text ||
        mac && /[\uf700-\uf7ff]/.test(text)) {
      resetInput(cm);
      return false;
    }

    var withOp = !cm.curOp;
    if (withOp) startOperation(cm);
    cm.display.shift = false;

    if (text.charCodeAt(0) == 0x200b && doc.sel == cm.display.selForContextMenu && !prevInput)
      prevInput = "\u200b";
    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;
    var inserted = text.slice(same), textLines = splitLines(inserted);

    // When pasing N lines into N selections, insert one line per selection
    var multiPaste = null;
    if (cm.state.pasteIncoming && doc.sel.ranges.length > 1) {
      if (lastCopied && lastCopied.join("\n") == inserted)
        multiPaste = doc.sel.ranges.length % lastCopied.length == 0 && map(lastCopied, splitLines);
      else if (textLines.length == doc.sel.ranges.length)
        multiPaste = map(textLines, function(l) { return [l]; });
    }

    // Normal behavior is to insert the new text into every selection
    for (var i = doc.sel.ranges.length - 1; i >= 0; i--) {
      var range = doc.sel.ranges[i];
      var from = range.from(), to = range.to();
      // Handle deletion
      if (same < prevInput.length)
        from = Pos(from.line, from.ch - (prevInput.length - same));
      // Handle overwrite
      else if (cm.state.overwrite && range.empty() && !cm.state.pasteIncoming)
        to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
      var updateInput = cm.curOp.updateInput;
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
                         origin: cm.state.pasteIncoming ? "paste" : cm.state.cutIncoming ? "cut" : "+input"};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
      // When an 'electric' character is inserted, immediately trigger a reindent
      if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&
          cm.options.smartIndent && range.head.ch < 100 &&
          (!i || doc.sel.ranges[i - 1].head.line != range.head.line)) {
        var mode = cm.getModeAt(range.head);
        var end = changeEnd(changeEvent);
        if (mode.electricChars) {
          for (var j = 0; j < mode.electricChars.length; j++)
            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
              indentLine(cm, end.line, "smart");
              break;
            }
        } else if (mode.electricInput) {
          if (mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)))
            indentLine(cm, end.line, "smart");
        }
      }
    }
    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;

    // Don't leave long text in the textarea, since it makes further polling slow
    if (text.length > 1000 || text.indexOf("\n") > -1) input.value = cm.display.prevInput = "";
    else cm.display.prevInput = text;
    if (withOp) endOperation(cm);
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
    return true;
  }

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  function resetInput(cm, typing) {
    if (cm.display.contextMenuPending) return;
    var minimal, selected, doc = cm.doc;
    if (cm.somethingSelected()) {
      cm.display.prevInput = "";
      var range = doc.sel.primary();
      minimal = hasCopyEvent &&
        (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
      var content = minimal ? "-" : selected || cm.getSelection();
      cm.display.input.value = content;
      if (cm.state.focused) selectInput(cm.display.input);
      if (ie && ie_version >= 9) cm.display.inputHasSelection = content;
    } else if (!typing) {
      cm.display.prevInput = cm.display.input.value = "";
      if (ie && ie_version >= 9) cm.display.inputHasSelection = null;
    }
    cm.display.inaccurateSelection = minimal;
  }

  function focusInput(cm) {
    if (cm.options.readOnly != "nocursor" && (!mobile || activeElt() != cm.display.input))
      cm.display.input.focus();
  }

  function ensureFocus(cm) {
    if (!cm.state.focused) { focusInput(cm); onFocus(cm); }
  }

  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }

  // EVENT HANDLERS

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    else
      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
    // Prevent normal selection in the editor (we handle our own)
    on(d.lineSpace, "selectstart", function(e) {
      if (!eventInWidget(d, e)) e_preventDefault(e);
    });
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    on(d.input, "keyup", function(e) { onKeyUp.call(cm, e); });
    on(d.input, "input", function() {
      if (ie && ie_version >= 9 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;
      readInput(cm);
    });
    on(d.input, "keydown", operation(cm, onKeyDown));
    on(d.input, "keypress", operation(cm, onKeyPress));
    on(d.input, "focus", bind(onFocus, cm));
    on(d.input, "blur", bind(onBlur, cm));

    function drag_(e) {
      if (!signalDOMEvent(cm, e)) e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});
      on(d.scroller, "dragenter", drag_);
      on(d.scroller, "dragover", drag_);
      on(d.scroller, "drop", operation(cm, onDrop));
    }
    on(d.scroller, "paste", function(e) {
      if (eventInWidget(d, e)) return;
      cm.state.pasteIncoming = true;
      focusInput(cm);
      fastPoll(cm);
    });
    on(d.input, "paste", function() {
      // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206
      // Add a char to the end of textarea before paste occur so that
      // selection doesn't span to the end of textarea.
      if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {
        var start = d.input.selectionStart, end = d.input.selectionEnd;
        d.input.value += "$";
        // The selection end needs to be set before the start, otherwise there
        // can be an intermediate non-empty selection between the two, which
        // can override the middle-click paste buffer on linux and cause the
        // wrong thing to get pasted.
        d.input.selectionEnd = end;
        d.input.selectionStart = start;
        cm.state.fakedLastChar = true;
      }
      cm.state.pasteIncoming = true;
      fastPoll(cm);
    });

    function prepareCopyCut(e) {
      if (cm.somethingSelected()) {
        lastCopied = cm.getSelections();
        if (d.inaccurateSelection) {
          d.prevInput = "";
          d.inaccurateSelection = false;
          d.input.value = lastCopied.join("\n");
          selectInput(d.input);
        }
      } else {
        var text = [], ranges = [];
        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
          var line = cm.doc.sel.ranges[i].head.line;
          var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
          ranges.push(lineRange);
          text.push(cm.getRange(lineRange.anchor, lineRange.head));
        }
        if (e.type == "cut") {
          cm.setSelections(ranges, null, sel_dontScroll);
        } else {
          d.prevInput = "";
          d.input.value = text.join("\n");
          selectInput(d.input);
        }
        lastCopied = text;
      }
      if (e.type == "cut") cm.state.cutIncoming = true;
    }
    on(d.input, "cut", prepareCopyCut);
    on(d.input, "copy", prepareCopyCut);

    // Needed to handle Tab key in KHTML
    if (khtml) on(d.sizer, "mouseup", function() {
      if (activeElt() == d.input) d.input.blur();
      focusInput(cm);
    });
  }

  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
      return;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  // MOUSE EVENTS

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) return true;
    }
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("not-content") == "true") return null;

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null; }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    if (signalDOMEvent(this, e)) return;
    var cm = this, display = cm.display;
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function(){display.scroller.draggable = true;}, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) return;
    var start = posFromMouse(cm, e);
    window.focus();

    switch (e_button(e)) {
    case 1:
      if (start)
        leftButtonDown(cm, e, start);
      else if (e_target(e) == display.scroller)
        e_preventDefault(e);
      break;
    case 2:
      if (webkit) cm.state.lastMiddleDown = +new Date;
      if (start) extendSelection(cm.doc, start);
      setTimeout(bind(focusInput, cm), 20);
      e_preventDefault(e);
      break;
    case 3:
      if (captureRightClick) onContextMenu(cm, e);
      break;
    }
  }

  var lastClick, lastDoubleClick;
  function leftButtonDown(cm, e, start) {
    setTimeout(bind(ensureFocus, cm), 0);

    var now = +new Date, type;
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
      type = "triple";
    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
      type = "double";
      lastDoubleClick = {time: now, pos: start};
    } else {
      type = "single";
      lastClick = {time: now, pos: start};
    }

    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) &&
        type == "single" && (contained = sel.contains(start)) > -1 &&
        !sel.ranges[contained].empty())
      leftButtonStartDrag(cm, e, start, modifier);
    else
      leftButtonSelect(cm, e, start, type, modifier);
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, e, start, modifier) {
    var display = cm.display;
    var dragEnd = operation(cm, function(e2) {
      if (webkit) display.scroller.draggable = false;
      cm.state.draggingText = false;
      off(document, "mouseup", dragEnd);
      off(display.scroller, "drop", dragEnd);
      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
        e_preventDefault(e2);
        if (!modifier)
          extendSelection(cm.doc, start);
        focusInput(cm);
        // Work around unexplainable focus problem in IE9 (#2127)
        if (ie && ie_version == 9)
          setTimeout(function() {document.body.focus(); focusInput(cm);}, 20);
      }
    });
    // Let the drag handler handle this.
    if (webkit) display.scroller.draggable = true;
    cm.state.draggingText = dragEnd;
    // IE's approach to draggable
    if (display.scroller.dragDrop) display.scroller.dragDrop();
    on(document, "mouseup", dragEnd);
    on(display.scroller, "drop", dragEnd);
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, e, start, type, addNew) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(e);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (addNew && !e.shiftKey) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        ourRange = ranges[ourIndex];
      else
        ourRange = new Range(start, start);
    } else {
      ourRange = doc.sel.primary();
    }

    if (e.altKey) {
      type = "rect";
      if (!addNew) ourRange = new Range(start, start);
      start = posFromMouse(cm, e, true, true);
      ourIndex = -1;
    } else if (type == "double") {
      var word = cm.findWordAt(start);
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
      else
        ourRange = word;
    } else if (type == "triple") {
      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
      else
        ourRange = line;
    } else {
      ourRange = extendRange(doc, ourRange, start);
    }

    if (!addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single") {
      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0));
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) return;
      lastPos = pos;

      if (type == "rect") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          else if (text.length > leftPos)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
        }
        if (!ranges.length) ranges.push(new Range(start, start));
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var anchor = oldRange.anchor, head = pos;
        if (type != "single") {
          if (type == "double")
            var range = cm.findWordAt(pos);
          else
            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
          if (cmp(range.anchor, anchor) > 0) {
            head = range.head;
            anchor = minPos(oldRange.from(), range.anchor);
          } else {
            head = range.anchor;
            anchor = maxPos(oldRange.to(), range.head);
          }
        }
        var ranges = startSel.ranges.slice(0);
        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, type == "rect");
      if (!cur) return;
      if (cmp(cur, lastPos) != 0) {
        ensureFocus(cm);
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) setTimeout(operation(cm, function() {
          if (counter != curCount) return;
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50);
      }
    }

    function done(e) {
      counter = Infinity;
      e_preventDefault(e);
      focusInput(cm);
      off(document, "mousemove", move);
      off(document, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function(e) {
      if (!e_button(e)) done(e);
      else extend(e);
    });
    var up = operation(cm, done);
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent, signalfn) {
    try { var mX = e.clientX, mY = e.clientY; }
    catch(e) { return false; }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
    if (prevent) e_preventDefault(e);

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalfn(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true, signalLater);
  }

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      return;
    e_preventDefault(e);
    if (ie) lastDrop = +new Date;
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm)) return;
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function(file, i) {
        var reader = new FileReader;
        reader.onload = operation(cm, function() {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos, text: splitLines(text.join("\n")), origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(bind(focusInput, cm), 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          if (cm.state.draggingText && !(mac ? e.metaKey : e.ctrlKey))
            var selected = cm.listSelections();
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) for (var i = 0; i < selected.length; ++i)
            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
          cm.replaceSelection(text, "around", "paste");
          focusInput(cm);
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

    e.dataTransfer.setData("Text", cm.getSelection());

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) img.parentNode.removeChild(img);
    }
  }

  // SCROLL EVENTS

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplaySimple(cm, {top: val});
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (gecko) updateDisplaySimple(cm);
    startWorker(cm, 100);
  }
  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    cm.display.scrollbars.setScrollLeft(val);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  var wheelEventDelta = function(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;
    return {x: dx, y: dy};
  };
  CodeMirror.wheelEventPixels = function(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  };

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||
          dy && scroll.scrollHeight > scroll.clientHeight)) return;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // KEY EVENTS

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;
    var prevShift = cm.display.shift, done = false;
    try {
      if (isReadOnly(cm)) cm.state.suppressEdits = true;
      if (dropShift) cm.display.shift = false;
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) return result;
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm);
  }

  var stopSeq = new Delayed;
  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) return "handled";
      stopSeq.set(50, function() {
        if (cm.state.keySeq == seq) {
          cm.state.keySeq = null;
          resetInput(cm);
        }
      });
      name = seq + " " + name;
    }
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      cm.state.keySeq = name;
    if (result == "handled")
      signalLater(cm, "keyHandled", cm, name, e);

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    if (seq && !result && /\'$/.test(name)) {
      e_preventDefault(e);
      return true;
    }
    return !!result;
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) return false;

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function(b) {return doHandleBinding(cm, b, true);})
          || dispatchKey(cm, name, e, function(b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 return doHandleBinding(cm, b);
             });
    } else {
      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e,
                       function(b) { return doHandleBinding(cm, b, true); });
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    ensureFocus(cm);
    if (signalDOMEvent(cm, e)) return;
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("", null, "cut");
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      showCrossHair(cm);
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) this.doc.sel.shift = false;
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if (((presto && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (handleCharBinding(cm, e, ch)) return;
    if (ie && ie_version >= 9) cm.display.inputHasSelection = null;
    fastPoll(cm);
  }

  // FOCUS/BLUR EVENTS

  function onFocus(cm) {
    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // The prevInput test prevents this from firing when a context
      // menu is closed (since the resetInput would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        resetInput(cm);
        if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730
      }
    }
    slowPoll(cm);
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.focused) {
      signal(cm, "blur", cm);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (signalDOMEvent(cm, e, "contextmenu")) return;
    var display = cm.display;
    if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;

    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) return; // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

    var oldCSS = display.input.style.cssText;
    display.inputDiv.style.position = "absolute";
    display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
      "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: " +
      (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
      "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)
    focusInput(cm);
    if (webkit) window.scrollTo(null, oldScrollY);
    resetInput(cm);
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) display.input.value = display.prevInput = " ";
    display.contextMenuPending = true;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (display.input.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = display.input.value = "\u200b" + (selected ? display.input.value : "");
        display.prevInput = selected ? "" : "\u200b";
        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      display.contextMenuPending = false;
      display.inputDiv.style.position = "relative";
      display.input.style.cssText = oldCSS;
      if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
      slowPoll(cm);

      // Try to detect the user choosing select-all
      if (display.input.selectionStart != null) {
        if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();
        var i = 0, poll = function() {
          if (display.selForContextMenu == cm.doc.sel && display.input.selectionStart == 0)
            operation(cm, commands.selectAll)(cm);
          else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);
          else resetInput(cm);
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) prepareSelectAllHack();
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function() {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) return false;
    return gutterEvent(cm, e, "gutterContextMenu", false, signal);
  }

  // UPDATING

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  var changeEnd = CodeMirror.changeEnd = function(change) {
    if (!change.text) return change.to;
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  };

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) return pos;
    if (cmp(pos, change.to) <= 0) return changeEnd(change);

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    else
      return Pos(nw.line + (pos.line - old.line), pos.ch);
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() { this.canceled = true; }
    };
    if (update) obj.update = function(from, to, text, origin) {
      if (from) this.from = clipPos(doc, from);
      if (to) this.to = clipPos(doc, to);
      if (text) this.text = text;
      if (origin !== undefined) this.origin = origin;
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits) return;

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    for (var i = 0; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        break;
    }
    if (i == source.length) return;
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return;
        }
        selAfter = event;
      }
      else break;
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return;
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) return;
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function(range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
                       Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        regLineChange(doc.cm, l, "gutter");
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) selAfter = computeSelAfterChange(doc, change);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
    else updateDoc(doc, change, spans);
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      signalCursorActivity(cm);

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      regLineChange(cm, from.line, "text");
    else
      regChange(cm, from.line, to.line + 1, lendiff);

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) signalLater(cm, "change", cm, obj);
      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, coords) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) return;

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " +
                           coords.left + "px; width: 2px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) margin = 0;
    for (var limit = 0; limit < 5; limit++) {
      var changed = false, coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
                                         Math.min(coords.top, endCoords.top) - margin,
                                         Math.max(coords.left, endCoords.left),
                                         Math.max(coords.bottom, endCoords.bottom) + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) break;
    }
    return coords;
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0) y1 = 0;
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (y2 - y1 > screen) y2 = y1 + screen;
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) result.scrollTop = newTop;
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = x2 - x1 > screenw;
    if (tooWide) x2 = x1 + screenw;
    if (x1 < 10)
      result.scrollLeft = 0;
    else if (x1 < screenleft)
      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
    else if (x2 > screenw + screenleft - 3)
      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollPos(cm, left, top) {
    if (left != null || top != null) resolveScrollToPos(cm);
    if (left != null)
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
    if (top != null)
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor(), from = cur, to = cur;
    if (!cm.options.lineWrapping) {
      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
      to = Pos(cur.line, cur.ch + 1);
    }
    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
                                    Math.min(from.top, to.top) - range.margin,
                                    Math.max(from.right, to.right),
                                    Math.max(from.bottom, to.bottom) + range.margin);
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
    }
  }

  // API UTILITIES

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) how = "add";
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) how = "prev";
      else state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) line.stateAfter = null;
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i, new Range(pos, pos));
          break;
        }
      }
    }
    line.stateAfter = null;
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);
    return line;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function() {
      for (var i = kill.length - 1; i >= 0; i--)
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      ensureCursorVisible(cm);
    });
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return (possible = false);
      } else ch = next;
      return true;
    }

    if (unit == "char") moveOnce();
    else if (unit == "column") moveOnce(true);
    else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) break;
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) type = "s";
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce();}
          break;
        }

        if (type) sawType = type;
        if (dir > 0 && !moveOnce(!first)) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), origDir, true);
    if (!possible) result.hitSide = true;
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  // EDITOR METHODS

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); focusInput(this); fastPoll(this);},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || maps[i].name == map) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: methodOp(function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: methodOp(function(how) {
      var ranges = this.doc.sel.ranges, end = -1;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (!range.empty()) {
          var from = range.from(), to = range.to();
          var start = Math.max(end, from.line);
          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (var j = start; j < end; ++j)
            indentLine(this, j, how);
          var newRanges = this.doc.sel.ranges;
          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
        } else if (range.head.line > end) {
          indentLine(this, range.head.line, how, true);
          end = range.head.line;
          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
        }
      }
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      return takeToken(this, pos, precise);
    },

    getLineTokens: function(line, precise) {
      return takeToken(this, Pos(line), precise, true);
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      var type;
      if (ch == 0) type = styles[2];
      else for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
        else { type = styles[mid * 2 + 2]; break; }
      }
      var cut = type ? type.indexOf("cm-overlay ") : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },

    getHelper: function(pos, type) {
      return this.getHelpers(pos, type)[0];
    },

    getHelpers: function(pos, type) {
      var found = [];
      if (!helpers.hasOwnProperty(type)) return helpers;
      var help = helpers[type], mode = this.getModeAt(pos);
      if (typeof mode[type] == "string") {
        if (help[mode[type]]) found.push(help[mode[type]]);
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val) found.push(val);
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (var i = 0; i < help._global.length; i++) {
        var cur = help._global[i];
        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
          found.push(cur.val);
      }
      return found;
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1, precise);
    },

    cursorCoords: function(start, mode) {
      var pos, range = this.doc.sel.primary();
      if (start == null) pos = range.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? range.from() : range.to();
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode) {
      var end = false, last = this.doc.first + this.doc.size - 1;
      if (line < this.doc.first) line = this.doc.first;
      else if (line > last) { line = last; end = true; }
      var lineObj = getLine(this.doc, line);
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
        (end ? this.doc.height - heightAtLine(lineObj) : 0);
    },

    defaultTextHeight: function() { return textHeight(this.display); },
    defaultCharWidth: function() { return charWidth(this.display); },

    setGutterMarker: methodOp(function(line, gutterID, value) {
      return changeLine(this.doc, line, "gutter", function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: methodOp(function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regLineChange(cm, i, "gutter");
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    addLineWidget: methodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),

    removeLineWidget: function(widget) { widget.clear(); },

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      node.setAttribute("cm-ignore-events", "true");
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: onKeyUp,

    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        return commands[cmd](this);
    },

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: methodOp(function(dir, unit) {
      var cm = this;
      cm.extendSelectionsBy(function(range) {
        if (cm.display.shift || cm.doc.extend || range.empty())
          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
        else
          return dir < 0 ? range.from() : range.to();
      }, sel_move);
    }),

    deleteH: methodOp(function(dir, unit) {
      var sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        doc.replaceSelection("", null, "+delete");
      else
        deleteNearSelection(this, function(range) {
          var other = findPosH(doc, range.head, dir, unit, false);
          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
        });
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: methodOp(function(dir, unit) {
      var cm = this, doc = this.doc, goals = [];
      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function(range) {
        if (collapse)
          return dir < 0 ? range.from() : range.to();
        var headPos = cursorCoords(cm, range.head, "div");
        if (range.goalColumn != null) headPos.left = range.goalColumn;
        goals.push(headPos.left);
        var pos = findPosV(cm, headPos, dir, unit);
        if (unit == "page" && range == doc.sel.primary())
          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
        return pos;
      }, sel_move);
      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
        doc.sel.ranges[i].goalColumn = goals[i];
    }),

    // Find the word at the given position (as returned by coordsChar).
    findWordAt: function(pos) {
      var doc = this.doc, line = getLine(doc, pos.line).text;
      var start = pos.ch, end = pos.ch;
      if (line) {
        var helper = this.getHelper(pos, "wordChars");
        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
        var startChar = line.charAt(start);
        var check = isWordChar(startChar, helper)
          ? function(ch) { return isWordChar(ch, helper); }
          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
          : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
        while (start > 0 && check(line.charAt(start - 1))) --start;
        while (end < line.length && check(line.charAt(end))) ++end;
      }
      return new Range(Pos(pos.line, start), Pos(pos.line, end));
    },

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite)
        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
      else
        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

      signal(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function() { return activeElt() == this.display.input; },

    scrollTo: methodOp(function(x, y) {
      if (x != null || y != null) resolveScrollToPos(this);
      if (x != null) this.curOp.scrollLeft = x;
      if (y != null) this.curOp.scrollTop = y;
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};
    },

    scrollIntoView: methodOp(function(range, margin) {
      if (range == null) {
        range = {from: this.doc.sel.primary().head, to: null};
        if (margin == null) margin = this.options.cursorScrollMargin;
      } else if (typeof range == "number") {
        range = {from: Pos(range, 0), to: null};
      } else if (range.from == null) {
        range = {from: range, to: null};
      }
      if (!range.to) range.to = range.from;
      range.margin = margin || 0;

      if (range.from.line != null) {
        resolveScrollToPos(this);
        this.curOp.scrollToPos = range;
      } else {
        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
                                      Math.min(range.from.top, range.to.top) - range.margin,
                                      Math.max(range.from.right, range.to.right),
                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);
        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
      }
    }),

    setSize: methodOp(function(width, height) {
      var cm = this;
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) cm.display.wrapper.style.width = interpret(width);
      if (height != null) cm.display.wrapper.style.height = interpret(height);
      if (cm.options.lineWrapping) clearLineMeasurementCache(this);
      var lineNo = cm.display.viewFrom;
      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)
          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }
        ++lineNo;
      });
      cm.curOp.forceUpdate = true;
      signal(cm, "refresh", this);
    }),

    operation: function(f){return runInOp(this, f);},

    refresh: methodOp(function() {
      var oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
        estimateLineHeights(this);
      signal(this, "refresh", this);
    }),

    swapDoc: methodOp(function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      resetInput(this);
      this.scrollTo(doc.scrollLeft, doc.scrollTop);
      this.curOp.forceScroll = true;
      signalLater(this, "swapDoc", this, old);
      return old;
    }),

    getInputField: function(){return this.display.input;},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };
  eventMixin(CodeMirror);

  // OPTION DEFAULTS

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};
  // Functions to run when options are changed.
  var optionHandlers = CodeMirror.optionHandlers = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  // Passed to option handlers when there is no old value.
  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("specialChars", /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val) {
    cm.options.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
    cm.refresh();
  }, true);
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
  option("electricChars", true);
  option("rtlMoveVisually", !windows);
  option("wholeLineUpdateBefore", true);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", function(cm, val, old) {
    var next = getKeyMap(val);
    var prev = old != CodeMirror.Init && getKeyMap(old);
    if (prev && prev.detach) prev.detach(cm, next);
    if (next.attach) next.attach(cm, prev || null);
  });
  option("extraKeys", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, function(cm) {updateScrollbars(cm);}, true);
  option("scrollbarStyle", "native", function(cm) {
    initScrollbars(cm);
    updateScrollbars(cm);
    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
  }, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("resetSelectionOnContextMenu", true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {
      onBlur(cm);
      cm.display.input.blur();
      cm.display.disabled = true;
    } else {
      cm.display.disabled = false;
      if (!val) resetInput(cm);
    }
  });
  option("disableInput", false, function(cm, val) {if (!val) resetInput(cm);}, true);
  option("dragDrop", true);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1, updateSelection, true);
  option("singleCursorHeightPerLine", true, updateSelection, true);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true, resetModeState, true);
  option("addModeClass", false, resetModeState, true);
  option("pollInterval", 100);
  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
  option("historyEventDelay", 1250);
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
  option("maxHighlightLength", 10000, resetModeState, true);
  option("moveInputWithCursor", true, function(cm, val) {
    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
  });

  option("tabindex", null, function(cm, val) {
    cm.display.input.tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2)
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") found = {name: found};
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode("application/xml");
    }
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  CodeMirror.getMode = function(options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) modeObj.helperType = spec.helperType;
    if (spec.modeProps) for (var prop in spec.modeProps)
      modeObj[prop] = spec.modeProps[prop];

    return modeObj;
  };

  // Minimal default mode.
  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because nested
  // modes need to do this for their inner modes.

  var copyState = CodeMirror.copyState = function(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  };

  var startState = CodeMirror.startState = function(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  };

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      if (!info || info.mode == mode) break;
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
    singleSelection: function(cm) {
      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine())
            return {from: range.head, to: Pos(range.head.line + 1, 0)};
          else
            return {from: range.head, to: Pos(range.head.line, len)};
        } else {
          return {from: range.from(), to: range.to()};
        }
      });
    },
    deleteLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0),
                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
      });
    },
    delLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0), to: range.from()};
      });
    },
    delWrappedLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({left: 0, top: top}, "div");
        return {from: leftPos, to: range.from()};
      });
    },
    delWrappedLineRight: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
        return {from: range.from(), to: rightPos };
      });
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    undoSelection: function(cm) {cm.undoSelection();},
    redoSelection: function(cm) {cm.redoSelection();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },
                            {origin: "+move", bias: 1});
    },
    goLineStartSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        return lineStartSmart(cm, range.head);
      }, {origin: "+move", bias: 1});
    },
    goLineEnd: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },
                            {origin: "+move", bias: -1});
    },
    goLineRight: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      }, sel_move);
    },
    goLineLeft: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: 0, top: top}, "div");
      }, sel_move);
    },
    goLineLeftSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({left: 0, top: top}, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
        return pos;
      }, sel_move);
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goGroupRight: function(cm) {cm.moveH(1, "group");},
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t");},
    insertSoftTab: function(cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.execCommand("insertTab");
    },
    transposeChars: function(cm) {
      runInOp(cm, function() {
        var ranges = cm.listSelections(), newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                              Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev)
                cm.replaceRange(line.charAt(0) + "\n" + prev.charAt(prev.length - 1),
                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function(cm) {
      runInOp(cm, function() {
        var len = cm.listSelections().length;
        for (var i = 0; i < len; i++) {
          var range = cm.listSelections()[i];
          cm.replaceRange("\n", range.anchor, range.head, "+input");
          cm.indentLine(range.from().line + 1, null, true);
          ensureCursorVisible(cm);
        }
      });
    },
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };


  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    fallthrough: "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;
      else if (/^a(lt)?$/i.test(mod)) alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
      else if (/^s(hift)$/i.test(mod)) shift = true;
      else throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt) name = "Alt-" + name;
    if (ctrl) name = "Ctrl-" + name;
    if (cmd) name = "Cmd-" + name;
    if (shift) name = "Shift-" + name;
    return name;
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  CodeMirror.normalizeKeyMap = function(keymap) {
    var copy = {};
    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
      if (value == "...") { delete keymap[keyname]; continue; }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val, name;
        if (i == keys.length - 1) {
          name = keyname;
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) copy[name] = val;
        else if (prev != val) throw new Error("Inconsistent bindings for " + name);
      }
      delete keymap[keyname];
    }
    for (var prop in copy) keymap[prop] = copy[prop];
    return keymap;
  };

  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) return "nothing";
    if (found === "...") return "multi";
    if (found != null && handle(found)) return "handled";

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
        return lookupKey(key, map.fallthrough, handle, context);
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) return result;
      }
    }
  };

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  var isModifierKey = CodeMirror.isModifierKey = function(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  };

  // Look up the name of a key as indicated by an event object.
  var keyName = CodeMirror.keyName = function(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) return false;
    var base = keyNames[event.keyCode], name = base;
    if (name == null || event.altGraphKey) return false;
    if (event.altKey && base != "Alt") name = "Alt-" + name;
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") name = "Ctrl-" + name;
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") name = "Cmd-" + name;
    if (!noShift && event.shiftKey && base != "Shift") name = "Shift-" + name;
    return name;
  };

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  }

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    if (!options) options = {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabindex)
      options.tabindex = textarea.tabindex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    cm.save = save;
    cm.getTextArea = function() { return textarea; };
    cm.toTextArea = function() {
      cm.toTextArea = isNaN; // Prevent this from being ran twice
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = "";
      if (textarea.form) {
        off(textarea.form, "submit", save);
        if (typeof textarea.form.submit == "function")
          textarea.form.submit = realSubmit;
      }
    };
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = CodeMirror.StringStream = function(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
  };

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == this.lineStart;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function() {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);},
    hideFirstChars: function(n, inner) {
      this.lineStart += n;
      try { return inner(); }
      finally { this.lineStart -= n; }
    }
  };

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  var TextMarker = CodeMirror.TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
  };
  eventMixin(TextMarker);

  // Clear the marker.
  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) signalLater(this, "clear", found.from, found.to);
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
      else if (cm) {
        if (span.to != null) max = lineNo(line);
        if (span.from != null) min = lineNo(line);
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(this.lines[i]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm.doc);
    }
    if (cm) signalLater(cm, "markerCleared", cm, this);
    if (withOp) endOperation(cm);
    if (this.parent) this.parent.clear();
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function(side, lineObj) {
    if (side == null && this.type == "bookmark") side = 1;
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) return from;
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) return to;
      }
    }
    return from && {from: from, to: to};
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function() {
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) return;
    runInOp(cm, function() {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          updateLineHeight(line, line.height + dHeight);
      }
    });
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) copyObj(options, marker, false);
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      return marker;
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) marker.widgetNode.setAttribute("cm-ignore-events", "true");
      if (options.insertLeft) marker.widgetNode.insertLeft = true;
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      sawCollapsedSpans = true;
    }

    if (marker.addToHistory)
      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        updateMaxLine = true;
      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
      if (marker.atomic) reCheckSelection(cm.doc);
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      markers[i].parent = this;
  };
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function(side, lineObj) {
    return this.primary.find(side, lineObj);
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function(doc) {
      if (widget) options.widgetNode = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
                         function(m) { return m.parent; });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], linked = [marker.primary.doc];;
      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    }
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) first = clearEmptySpans(first);
    if (last && last != first) last = clearEmptySpans(last);

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        spans.splice(i--, 1);
    }
    if (!spans.length) return null;
    return spans;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          newParts.push({from: p.from, to: m.from});
        if (dto > 0 || !mk.inclusiveRight && !dto)
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) return lenDiff;
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) return -fromCmp;
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) return toCmp;
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) continue;
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||
          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))
        return true;
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = merged.find(-1, true).line;
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) return lineN;
    return lineNo(vis);
  }
  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) return lineN;
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) return lineN;
    while (merged = collapsedSpanAtEnd(line))
      line = merged.find(1, true).line;
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.marker.widgetNode) continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  // LINE WIDGETS

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {
    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.cm = cm;
    this.node = node;
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      addToScrollPos(cm, null, diff);
  }

  LineWidget.prototype.clear = function() {
    var cm = this.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) line.widgets = null;
    var height = widgetHeight(this);
    runInOp(cm, function() {
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, "widget");
      updateLineHeight(line, Math.max(0, line.height - height));
    });
  };
  LineWidget.prototype.changed = function() {
    var oldH = this.height, cm = this.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    runInOp(cm, function() {
      cm.curOp.forceUpdate = true;
      adjustScrollWhenAboveVisible(cm, line, diff);
      updateLineHeight(line, line.height + diff);
    });
  };

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        parentStyle += "margin-left: -" + widget.cm.getGutterElement().offsetWidth + "px;";
      removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.offsetHeight;
  }

  function addLineWidget(cm, handle, node, options) {
    var widget = new LineWidget(cm, node, options);
    if (widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(cm.doc, handle, "widget", function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) widgets.push(widget);
      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (!lineIsHidden(cm.doc, line)) {
        var aboveVisible = heightAtLine(line) < cm.doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) addToScrollPos(cm, null, widget.height);
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  eventMixin(Line);
  Line.prototype.lineNo = function() { return lineNo(this); };

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  function extractLineClasses(type, output) {
    if (type) for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) break;
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        output[prop] = lineClass[2];
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        output[prop] += " " + lineClass[2];
    }
    return type;
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) return mode.blankLine(state);
    if (!mode.innerMode) return;
    var inner = CodeMirror.innerMode(mode, state);
    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) return style;
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    function getObj(copy) {
      return {start: stream.start, end: stream.pos,
              string: stream.current(),
              type: style || null,
              state: copy ? copyState(doc.mode, state) : state};
    }

    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize), tokens;
    if (asArray) tokens = [];
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, state);
      if (asArray) tokens.push(getObj(true));
    }
    return asArray ? tokens : getObj();
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) processLine(cm, text, state, stream.pos);
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) style = "m-" + (style ? mName + " " + style : mName);
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 50000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444 characters
      var pos = Math.min(stream.pos, curStart + 50000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, state, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
      st.push(end, style);
    }, lineClasses, forceToEnd);

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i+1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, "cm-overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
          }
        }
      }, lineClasses);
    }

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
      line.styles = result.styles;
      if (result.classes) line.styleClasses = result.classes;
      else if (line.styleClasses) line.styleClasses = null;
      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;
    }
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, state, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize);
    stream.start = stream.pos = startAt || 0;
    if (text == "") callBlankLine(mode, state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      readToken(mode, stream, state);
      stream.start = stream.pos;
    }
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) return null;
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: elt("pre", [content]), content: content, col: 0, pos: 0, cm: cm};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if ((ie || webkit) && cm.getOption("lineWrapping"))
        builder.addToken = buildTokenSplitSpaces(builder.addToken);
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        if (line.styleClasses.textClass)
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit && /\bcm-tab\b/.test(builder.content.lastChild.className))
      builder.content.className = "cm-tab-wrap-hack";

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");

    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
    if (!text) return;
    var special = builder.cm.options.specialChars, mustWrap = false;
    if (!special.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(text);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) mustWrap = true;
      builder.pos += text.length;
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(text.slice(pos, pos + skipped));
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          builder.col += tabWidth;
        } else {
          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt);
        builder.pos++;
      }
    }
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      var token = elt("span", [content], fullStyle, css);
      if (title) token.title = title;
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }

  function buildTokenSplitSpaces(inner) {
    function split(old) {
      var out = " ";
      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
      out += " ";
      return out;
    }
    return function(builder, text, style, startStyle, endStyle, title) {
      inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);
    };
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function(builder, text, style, startStyle, endStyle, title) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        for (var i = 0; i < order.length; i++) {
          var part = order[i];
          if (part.to > start && part.from <= start) break;
        }
        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title);
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) {
      builder.map.push(builder.pos, builder.pos + size, widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
      return;
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [];
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }
            if (m.className) spanStyle += " " + m.className;
            if (m.css) css = m.css;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
            if (m.title && !title) title = m.title;
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) foundBookmarks.push(m);
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) return;
        }
        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)
          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      for (var i = 0, added = []; i < text.length - 1; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        for (var added = [], i = 1; i < text.length - 1; ++i)
          added.push(new Line(text[i], spansFor(i), estimateHeight));
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      for (var i = 1, added = []; i < text.length - 1; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, height = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
    },
    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;

    if (typeof text == "string") text = splitLines(text);
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: splitLines(code), origin: "setValue"}, true);
      setSelection(this, simpleSelection(top));
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") line = getLine(this, line);
      return visualLine(line);
    },

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") pos = range.head;
      else if (start == "anchor") pos = range.anchor;
      else if (start == "end" || start == "to" || start === false) pos = range.to();
      else pos = range.from();
      return pos;
    },
    listSelections: function() { return this.sel.ranges; },
    somethingSelected: function() {return this.sel.somethingSelected();},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads, options));
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      extendSelections(this, map(this.sel.ranges, f), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) return;
      for (var i = 0, out = []; i < ranges.length; i++)
        out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head));
      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) return lines;
      else return lines.join(lineSep || "\n");
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) sel = sel.join(lineSep || "\n");
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        dup[i] = code;
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i = changes.length - 1; i >= 0; i--)
        makeChange(this, changes[i]);
      if (newSel) setSelectionReplaceHistory(this, newSel);
      else if (this.cm) ensureCursorVisible(this.cm);
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend;},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
      return {undo: done, redo: undone};
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (classTest(cls).test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var found = cur.match(classTest(cls));
          if (!found) return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function(line) {
        var spans = line.markedSpans;
        if (spans) for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(lineNo == from.line && from.ch > span.to ||
                span.from == null && lineNo != from.line||
                lineNo == to.line && span.from > to.ch) &&
              (!filter || filter(span.marker)))
            found.push(span.marker.parent || span.marker);
        }
        ++lineNo;
      });
      return found;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first;
      this.iter(function(line) {
        var sz = line.text.length + 1;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;}
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  eventMixin(Doc);

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) findMaxLine(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
    for (var chunk = doc; !chunk.lines;) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) for (var n = line; n; n = n.parent) n.height += diff;
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0; i < chunk.children.length; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }


  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) array.pop();
      else break;
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, ore are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        pushSelectionToHistory(doc.sel, hist.done);
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) hist.done.shift();
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) signal(doc, "historyAdded");
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      hist.done[hist.done.length - 1] = sel;
    else
      pushSelectionToHistory(sel, hist.done);

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      clearSelectionEvents(hist.undone);
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      dest.push(sel);
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT UTILITIES

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  };
  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  };
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) b = 1;
      else if (e.button & 2) b = 3;
      else if (e.button & 4) b = 2;
    }
    if (mac && e.ctrlKey && b == 1) b = 3;
    return b;
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var on = CodeMirror.on = function(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent("on" + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  };

  var off = CodeMirror.off = function(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent("on" + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr) return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) { arr.splice(i, 1); break; }
    }
  };

  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
  };

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    function bnd(f) {return function(){f.apply(null, args);};};
    for (var i = 0; i < arr.length; ++i)
      list.push(bnd(arr[i]));
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) return;
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
      set.push(arr[i]);
  }

  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // MISC UTILITIES

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  function Delayed() {this.id = null;}
  Delayed.prototype.set = function(ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        return n + (end - i);
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  };

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) nextTab = string.length;
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        return pos + Math.min(skipped, goal - col);
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) return pos;
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + " ");
    return spaceStrs[n];
  }

  function lst(arr) { return arr[arr.length-1]; }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
  else if (ie) // Suppress mysterious IE10 errors
    selectInput = function(node) { try { node.select(); } catch(_e) {} };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      if (array[i] == elt) return i;
    return -1;
  }
  if ([].indexOf) indexOf = function(array, elt) { return array.indexOf(elt); };
  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
    return out;
  }
  if ([].map) map = function(array, f) { return array.map(f); };

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      var ctor = function() {};
      ctor.prototype = base;
      inst = new ctor();
    }
    if (props) copyObj(props, inst);
    return inst;
  };

  function copyObj(obj, target, overwrite) {
    if (!target) target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        target[prop] = obj[prop];
    return target;
  }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args);};
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  };
  function isWordChar(ch, helper) {
    if (!helper) return isWordCharBasic(ch);
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) return true;
    return helper.test(ch);
  }

  function isEmpty(obj) {
    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
    return true;
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }

  // DOM UTILITIES

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == "string") e.appendChild(document.createTextNode(content));
    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  var range;
  if (document.createRange) range = function(node, start, end) {
    var r = document.createRange();
    r.setEnd(node, end);
    r.setStart(node, start);
    return r;
  };
  else range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r; }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r;
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  function contains(parent, child) {
    if (parent.contains)
      return parent.contains(child);
    while (child = child.parentNode)
      if (child == parent) return true;
  }

  function activeElt() { return document.activeElement; }
  // Older versions of IE throws unspecified error when touching
  // document.activeElement in some cases (during loading, in iframe)
  if (ie && ie_version < 11) activeElt = function() {
    try { return document.activeElement; }
    catch(e) { return document.body; }
  };

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*"); }
  var rmClass = CodeMirror.rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };
  var addClass = CodeMirror.addClass = function(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) node.className += (current ? " " : "") + cls;
  };
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
    return b;
  }

  // WINDOW-WIDE EVENTS

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.body.getElementsByClassName) return;
    var byClass = document.body.getElementsByClassName("CodeMirror");
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) f(cm);
    }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) return;
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function() {
      if (resizeTimer == null) resizeTimer = setTimeout(function() {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100);
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function() {
      forEachCodeMirror(onBlur);
    });
  }

  // FEATURE DETECTION

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) return false;
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
    }
    if (zwspSupported) return elt("span", "\u200b");
    else return elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) return badBidiRects;
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    return badBidiRects = (r1.right - r0.right < 3);
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLines = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) nl = string.length;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string){return string.split(/\r\n?|\n/);};

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = (function() {
    var e = elt("div");
    if ("oncopy" in e) return true;
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) return badZoomedRects;
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  }

  // KEY NAMES

  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
                  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete",
                  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
                  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
                  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"};
  CodeMirror.keyNames = keyNames;
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) return f(from, to, "ltr");
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
        found = true;
      }
    }
    if (!found) f(from, to, "ltr");
  }

  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) return line.text.length;
    return bidiRight(lst(order));
  }

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line = getLine(cm.doc, lineN);
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      lineN = null;
    }
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN == null ? lineNo(line) : lineN, ch);
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS);
    }
    return start;
  }

  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir) return true;
    if (b == linedir) return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    bidiOther = null;
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) return i;
      if ((cur.from == pos || cur.to == pos)) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          if (cur.from != cur.to) bidiOther = found;
          return i;
        } else {
          if (cur.from != cur.to) bidiOther = i;
          return found;
        }
      }
    }
    return found;
  }

  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit) return pos + dir;
    do pos += dir;
    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
    return pos;
  }

  // This is needed in order to move 'visually' through bi-directional
  // text -- i.e., pressing left should make the cursor go left, even
  // when in RTL text. The tricky part is the 'jumps', where RTL and
  // LTR text touch each other. This often requires the cursor offset
  // to move more than one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

    for (;;) {
      if (target > part.from && target < part.to) return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos) return target;
        part = bidi[pos += dir];
        return (dir > 0) == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part) return null;
        if ((dir > 0) == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6ff
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
    function charType(code) {
      if (code <= 0xf7) return lowTypes.charAt(code);
      else if (0x590 <= code && code <= 0x5f4) return "R";
      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
      else if (0x6ee <= code && code <= 0x8ac) return "r";
      else if (0x2000 <= code && code <= 0x200b) return "w";
      else if (code == 0x200c) return "b";
      else return "L";
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str) {
      if (!bidiRE.test(str)) return false;
      var len = str.length, types = [];
      for (var i = 0, type; i < len; ++i)
        types.push(type = charType(str.charCodeAt(i)));

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i = 0, prev = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "m") types[i] = prev;
        else prev = type;
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "1" && cur == "r") types[i] = "n";
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
        var type = types[i];
        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
        else if (type == "," && prev == types[i+1] &&
                 (prev == "1" || prev == "n")) types[i] = prev;
        prev = type;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type == ",") types[i] = "N";
        else if (type == "%") {
          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (cur == "L" && type == "1") types[i] = "L";
        else if (isStrong.test(type)) cur = type;
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i = 0; i < len; ++i) {
        if (isNeutral.test(types[i])) {
          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
          var before = (i ? types[i-1] : outerType) == "L";
          var after = (end < len ? types[end] : outerType) == "L";
          var replace = before || after ? "L" : "R";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i = 0; i < len;) {
        if (countsAsLeft.test(types[i])) {
          var start = i;
          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
          order.push(new BidiSpan(0, start, i));
        } else {
          var pos = i, at = order.length;
          for (++i; i < len && types[i] != "L"; ++i) {}
          for (var j = pos; j < i;) {
            if (countsAsNum.test(types[j])) {
              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
              var nstart = j;
              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j));
              pos = j;
            } else ++j;
          }
          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift(new BidiSpan(0, 0, m[0].length));
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push(new BidiSpan(0, len - m[0].length, len));
      }
      if (order[0].level != lst(order).level)
        order.push(new BidiSpan(order[0].level, len, len));

      return order;
    };
  })();

  // THE END

  CodeMirror.version = "4.10.0";

  return CodeMirror;
});

if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old};
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("haskell", function(_config, modeConfig) {

  function switchState(source, setState, f) {
    setState(f);
    return f(source, setState);
  }

  // These should all be Unicode extended, as per the Haskell 2010 report
  var smallRE = /[a-z_]/;
  var largeRE = /[A-Z]/;
  var digitRE = /\d/;
  var hexitRE = /[0-9A-Fa-f]/;
  var octitRE = /[0-7]/;
  var idRE = /[a-z_A-Z0-9'\xa1-\uffff]/;
  var symbolRE = /[-!#$%&*+.\/<=>?@\\^|~:]/;
  var specialRE = /[(),;[\]`{}]/;
  var whiteCharRE = /[ \t\v\f]/; // newlines are handled in tokenizer

  function normal(source, setState) {
    if (source.eatWhile(whiteCharRE)) {
      return null;
    }

    var ch = source.next();
    if (specialRE.test(ch)) {
      if (ch == '{' && source.eat('-')) {
        var t = "comment";
        if (source.eat('#')) {
          t = "meta";
        }
        return switchState(source, setState, ncomment(t, 1));
      }
      return null;
    }

    if (ch == '\'') {
      if (source.eat('\\')) {
        source.next();  // should handle other escapes here
      }
      else {
        source.next();
      }
      if (source.eat('\'')) {
        return "string";
      }
      return "error";
    }

    if (ch == '"') {
      return switchState(source, setState, stringLiteral);
    }

    if (largeRE.test(ch)) {
      source.eatWhile(idRE);
      if (source.eat('.')) {
        return "qualifier";
      }
      return "variable-2";
    }

    if (smallRE.test(ch)) {
      source.eatWhile(idRE);
      return "variable";
    }

    if (digitRE.test(ch)) {
      if (ch == '0') {
        if (source.eat(/[xX]/)) {
          source.eatWhile(hexitRE); // should require at least 1
          return "integer";
        }
        if (source.eat(/[oO]/)) {
          source.eatWhile(octitRE); // should require at least 1
          return "number";
        }
      }
      source.eatWhile(digitRE);
      var t = "number";
      if (source.match(/^\.\d+/)) {
        t = "number";
      }
      if (source.eat(/[eE]/)) {
        t = "number";
        source.eat(/[-+]/);
        source.eatWhile(digitRE); // should require at least 1
      }
      return t;
    }

    if (ch == "." && source.eat("."))
      return "keyword";

    if (symbolRE.test(ch)) {
      if (ch == '-' && source.eat(/-/)) {
        source.eatWhile(/-/);
        if (!source.eat(symbolRE)) {
          source.skipToEnd();
          return "comment";
        }
      }
      var t = "variable";
      if (ch == ':') {
        t = "variable-2";
      }
      source.eatWhile(symbolRE);
      return t;
    }

    return "error";
  }

  function ncomment(type, nest) {
    if (nest == 0) {
      return normal;
    }
    return function(source, setState) {
      var currNest = nest;
      while (!source.eol()) {
        var ch = source.next();
        if (ch == '{' && source.eat('-')) {
          ++currNest;
        }
        else if (ch == '-' && source.eat('}')) {
          --currNest;
          if (currNest == 0) {
            setState(normal);
            return type;
          }
        }
      }
      setState(ncomment(type, currNest));
      return type;
    };
  }

  function stringLiteral(source, setState) {
    while (!source.eol()) {
      var ch = source.next();
      if (ch == '"') {
        setState(normal);
        return "string";
      }
      if (ch == '\\') {
        if (source.eol() || source.eat(whiteCharRE)) {
          setState(stringGap);
          return "string";
        }
        if (source.eat('&')) {
        }
        else {
          source.next(); // should handle other escapes here
        }
      }
    }
    setState(normal);
    return "error";
  }

  function stringGap(source, setState) {
    if (source.eat('\\')) {
      return switchState(source, setState, stringLiteral);
    }
    source.next();
    setState(normal);
    return "error";
  }


  var wellKnownWords = (function() {
    var wkw = {};
    function setType(t) {
      return function () {
        for (var i = 0; i < arguments.length; i++)
          wkw[arguments[i]] = t;
      };
    }

    setType("keyword")(
      "case", "class", "data", "default", "deriving", "do", "else", "foreign",
      "if", "import", "in", "infix", "infixl", "infixr", "instance", "let",
      "module", "newtype", "of", "then", "type", "where", "_");

    setType("keyword")(
      "\.\.", ":", "::", "=", "\\", "\"", "<-", "->", "@", "~", "=>");

    setType("builtin")(
      "!!", "$!", "$", "&&", "+", "++", "-", ".", "/", "/=", "<", "<=", "=<<",
      "==", ">", ">=", ">>", ">>=", "^", "^^", "||", "*", "**");

    setType("builtin")(
      "Bool", "Bounded", "Char", "Double", "EQ", "Either", "Enum", "Eq",
      "False", "FilePath", "Float", "Floating", "Fractional", "Functor", "GT",
      "IO", "IOError", "Int", "Integer", "Integral", "Just", "LT", "Left",
      "Maybe", "Monad", "Nothing", "Num", "Ord", "Ordering", "Rational", "Read",
      "ReadS", "Real", "RealFloat", "RealFrac", "Right", "Show", "ShowS",
      "String", "True");

    setType("builtin")(
      "abs", "acos", "acosh", "all", "and", "any", "appendFile", "asTypeOf",
      "asin", "asinh", "atan", "atan2", "atanh", "break", "catch", "ceiling",
      "compare", "concat", "concatMap", "const", "cos", "cosh", "curry",
      "cycle", "decodeFloat", "div", "divMod", "drop", "dropWhile", "either",
      "elem", "encodeFloat", "enumFrom", "enumFromThen", "enumFromThenTo",
      "enumFromTo", "error", "even", "exp", "exponent", "fail", "filter",
      "flip", "floatDigits", "floatRadix", "floatRange", "floor", "fmap",
      "foldl", "foldl1", "foldr", "foldr1", "fromEnum", "fromInteger",
      "fromIntegral", "fromRational", "fst", "gcd", "getChar", "getContents",
      "getLine", "head", "id", "init", "interact", "ioError", "isDenormalized",
      "isIEEE", "isInfinite", "isNaN", "isNegativeZero", "iterate", "last",
      "lcm", "length", "lex", "lines", "log", "logBase", "lookup", "map",
      "mapM", "mapM_", "max", "maxBound", "maximum", "maybe", "min", "minBound",
      "minimum", "mod", "negate", "not", "notElem", "null", "odd", "or",
      "otherwise", "pi", "pred", "print", "product", "properFraction",
      "putChar", "putStr", "putStrLn", "quot", "quotRem", "read", "readFile",
      "readIO", "readList", "readLn", "readParen", "reads", "readsPrec",
      "realToFrac", "recip", "rem", "repeat", "replicate", "return", "reverse",
      "round", "scaleFloat", "scanl", "scanl1", "scanr", "scanr1", "seq",
      "sequence", "sequence_", "show", "showChar", "showList", "showParen",
      "showString", "shows", "showsPrec", "significand", "signum", "sin",
      "sinh", "snd", "span", "splitAt", "sqrt", "subtract", "succ", "sum",
      "tail", "take", "takeWhile", "tan", "tanh", "toEnum", "toInteger",
      "toRational", "truncate", "uncurry", "undefined", "unlines", "until",
      "unwords", "unzip", "unzip3", "userError", "words", "writeFile", "zip",
      "zip3", "zipWith", "zipWith3");

    var override = modeConfig.overrideKeywords;
    if (override) for (var word in override) if (override.hasOwnProperty(word))
      wkw[word] = override[word];

    return wkw;
  })();



  return {
    startState: function ()  { return { f: normal }; },
    copyState:  function (s) { return { f: s.f }; },

    token: function(stream, state) {
      var t = state.f(stream, function(s) { state.f = s; });
      var w = stream.current();
      return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;
    },

    blockCommentStart: "{-",
    blockCommentEnd: "-}",
    lineComment: "--"
  };

});

CodeMirror.defineMIME("text/x-haskell", "haskell");

});

if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old};
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode('mllike', function(_config, parserConfig) {
  var words = {
    'let': 'keyword',
    'rec': 'keyword',
    'in': 'keyword',
    'of': 'keyword',
    'and': 'keyword',
    'if': 'keyword',
    'then': 'keyword',
    'else': 'keyword',
    'for': 'keyword',
    'to': 'keyword',
    'while': 'keyword',
    'do': 'keyword',
    'done': 'keyword',
    'fun': 'keyword',
    'function': 'keyword',
    'val': 'keyword',
    'type': 'keyword',
    'mutable': 'keyword',
    'match': 'keyword',
    'with': 'keyword',
    'try': 'keyword',
    'open': 'builtin',
    'ignore': 'builtin',
    'begin': 'keyword',
    'end': 'keyword'
  };

  var extraWords = parserConfig.extraWords || {};
  for (var prop in extraWords) {
    if (extraWords.hasOwnProperty(prop)) {
      words[prop] = parserConfig.extraWords[prop];
    }
  }

  function tokenBase(stream, state) {
    var ch = stream.next();

    if (ch === '"') {
      state.tokenize = tokenString;
      return state.tokenize(stream, state);
    }
    if (ch === '(') {
      if (stream.eat('*')) {
        state.commentLevel++;
        state.tokenize = tokenComment;
        return state.tokenize(stream, state);
      }
    }
    if (ch === '~') {
      stream.eatWhile(/\w/);
      return 'variable-2';
    }
    if (ch === '`') {
      stream.eatWhile(/\w/);
      return 'quote';
    }
    if (ch === '/' && parserConfig.slashComments && stream.eat('/')) {
      stream.skipToEnd();
      return 'comment';
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\d]/);
      if (stream.eat('.')) {
        stream.eatWhile(/[\d]/);
      }
      return 'number';
    }
    if ( /[+\-*&%=<>!?|]/.test(ch)) {
      return 'operator';
    }
    stream.eatWhile(/\w/);
    var cur = stream.current();
    return words[cur] || 'variable';
  }

  function tokenString(stream, state) {
    var next, end = false, escaped = false;
    while ((next = stream.next()) != null) {
      if (next === '"' && !escaped) {
        end = true;
        break;
      }
      escaped = !escaped && next === '\\';
    }
    if (end && !escaped) {
      state.tokenize = tokenBase;
    }
    return 'string';
  };

  function tokenComment(stream, state) {
    var prev, next;
    while(state.commentLevel > 0 && (next = stream.next()) != null) {
      if (prev === '(' && next === '*') state.commentLevel++;
      if (prev === '*' && next === ')') state.commentLevel--;
      prev = next;
    }
    if (state.commentLevel <= 0) {
      state.tokenize = tokenBase;
    }
    return 'comment';
  }

  return {
    startState: function() {return {tokenize: tokenBase, commentLevel: 0};},
    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      return state.tokenize(stream, state);
    },

    blockCommentStart: "(*",
    blockCommentEnd: "*)",
    lineComment: parserConfig.slashComments ? "//" : null
  };
});

CodeMirror.defineMIME('text/x-ocaml', {
  name: 'mllike',
  extraWords: {
    'succ': 'keyword',
    'trace': 'builtin',
    'exit': 'builtin',
    'print_string': 'builtin',
    'print_endline': 'builtin',
    'true': 'atom',
    'false': 'atom',
    'raise': 'keyword'
  }
});

CodeMirror.defineMIME('text/x-fsharp', {
  name: 'mllike',
  extraWords: {
    'abstract': 'keyword',
    'as': 'keyword',
    'assert': 'keyword',
    'base': 'keyword',
    'class': 'keyword',
    'default': 'keyword',
    'delegate': 'keyword',
    'downcast': 'keyword',
    'downto': 'keyword',
    'elif': 'keyword',
    'exception': 'keyword',
    'extern': 'keyword',
    'finally': 'keyword',
    'global': 'keyword',
    'inherit': 'keyword',
    'inline': 'keyword',
    'interface': 'keyword',
    'internal': 'keyword',
    'lazy': 'keyword',
    'let!': 'keyword',
    'member' : 'keyword',
    'module': 'keyword',
    'namespace': 'keyword',
    'new': 'keyword',
    'null': 'keyword',
    'override': 'keyword',
    'private': 'keyword',
    'public': 'keyword',
    'return': 'keyword',
    'return!': 'keyword',
    'select': 'keyword',
    'static': 'keyword',
    'struct': 'keyword',
    'upcast': 'keyword',
    'use': 'keyword',
    'use!': 'keyword',
    'val': 'keyword',
    'when': 'keyword',
    'yield': 'keyword',
    'yield!': 'keyword',

    'List': 'builtin',
    'Seq': 'builtin',
    'Map': 'builtin',
    'Set': 'builtin',
    'int': 'builtin',
    'string': 'builtin',
    'raise': 'builtin',
    'failwith': 'builtin',
    'not': 'builtin',
    'true': 'builtin',
    'false': 'builtin'
  },
  slashComments: true
});

});

if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old};
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("clike", function(config, parserConfig) {
  var indentUnit = config.indentUnit,
      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
      dontAlignCalls = parserConfig.dontAlignCalls,
      keywords = parserConfig.keywords || {},
      builtin = parserConfig.builtin || {},
      blockKeywords = parserConfig.blockKeywords || {},
      atoms = parserConfig.atoms || {},
      hooks = parserConfig.hooks || {},
      multiLineStrings = parserConfig.multiLineStrings,
      indentStatements = parserConfig.indentStatements !== false;
  var isOperatorChar = /[+\-*&%=<>!?|\/]/;

  var curPunc;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_\xa1-\uffff]/);
    var cur = stream.current();
    if (keywords.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "keyword";
    }
    if (builtin.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "builtin";
    }
    if (atoms.propertyIsEnumerable(cur)) return "atom";
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {end = true; break;}
        escaped = !escaped && next == "\\";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = null;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function Context(indented, column, type, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.align = align;
    this.prev = prev;
  }
  function pushContext(state, col, type) {
    var indent = state.indented;
    if (state.context && state.context.type == "statement")
      indent = state.context.indented;
    return state.context = new Context(indent, col, type, null, state.context);
  }
  function popContext(state) {
    var t = state.context.type;
    if (t == ")" || t == "]" || t == "}")
      state.indented = state.context.indented;
    return state.context = state.context.prev;
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
        indented: 0,
        startOfLine: true
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (stream.eatSpace()) return null;
      curPunc = null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment" || style == "meta") return style;
      if (ctx.align == null) ctx.align = true;

      if ((curPunc == ";" || curPunc == ":" || curPunc == ",") && ctx.type == "statement") popContext(state);
      else if (curPunc == "{") pushContext(state, stream.column(), "}");
      else if (curPunc == "[") pushContext(state, stream.column(), "]");
      else if (curPunc == "(") pushContext(state, stream.column(), ")");
      else if (curPunc == "}") {
        while (ctx.type == "statement") ctx = popContext(state);
        if (ctx.type == "}") ctx = popContext(state);
        while (ctx.type == "statement") ctx = popContext(state);
      }
      else if (curPunc == ctx.type) popContext(state);
      else if (indentStatements &&
               (((ctx.type == "}" || ctx.type == "top") && curPunc != ';') ||
                (ctx.type == "statement" && curPunc == "newstatement")))
        pushContext(state, stream.column(), "statement");
      state.startOfLine = false;
      return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;
      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
      if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
      var closing = firstChar == ctx.type;
      if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit);
      else if (ctx.align && (!dontAlignCalls || ctx.type != ")")) return ctx.column + (closing ? 0 : 1);
      else if (ctx.type == ")" && !closing) return ctx.indented + statementIndentUnit;
      else return ctx.indented + (closing ? 0 : indentUnit);
    },

    electricChars: "{}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    lineComment: "//",
    fold: "brace"
  };
});

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var cKeywords = "auto if break int case long char register continue return default short do sizeof " +
    "double static else struct entry switch extern typedef float union for unsigned " +
    "goto while enum void const signed volatile";

  function cppHook(stream, state) {
    if (!state.startOfLine) return false;
    for (;;) {
      if (stream.skipTo("\\")) {
        stream.next();
        if (stream.eol()) {
          state.tokenize = cppHook;
          break;
        }
      } else {
        stream.skipToEnd();
        state.tokenize = null;
        break;
      }
    }
    return "meta";
  }

  function cpp11StringHook(stream, state) {
    stream.backUp(1);
    // Raw strings.
    if (stream.match(/(R|u8R|uR|UR|LR)/)) {
      var match = stream.match(/"([^\s\\()]{0,16})\(/);
      if (!match) {
        return false;
      }
      state.cpp11RawStringDelim = match[1];
      state.tokenize = tokenRawString;
      return tokenRawString(stream, state);
    }
    // Unicode strings/chars.
    if (stream.match(/(u8|u|U|L)/)) {
      if (stream.match(/["']/, /* eat */ false)) {
        return "string";
      }
      return false;
    }
    // Ignore this hook.
    stream.next();
    return false;
  }

  // C#-style strings where "" escapes a quote.
  function tokenAtString(stream, state) {
    var next;
    while ((next = stream.next()) != null) {
      if (next == '"' && !stream.eat('"')) {
        state.tokenize = null;
        break;
      }
    }
    return "string";
  }

  // C++11 raw string literal is <prefix>"<delim>( anything )<delim>", where
  // <delim> can be a string up to 16 characters long.
  function tokenRawString(stream, state) {
    // Escape characters that have special regex meanings.
    var delim = state.cpp11RawStringDelim.replace(/[^\w\s]/g, '\\$&');
    var match = stream.match(new RegExp(".*?\\)" + delim + '"'));
    if (match)
      state.tokenize = null;
    else
      stream.skipToEnd();
    return "string";
  }

  function def(mimes, mode) {
    if (typeof mimes == "string") mimes = [mimes];
    var words = [];
    function add(obj) {
      if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop))
        words.push(prop);
    }
    add(mode.keywords);
    add(mode.builtin);
    add(mode.atoms);
    if (words.length) {
      mode.helperType = mimes[0];
      CodeMirror.registerHelper("hintWords", mimes[0], words);
    }

    for (var i = 0; i < mimes.length; ++i)
      CodeMirror.defineMIME(mimes[i], mode);
  }

  def(["text/x-csrc", "text/x-c", "text/x-chdr"], {
    name: "clike",
    keywords: words(cKeywords),
    blockKeywords: words("case do else for if switch while struct"),
    atoms: words("null"),
    hooks: {"#": cppHook},
    modeProps: {fold: ["brace", "include"]}
  });

  def(["text/x-c++src", "text/x-c++hdr"], {
    name: "clike",
    keywords: words(cKeywords + " asm dynamic_cast namespace reinterpret_cast try bool explicit new " +
                    "static_cast typeid catch operator template typename class friend private " +
                    "this using const_cast inline public throw virtual delete mutable protected " +
                    "wchar_t alignas alignof constexpr decltype nullptr noexcept thread_local final " +
                    "static_assert override"),
    blockKeywords: words("catch class do else finally for if struct switch try while"),
    atoms: words("true false null"),
    hooks: {
      "#": cppHook,
      "u": cpp11StringHook,
      "U": cpp11StringHook,
      "L": cpp11StringHook,
      "R": cpp11StringHook
    },
    modeProps: {fold: ["brace", "include"]}
  });

  def("text/x-java", {
    name: "clike",
    keywords: words("abstract assert boolean break byte case catch char class const continue default " +
                    "do double else enum extends final finally float for goto if implements import " +
                    "instanceof int interface long native new package private protected public " +
                    "return short static strictfp super switch synchronized this throw throws transient " +
                    "try void volatile while"),
    blockKeywords: words("catch class do else finally for if switch try while"),
    atoms: words("true false null"),
    hooks: {
      "@": function(stream) {
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      }
    },
    modeProps: {fold: ["brace", "import"]}
  });

  def("text/x-csharp", {
    name: "clike",
    keywords: words("abstract as base break case catch checked class const continue" +
                    " default delegate do else enum event explicit extern finally fixed for" +
                    " foreach goto if implicit in interface internal is lock namespace new" +
                    " operator out override params private protected public readonly ref return sealed" +
                    " sizeof stackalloc static struct switch this throw try typeof unchecked" +
                    " unsafe using virtual void volatile while add alias ascending descending dynamic from get" +
                    " global group into join let orderby partial remove select set value var yield"),
    blockKeywords: words("catch class do else finally for foreach if struct switch try while"),
    builtin: words("Boolean Byte Char DateTime DateTimeOffset Decimal Double" +
                    " Guid Int16 Int32 Int64 Object SByte Single String TimeSpan UInt16 UInt32" +
                    " UInt64 bool byte char decimal double short int long object"  +
                    " sbyte float string ushort uint ulong"),
    atoms: words("true false null"),
    hooks: {
      "@": function(stream, state) {
        if (stream.eat('"')) {
          state.tokenize = tokenAtString;
          return tokenAtString(stream, state);
        }
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      }
    }
  });

  function tokenTripleString(stream, state) {
    var escaped = false;
    while (!stream.eol()) {
      if (!escaped && stream.match('"""')) {
        state.tokenize = null;
        break;
      }
      escaped = stream.next() != "\\" && !escaped;
    }
    return "string";
  }

  def("text/x-scala", {
    name: "clike",
    keywords: words(

      /* scala */
      "abstract case catch class def do else extends false final finally for forSome if " +
      "implicit import lazy match new null object override package private protected return " +
      "sealed super this throw trait try trye type val var while with yield _ : = => <- <: " +
      "<% >: # @ " +

      /* package scala */
      "assert assume require print println printf readLine readBoolean readByte readShort " +
      "readChar readInt readLong readFloat readDouble " +

      "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either " +
      "Enumeration Equiv Error Exception Fractional Function IndexedSeq Integral Iterable " +
      "Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering " +
      "Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder " +
      "StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector :: #:: " +

      /* package java.lang */
      "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +
      "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +
      "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +
      "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"
    ),
    multiLineStrings: true,
    blockKeywords: words("catch class do else finally for forSome if match switch try while"),
    atoms: words("true false null"),
    indentStatements: false,
    hooks: {
      "@": function(stream) {
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      },
      '"': function(stream, state) {
        if (!stream.match('""')) return false;
        state.tokenize = tokenTripleString;
        return state.tokenize(stream, state);
      }
    }
  });

  def(["x-shader/x-vertex", "x-shader/x-fragment"], {
    name: "clike",
    keywords: words("float int bool void " +
                    "vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 " +
                    "mat2 mat3 mat4 " +
                    "sampler1D sampler2D sampler3D samplerCube " +
                    "sampler1DShadow sampler2DShadow" +
                    "const attribute uniform varying " +
                    "break continue discard return " +
                    "for while do if else struct " +
                    "in out inout"),
    blockKeywords: words("for while do if else struct"),
    builtin: words("radians degrees sin cos tan asin acos atan " +
                    "pow exp log exp2 sqrt inversesqrt " +
                    "abs sign floor ceil fract mod min max clamp mix step smootstep " +
                    "length distance dot cross normalize ftransform faceforward " +
                    "reflect refract matrixCompMult " +
                    "lessThan lessThanEqual greaterThan greaterThanEqual " +
                    "equal notEqual any all not " +
                    "texture1D texture1DProj texture1DLod texture1DProjLod " +
                    "texture2D texture2DProj texture2DLod texture2DProjLod " +
                    "texture3D texture3DProj texture3DLod texture3DProjLod " +
                    "textureCube textureCubeLod " +
                    "shadow1D shadow2D shadow1DProj shadow2DProj " +
                    "shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod " +
                    "dFdx dFdy fwidth " +
                    "noise1 noise2 noise3 noise4"),
    atoms: words("true false " +
                "gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex " +
                "gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 " +
                "gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 " +
                "gl_FogCoord " +
                "gl_Position gl_PointSize gl_ClipVertex " +
                "gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor " +
                "gl_TexCoord gl_FogFragCoord " +
                "gl_FragCoord gl_FrontFacing " +
                "gl_FragColor gl_FragData gl_FragDepth " +
                "gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix " +
                "gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse " +
                "gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse " +
                "gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose " +
                "gl_ProjectionMatrixInverseTranspose " +
                "gl_ModelViewProjectionMatrixInverseTranspose " +
                "gl_TextureMatrixInverseTranspose " +
                "gl_NormalScale gl_DepthRange gl_ClipPlane " +
                "gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel " +
                "gl_FrontLightModelProduct gl_BackLightModelProduct " +
                "gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ " +
                "gl_FogParameters " +
                "gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords " +
                "gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats " +
                "gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits " +
                "gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits " +
                "gl_MaxDrawBuffers"),
    hooks: {"#": cppHook},
    modeProps: {fold: ["brace", "include"]}
  });

  def("text/x-nesc", {
    name: "clike",
    keywords: words(cKeywords + "as atomic async call command component components configuration event generic " +
                    "implementation includes interface module new norace nx_struct nx_union post provides " +
                    "signal task uses abstract extends"),
    blockKeywords: words("case do else for if switch while struct"),
    atoms: words("null"),
    hooks: {"#": cppHook},
    modeProps: {fold: ["brace", "include"]}
  });

  def("text/x-objectivec", {
    name: "clike",
    keywords: words(cKeywords + "inline restrict _Bool _Complex _Imaginery BOOL Class bycopy byref id IMP in " +
                    "inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),
    atoms: words("YES NO NULL NILL ON OFF"),
    hooks: {
      "@": function(stream) {
        stream.eatWhile(/[\w\$]/);
        return "keyword";
      },
      "#": cppHook
    },
    modeProps: {fold: "brace"}
  });

});

if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old};
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// TODO actually recognize syntax of TypeScript constructs

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;
  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    var jsKeywords = {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C, "debugger": C,
      "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "module": kw("module"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C
    };

    // Extend the 'normal' keywords with the TypeScript language extensions
    if (isTS) {
      var type = {type: "variable", style: "variable-3"};
      var tsKeywords = {
        // object-like things
        "interface": kw("interface"),
        "extends": kw("extends"),
        "constructor": kw("constructor"),

        // scope modifiers
        "public": kw("public"),
        "private": kw("private"),
        "protected": kw("protected"),
        "static": kw("static"),

        // types
        "string": type, "number": type, "bool": type, "any": type
      };

      for (var attr in tsKeywords) {
        jsKeywords[attr] = tsKeywords[attr];
      }
    }

    return jsKeywords;
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" && !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet && next == "]") inSet = false;
      }
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
      return ret("number", "number");
    } else if (ch == "." && stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" && stream.eat(">")) {
      return ret("=>", "operator");
    } else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (state.lastType == "operator" || state.lastType == "keyword c" ||
               state.lastType == "sof" || /^[\[{}\(,;:]$/.test(state.lastType)) {
        readRegexp(stream);
        stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla
        return ret("regexp", "string-2");
      } else {
        stream.eatWhile(isOperatorChar);
        return ret("operator", "operator", stream.current());
      }
    } else if (ch == "`") {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    } else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret("operator", "operator", stream.current());
    } else if (wordRE.test(ch)) {
      stream.eatWhile(wordRE);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
                     ret("variable", "variable", word);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret("jsonld-keyword", "meta");
      }
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    return ret("quasi", "string-2", stream.current());
  }

  var brackets = "([{}])";
  // This is a crude lookahead trick to try and notice that we're
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there's no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf("=>", stream.start);
    if (arrow < 0) return;

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos >= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket >= 0 && bracket < 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) break;
      } else if (bracket >= 3 && bracket < 6) {
        ++depth;
      } else if (wordRE.test(ch)) {
        sawSomething = true;
      } else if (/["'\/]/.test(ch)) {
        return;
      } else if (sawSomething && !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething && !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname) return true;
      return false;
    }
    var state = cx.state;
    if (state.context) {
      cx.marked = "def";
      if (inList(state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else {
      if (inList(state.globalVars)) return;
      if (parserConfig.globalVars)
        state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  // Combinators

  var defaultVars = {name: "this", next: {name: "arguments"}};
  function pushcontext() {
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
        indent = outer.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(exp);
    };
    return exp;
  }

  function statement(type, value) {
    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "{") return cont(pushlex("}"), block, poplex);
    if (type == ";") return cont();
    if (type == "if") {
      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex("form"), expression, statement, poplex, maybeelse);
    }
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
    if (type == "variable") return cont(pushlex("stat"), maybelabel);
    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                      block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                     statement, poplex, popcontext);
    if (type == "module") return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex);
    if (type == "class") return cont(pushlex("form"), className, poplex);
    if (type == "export") return cont(pushlex("form"), afterExport, poplex);
    if (type == "import") return cont(pushlex("form"), afterImport, poplex);
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type) {
    return expressionInner(type, false);
  }
  function expressionNoComma(type) {
    return expressionInner(type, true);
  }
  function expressionInner(type, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);
      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef, maybeop);
    if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);
    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
    if (type == "quasi") { return pass(quasi, maybeop); }
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }
  function maybeexpressionNoComma(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expressionNoComma);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == "operator") {
      if (/\+\+|--/.test(value)) return cont(me);
      if (value == "?") return cont(expression, expect(":"), expr);
      return cont(expr);
    }
    if (type == "quasi") { return pass(quasi, me); }
    if (type == ";") return;
    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
  }
  function quasi(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasi);
    return cont(expression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expressionNoComma);
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
      return cont(afterprop);
    } else if (type == "number" || type == "string") {
      cx.marked = jsonldMode ? "property" : (cx.style + " property");
      return cont(afterprop);
    } else if (type == "jsonld-keyword") {
      return cont(afterprop);
    } else if (type == "[") {
      return cont(expression, expect("]"), afterprop);
    }
  }
  function getterSetter(type) {
    if (type != "variable") return pass(afterprop);
    cx.marked = "property";
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == ":") return cont(expressionNoComma);
    if (type == "(") return pass(functiondef);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(what, proceed);
      }
      if (type == end) return cont();
      return cont(expect(end));
    }
    return function(type) {
      if (type == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i < arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type) {
    if (isTS && type == ":") return cont(typedef);
  }
  function typedef(type) {
    if (type == "variable"){cx.marked = "variable-3"; return cont();}
  }
  function vardef() {
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (type == "variable") { register(value); return cont(); }
    if (type == "[") return contCommasep(pattern, "]");
    if (type == "{") return contCommasep(proppattern, "}");
  }
  function proppattern(type, value) {
    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == "variable") cx.marked = "property";
    return cont(expect(":"), pattern, maybeAssign);
  }
  function maybeAssign(_type, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == ",") return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
  }
  function forspec(type) {
    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef, expect(";"), forspec2);
    if (type == ";") return cont(forspec2);
    if (type == "variable") return cont(formaybeinof);
    return pass(expression, expect(";"), forspec2);
  }
  function formaybeinof(_type, value) {
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == ";") return cont(forspec3);
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return pass(expression, expect(";"), forspec3);
  }
  function forspec3(type) {
    if (type != ")") cont(expression);
  }
  function functiondef(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext);
  }
  function funarg(type) {
    if (type == "spread") return cont(funarg);
    return pass(pattern, maybetype);
  }
  function className(type, value) {
    if (type == "variable") {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(type, value) {
    if (value == "extends") return cont(expression, classNameAfter);
    if (type == "{") return cont(pushlex("}"), classBody, poplex);
  }
  function classBody(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(classGetterSetter, functiondef, classBody);
      return cont(functiondef, classBody);
    }
    if (value == "*") {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (type == ";") return cont(classBody);
    if (type == "}") return cont();
  }
  function classGetterSetter(type) {
    if (type != "variable") return pass();
    cx.marked = "property";
    return cont();
  }
  function afterModule(type, value) {
    if (type == "string") return cont(statement);
    if (type == "variable") { register(value); return cont(maybeFrom); }
  }
  function afterExport(_type, value) {
    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
    return pass(statement);
  }
  function afterImport(type) {
    if (type == "string") return cont();
    return pass(importSpec, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == "{") return contCommasep(importSpec, "}");
    if (type == "variable") register(value);
    return cont();
  }
  function maybeFrom(_type, value) {
    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == "]") return cont();
    return pass(expressionNoComma, maybeArrayComprehension);
  }
  function maybeArrayComprehension(type) {
    if (type == "for") return pass(comprehension, expect("]"));
    if (type == ",") return cont(commasep(maybeexpressionNoComma, "]"));
    return pass(commasep(expressionNoComma, "]"));
  }
  function comprehension(type) {
    if (type == "for") return cont(forspec, comprehension);
    if (type == "if") return cont(expression, comprehension);
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: "sof",
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars && {vars: parserConfig.localVars},
        indented: 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse) break;
      }
      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    lineComment: jsonMode ? null : "//",
    fold: "brace",

    helperType: jsonMode ? "json" : "javascript",
    jsonldMode: jsonldMode,
    jsonMode: jsonMode
  };
});

CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/x-javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});

if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old};
(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E;$.Define($$,{WebSharper:{Samples:{PouchDB:{Client:{AccordionId:$.Field(function(){return"accordion";}),Accordions:$.Field(function(){var F,G;F=d.Attr();G=i.AccordionId();return d.Div(e.ofArray([F.NewAttr("id",G),d.Attr().Class("panel-group")]));}),AdderPiglet:$.Field(function(){var H,K,P,T,U,V;H=function(I){return j.iter(function(J){return J.setOption("mode",i.LangMode(I.Language));},i.cm());};P=$.New(o,{$:0});K=l.op_LessMultiplyGreater(l.op_LessMultiplyGreater(m.Return(function(L){return function(M){return n.flip(function(N){return function(O){return i.mkSnippet(N,O);};},L,M);};}),m.Yield("")),P.Bind(m.Yield({$:0}),function(Q){return Q.$==3?P.ReturnFrom(m.Map(function(R){return{$:3,$0:R.$0};},m.Yield({$:1,$0:""}))):P.ReturnFrom(m.Map(function(S){return n.cnst(Q,S);},m.Yield({$:0})));}));T=m.Run(H,K);U=m.WithSubmit(T);V=m.Run(function(W){var X;X=p.now();i.db().put(W,q(X)).then(function(){var Z,_0,_3;Z=i.SnippetToString(W,new p(X));_0=function(_1){return r(i.Accordions().Dom).prepend(_1.Dom).ready(function(){return _1.Render();});};_3=e.rev(i.MkPanel($$.String(X),i.AccordionId(),Z,i.CodePre(W.Code)));s.iter(_0,_3);return r(".saved-modal").modal("show");});return;},U);return m.Render(function(_4){return function(_5){return function(_6){var _7,_8,_9,_,ba,bb,bc,bd,be;_7=t.CodeMirror(_4);_8=_7[0];_9=_7[1];_=e.ofArray([d.Text("Code")]);ba=d.Tags();_8.AppendN(ba.NewTag("label",_).Dom);bb={$:1,$0:_9};i.cm=function(){return bb;};bc=u.Submit(_6);bd=bc["HtmlProvider@33"];be=bc.get_Body();bd.AddClass(be,"btn btn-primary");v.OnAfterRender(function(){return _9.setValue("");},_8);return v.add(d.Div(e.ofArray([d.Attr().Class("form-horizontal")])),e.ofArray([_5.Chooser(function(bf){return n.FormControl("",u.Select(bf,e.map(function(bg){return[bg,i.LangName(bg)];},i.Languages("Other"))));}),u.RenderChoice(_5,function(bg){return t.InputOption(bg);},d.Div($.New(w,{$:0}))),_8,bc,u.ShowResult(_6,function(bi){return bi.$==1?e.map(function(bj){return d.Text(bj.get_Message());},bi.$0):$.New(w,{$:0});},d.Div($.New(w,{$:0})))]));};};},V);}),CodePre:function(bk){var bl;bl=v.add(d.Pre(e.ofArray([d.Attr().Class("prettyprint linenums")])),e.ofArray([d.Text(bk)]));v.OnAfterRender(function(){return $$.prettyPrint();},bl);return bl;},Data:$.Field(function(){return function(bn){return function(bo){var bp,bq;bp=d.Attr();bq="data-"+bn;return bp.NewAttr(bq,bo);};};}),Defaults:{PopulateDb:function(br){var bs;bs=function(){var bu,bv;bu=n["Promise`1.ToAsync"](br.info());bv=function(bw){var bx,by,bA,bB;if(bw.doc_count===0){bx=x.codes();by=e.map($.Tupled(function(bz){return n["Promise`1.ToAsync"](br.put(i.mkSnippet(bz[0],bz[1]),$$.String(p.now())));}),bx);bA=y.Parallel(by);return bA;}else{bB=[];return y.Return(bB);}};return y.Bind(bu,bv);};return n.op_BarMultiplyGreater(y.Delay(bs),function(){});},codes:$.Field(function(){return e.ofArray([[{$:0},n["String.StripMargin"]("\n                        |fibs :: [Integer]\n                        |fibs = 0 : scanl (+) 1 fibs\n                        |\n                        |main = print (take 10 fibs)","|")],[{$:1},n["String.StripMargin"]("\n                        |object Main extends App {\n                        |    val fibs: Stream[BigInt] = BigInt(0) #:: fibs.scan(BigInt(1))(_ + _)\n                        |    fibs take 10 foreach println\n                        |}","|")],[{$:2},n["String.StripMargin"]("\n                        #let fibs =\n                        #    let rec helper a b =\n                        #        seq {\n                        #            yield a;\n                        #            yield! helper b (a + b)\n                        #        }\n                        #    helper 0 1\n                        #\n                        #fibs\n                        #|> Seq.take 10\n                        #|> Seq.iter (printfn \"%d\")","#")]]);})},LangMode:function(bD){return bD.$==1?"text/x-scala":bD.$==2?"text/x-ocaml":bD.$==3?bD.$0.toLowerCase():"text/x-haskell";},LangName:function(bE){return bE.$==1?"Scala":bE.$==2?"F#":bE.$==3?bE.$0:"Haskell";},Languages:function(bF){return e.ofArray([{$:0},{$:1},{$:2},{$:3,$0:bF}]);},Main:$.Field(function(){var bG,bN,bO;bG=function(){var bI,bJ;bI=x.PopulateDb(i.db());bJ=function(){var bL,bM;bM=d.Attr();bL=v.add(d.Div(e.ofArray([bM.NewAttr("style","margin: 0 auto; width: 50%; min-width: 400px")])),e.ofArray([i.AdderPiglet(),i.Accordions()]));i.RefreshSnippets(i.Accordions());bL.AppendTo("container");return y.Return(null);};return y.Bind(bI,bJ);};bN=y.Delay(bG);bO={$:0};return y.Start(bN,bO);}),MkPanel:function(bP,bQ,bR,bS){var bT,bU,bV;bT=d.Attr();bU="#"+bP;bV=d.Attr();return e.ofArray([v.add(d.Div(e.ofArray([d.Attr().Class("panel-heading")])),e.ofArray([v.add(d.H4(e.ofArray([d.Attr().Class("panel-title")])),e.ofArray([v.add(d.A(e.ofArray([((i.Data())("toggle"))("collapse"),((i.Data())("parent"))(bQ),bT.NewAttr("href",bU)])),e.ofArray([d.Text(bR)]))]))])),v.add(d.Div(e.ofArray([bV.NewAttr("id",bP),d.Attr().Class("panel-collapse collapse")])),e.ofArray([v.add(d.Div(e.ofArray([d.Attr().Class("panel-body")])),e.ofArray([bS]))]))]);},RefreshSnippets:function(bW){var bX,bY,b1;bY=function(bZ){return bW.AppendI(bZ);};bX=n.op_BarMultiplyGreater(i.RenderSnippets(),function(b0){return s.iter(bY,b0);});b1={$:0};return y.Start(bX,b1);},RenderSnippets:$.Field(function(){var b2;b2=function(){var b4,b5;b4=n["Promise`1.ToAsync"](i.db().allDocs({include_docs:true,descending:true}));b5=function(b6){var b7,b8;b7=b6.rows;b8=e.concat(e.map(function(b9){var b_;b_=i.SnippetToString(b9.doc,new p($$.parseInt(b9.id,10)));return i.MkPanel(b9.id,i.AccordionId(),b_,i.CodePre(b9.doc.Code));},e.ofArray(b7)));return y.Return(b8);};return y.Bind(b4,b5);};return y.Delay(b2);}),SnippetToString:function(b$,ca){return i.LangName(b$.Language)+" - "+ca.toLocaleString();},cm:$.Field(function(){return{$:0};}),db:$.Field(function(){return new z("snippetdb");}),mkSnippet:function(cb,cc){return{Language:cb,Code:cc};}},Controls:{CodeMirror:function(cd){var ce,cf,ci;ce=d.Div($.New(w,{$:0}));cf=new A(function(cg){return v.OnAfterRender(function(ch){return ch.AppendN(cg);},ce);},{lineNumbers:true});ci=cd.get_Latest();if(ci.$==1){}else{cf.setValue(ci.$0);}cd.Subscribe(function(cj){var ck;if(cj.$==1){return null;}else{ck=cj.$0;return cf.getValue()!==ck?cf.setValue(ck):null;}});cf.on("change",$.Tupled(function(cl){return cd.Trigger($.New(B,{$:0,$0:cl[0].getValue()}));}));return[ce,cf];},InputOption:function(cm){var cn,co,cr,cu,cx,cy;cn=d.Div($.New(w,{$:0}));co=function(){return function(cq){return cq;};};cr=C.Map(function(cs){return j.fold(co,"",cs);},function(ct){return{$:1,$0:ct};},cm);cu=u.input("text",function(cv){return cv;},function(cw){return cw;},cr);cx=n.FormControl("Language",cu);cy={contents:false};cm.SubscribeImmediate(function(cz){if(cz.$==0){if(cz.$0.$==1){if(!cy.contents){cn.AppendN(cx.Dom);cy.contents=true;return;}else{return null;}}else{if(cy.contents){cn["HtmlProvider@33"].Clear(cn.get_Body());cy.contents=false;return;}else{return null;}}}else{return null;}});return cn;}},Utils:{FormControl:function(cA,cB){var cC,cD,cE,cF,cG,cH;cC=cB["HtmlProvider@33"];cD=cB.get_Body();cC.AddClass(cD,"form-control");cF=d.Attr();cG=cB.get_Id();cE=e.ofArray([cF.NewAttr("for",cG),d.Text(cA)]);cH=d.Tags();return v.add(d.Div(e.ofArray([d.Attr().Class("form-group")])),e.ofArray([cH.NewTag("label",cE),cB]));},"Promise`1.ToAsync":function(cI){var cJ;cJ=$.Tupled(function(cK){cI.then(cK[0],cK[1]);});return y.FromContinuations(cJ);},"String.StripMargin":function(cL,cM){var cN;cN=[13,10];return D.concat("\n",E.map(function(cO){var cP;cP=cO.indexOf(cM);return cP>=0?cO.substring(cP+1):cO;},D.SplitChars(cL,cN,1)));},cnst:function(cQ){return cQ;},flip:function(cS,cT,cU){return(cS(cU))(cT);},op_BarMultiplyGreater:function(cV,cW){var cX;cX=function(){var cZ;cZ=function(c0){var c1;c1=cW(c0);return y.Return(c1);};return y.Bind(cV,cZ);};return y.Delay(cX);}}}}}});$.OnInit(function(){a=$.Safe($$.IntelliFactory.WebSharper);b=$.Safe(a.Html);c=$.Safe(b.Client);d=$.Safe(c.Default);e=$.Safe(a.List);f=$.Safe($$.WebSharper);g=$.Safe(f.Samples);h=$.Safe(g.PouchDB);i=$.Safe(h.Client);j=$.Safe(a.Option);k=$.Safe(a.Piglets);l=$.Safe(k.Pervasives);m=$.Safe(k.Piglet1);n=$.Safe(h.Utils);o=$.Safe(m.Builder);p=$.Safe($$.Date);q=$.Safe($$.String);r=$.Safe($$.jQuery);s=$.Safe(a.Seq);t=$.Safe(h.Controls);u=$.Safe(k.Controls);v=$.Safe(c.Operators);w=$.Safe(e.T);x=$.Safe(i.Defaults);y=$.Safe(a.Concurrency);z=$.Safe($$.PouchDB);A=$.Safe($$.CodeMirror);B=$.Safe(k.Result);C=$.Safe(k.Stream1);D=$.Safe(a.Strings);return E=$.Safe(a.Arrays);});$.OnLoad(function(){i.db();i.cm();i.RenderSnippets();i.Main();x.codes();i.Data();i.AdderPiglet();i.Accordions();i.AccordionId();return;});}());


if (typeof IntelliFactory !=='undefined')
  IntelliFactory.Runtime.Start();
