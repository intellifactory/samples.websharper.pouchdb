try{Object.defineProperty(Error.prototype,"message",{enumerable:!0})}catch(e){}var IntelliFactory={Runtime:{Class:function(n,t){function i(){}i.prototype=n;for(var r in t)i[r]=t[r];return i},Define:function(n,t){function i(n,t){var u,f,e;for(u in t)if(f=typeof n[u],e=typeof t[u],f=="object"&&e=="object")i(n[u],t[u]);else if(f=="undefined"||r)n[u]=t[u];else throw new Error("Name conflict: "+u);}var r=!!this.overwrite;i(n,t)},DeleteEmptyFields:function(n,t){for(var r,i=0;i<t.length;i++)r=t[i],n[r]===undefined&&delete n[r];return n},Field:function(n){var t,i=!1;return function(){return i||(i=!0,t=n()),t}},GetOptional:function(n){return n===undefined?{$:0}:{$:1,$0:n}},New:function(n,t){var i=new n;for(var r in t)r in i||(i[r]=t[r]);return i},NewObject:function(n){for(var i={},t=0;t<n.length;t++)i[n[t][0]]=n[t][1];return i},OnInit:function(n){"init"in this||(this.init=[]);this.init.push(n)},OnLoad:function(n){"load"in this||(this.load=[]);this.load.push(n)},Inherit:function(n,t){var r=n.prototype,i;n.prototype=new t;for(i in r)n.prototype[i]=r[i]},Safe:function(n){return n===undefined?{}:n},SetOptional:function(n,t,i){i.$==0?delete n[t]:n[t]=i.$0},Start:function(){function n(n){for(var t=0;t<n.length;t++)n[t]()}"init"in this&&(n(this.init),this.init=[]);"load"in this&&(n(this.load),this.load=[])},Bind:function(n){return function(){return n.apply(this,arguments)}},CreateFuncWithArgs:function(n){return function(){return n(Array.prototype.slice.call(arguments))}},CreateFuncWithOnlyThis:function(n){return function(){return n(this)}},CreateFuncWithThis:function(n){return function(){return n(this).apply(null,arguments)}},CreateFuncWithThisArgs:function(n){return function(){return n(this)(Array.prototype.slice.call(arguments))}},CreateFuncWithRest:function(n,t){return function(){return t(Array.prototype.slice.call(arguments,0,n).concat([Array.prototype.slice.call(arguments,n)]))}},CreateFuncWithArgsRest:function(n,t){return function(){return t([Array.prototype.slice.call(arguments,0,n),Array.prototype.slice.call(arguments,n)])}},UnionByType:function(n,t,i){for(var u,f=typeof t,r=0;r<n.length;r++)if(u=n[r],typeof u=="number"){if(Array.isArray(t)&&(u==0||t.length==u))return{$:r,$0:t}}else if(u==f)return{$:r,$0:t};if(!i)throw new Error("Type not expected for creating Choice value.");}}};Date.now||(Date.now=function(){return(new Date).getTime()});
var JSON;JSON||(JSON={}),function(){"use strict";function i(n){return n<10?"0"+n:n}function f(n){return o.lastIndex=0,o.test(n)?'"'+n.replace(o,function(n){var t=s[n];return typeof t=="string"?t:"\\u"+("0000"+n.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+n+'"'}function r(i,e){var s,l,h,a,v=n,c,o=e[i];o&&typeof o=="object"&&typeof o.toJSON=="function"&&(o=o.toJSON(i));typeof t=="function"&&(o=t.call(e,i,o));switch(typeof o){case"string":return f(o);case"number":return isFinite(o)?String(o):"null";case"boolean":case"null":return String(o);case"object":if(!o)return"null";if(n+=u,c=[],Object.prototype.toString.apply(o)==="[object Array]"){for(a=o.length,s=0;s<a;s+=1)c[s]=r(s,o)||"null";return h=c.length===0?"[]":n?"[\n"+n+c.join(",\n"+n)+"\n"+v+"]":"["+c.join(",")+"]",n=v,h}if(t&&typeof t=="object")for(a=t.length,s=0;s<a;s+=1)typeof t[s]=="string"&&(l=t[s],h=r(l,o),h&&c.push(f(l)+(n?": ":":")+h));else for(l in o)Object.prototype.hasOwnProperty.call(o,l)&&(h=r(l,o),h&&c.push(f(l)+(n?": ":":")+h));return h=c.length===0?"{}":n?"{\n"+n+c.join(",\n"+n)+"\n"+v+"}":"{"+c.join(",")+"}",n=v,h}}typeof Date.prototype.toJSON!="function"&&(Date.prototype.toJSON=function(){return isFinite(this.valueOf())?this.getUTCFullYear()+"-"+i(this.getUTCMonth()+1)+"-"+i(this.getUTCDate())+"T"+i(this.getUTCHours())+":"+i(this.getUTCMinutes())+":"+i(this.getUTCSeconds())+"Z":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(){return this.valueOf()});var e=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,o=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,n,u,s={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},t;typeof JSON.stringify!="function"&&(JSON.stringify=function(i,f,e){var o;if(n="",u="",typeof e=="number")for(o=0;o<e;o+=1)u+=" ";else typeof e=="string"&&(u=e);if(t=f,f&&typeof f!="function"&&(typeof f!="object"||typeof f.length!="number"))throw new Error("JSON.stringify");return r("",{"":i})});typeof JSON.parse!="function"&&(JSON.parse=function(n,t){function r(n,i){var f,e,u=n[i];if(u&&typeof u=="object")for(f in u)Object.prototype.hasOwnProperty.call(u,f)&&(e=r(u,f),e!==undefined?u[f]=e:delete u[f]);return t.call(n,i,u)}var i;if(n=String(n),e.lastIndex=0,e.test(n)&&(n=n.replace(e,function(n){return"\\u"+("0000"+n.charCodeAt(0).toString(16)).slice(-4)})),/^[\],:{}\s]*$/.test(n.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,"")))return i=eval("("+n+")"),typeof t=="function"?r({"":i},""):i;throw new SyntaxError("JSON.parse");})}();
(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z;$.Define($$,{WebSharper:{AggregateException:$.Class({},{New:function(_0){return $.New(this,a.New1("One or more errors occurred.",_0));},New1:function(_1){return $.New(this,b.New1(_1));}}),ArgumentException:$.Class({},{New:function(){return $.New(this,c.New1("Value does not fall within the expected range."));},New1:function(_3){return $.New(this,b.New1(_3));}}),Arrays:{average:function(_4){return d(e.sum(_4))/d(_4.length);},averageBy:function(_5,_6){return d(e.sumBy(_5,_6))/d(_6.length);},blit:function(_7,_8,_9,_,ba){var bb;e.checkRange(_7,_8,ba);e.checkRange(_9,_,ba);for(bb=0;bb<=ba-1;bb++){e.set(_9,_+bb,e.get(_7,_8+bb));}return;},checkBounds:function(bb,bc){return(bc<0?true:bc>=bb.length)?f.FailWith("Index was outside the bounds of the array."):null;},checkBounds2D:function(bd,be,bf){return(((be<0?true:bf<0)?true:be>=bd.length)?true:bf>=(bd.length?bd[0].length:0))?f.Raise(g.New()):null;},checkLength:function(bg,bh){return bg.length!==bh.length?f.FailWith("Arrays differ in length."):null;},checkRange:function(bi,bj,bk){return((bk<0?true:bj<0)?true:bi.length<bj+bk)?f.FailWith("Index was outside the bounds of the array."):null;},choose:function(bl,bm){var bn,bo,bp,bq,br;bn=[];for(bo=0;bo<=bm.length-1;bo++){bp=bl(e.get(bm,bo));if(bp.$==0){bq=null;}else{br=bp.$0;bq=bn.push(br);}}return bn;},collect:function(bs,bt){return h.prototype.concat.apply([],e.map(bs,bt));},concat:function(bu){return h.prototype.concat.apply([],e.ofSeq(bu));},create:function(bv,bw){var bx,by;bx=h(bv);for(by=0;by<=bv-1;by++){e.set(bx,by,bw);}return bx;},create2D:function(bz){var bA,bC,bD;bA=function(bB){return e.ofSeq(bB);};bC=i.map(bA,bz);bD=e.ofSeq(bC);bD.dims=2;return bD;},exists2:function(bE,bF,bG){e.checkLength(bF,bG);return i.exists2(bE,bF,bG);},fill:function(bH,bI,bJ,bK){var bL;e.checkRange(bH,bI,bJ);for(bL=bI;bL<=bI+bJ-1;bL++){e.set(bH,bL,bK);}return;},filter:function(bM,bN){var bO,bP;bO=[];for(bP=0;bP<=bN.length-1;bP++){bM(e.get(bN,bP))?bO.push(e.get(bN,bP)):null;}return bO;},find:function(bQ,bR){var bS,bT,bU;bS=e.tryFind(bQ,bR);if(bS.$==0){bT=f.FailWith("KeyNotFoundException");}else{bU=bS.$0;bT=bU;}return bT;},findINdex:function(bV,bW){var bX,bY,bZ;bX=e.tryFindIndex(bV,bW);if(bX.$==0){bY=f.FailWith("KeyNotFoundException");}else{bZ=bX.$0;bY=bZ;}return bY;},fold:function(b0,b1,b2){var b3,b4;b3=b1;for(b4=0;b4<=b2.length-1;b4++){b3=(b0(b3))(e.get(b2,b4));}return b3;},fold2:function(b5,b6,b7,b8){var b9,b_;e.checkLength(b7,b8);b9=b6;for(b_=0;b_<=b7.length-1;b_++){b9=((b5(b9))(e.get(b7,b_)))(e.get(b8,b_));}return b9;},foldBack:function(b$,ca,cb){var cc,cd,ce;cc=cb;cd=ca.length;for(ce=1;ce<=cd;ce++){cc=(b$(e.get(ca,cd-ce)))(cc);}return cc;},foldBack2:function(cf,cg,ch,ci){var cj,ck,cl;e.checkLength(cg,ch);cj=cg.length;ck=ci;for(cl=1;cl<=cj;cl++){ck=((cf(e.get(cg,cj-cl)))(e.get(ch,cj-cl)))(ck);}return ck;},forall2:function(cm,cn,co){e.checkLength(cn,co);return i.forall2(cm,cn,co);},get:function(cp,cq){e.checkBounds(cp,cq);return cp[cq];},get2D:function(cr,cs,ct){e.checkBounds2D(cr,cs,ct);return cr[cs][ct];},init:function(cu,cv){var cw,cx;cu<0?f.FailWith("Negative size given."):null;cw=h(cu);for(cx=0;cx<=cu-1;cx++){e.set(cw,cx,cv(cx));}return cw;},iter:function(cy,cz){var cA;for(cA=0;cA<=cz.length-1;cA++){cy(e.get(cz,cA));}return;},iter2:function(cB,cC,cD){var cE;e.checkLength(cC,cD);for(cE=0;cE<=cC.length-1;cE++){(cB(e.get(cC,cE)))(e.get(cD,cE));}return;},iteri:function(cF,cG){var cH;for(cH=0;cH<=cG.length-1;cH++){(cF(cH))(e.get(cG,cH));}return;},iteri2:function(cI,cJ,cK){var cL;e.checkLength(cJ,cK);for(cL=0;cL<=cJ.length-1;cL++){((cI(cL))(e.get(cJ,cL)))(e.get(cK,cL));}return;},length:function(cM){var cN;cN=cM.dims;return cN===2?cM.length*cM.length:cM.length;},map:function(cO,cP){var cQ,cR;cQ=h(cP.length);for(cR=0;cR<=cP.length-1;cR++){e.set(cQ,cR,cO(e.get(cP,cR)));}return cQ;},map2:function(cS,cT,cU){var cV,cW;e.checkLength(cT,cU);cV=h(cU.length);for(cW=0;cW<=cU.length-1;cW++){e.set(cV,cW,(cS(e.get(cT,cW)))(e.get(cU,cW)));}return cV;},mapi:function(cX,cY){var cZ,c0;cZ=h(cY.length);for(c0=0;c0<=cY.length-1;c0++){e.set(cZ,c0,(cX(c0))(e.get(cY,c0)));}return cZ;},mapi2:function(c1,c2,c3){var c4,c5;e.checkLength(c2,c3);c4=h(c2.length);for(c5=0;c5<=c2.length-1;c5++){e.set(c4,c5,((c1(c5))(e.get(c2,c5)))(e.get(c3,c5)));}return c4;},max:function(c6){return e.reduce(function(c7){return function(c8){return f.Max(c7,c8);};},c6);},maxBy:function(c9,c_){return e.reduce(function(c$){return function(da){return j.Compare(c9(c$),c9(da))===1?c$:da;};},c_);},min:function(db){return e.reduce(function(dc){return function(dd){return f.Min(dc,dd);};},db);},minBy:function(de,df){return e.reduce(function(dg){return function(dh){return j.Compare(de(dg),de(dh))===-1?dg:dh;};},df);},nonEmpty:function(di){return di.length===0?f.FailWith("The input array was empty."):null;},ofSeq:function(dj){var dk,dl;dk=[];dl=k.Get(dj);while(dl.MoveNext()){dk.push(dl.get_Current());}return dk;},partition:function(dm,dn){var _do,dp,dq;_do=[];dp=[];for(dq=0;dq<=dn.length-1;dq++){dm(e.get(dn,dq))?_do.push(e.get(dn,dq)):dp.push(e.get(dn,dq));}return[_do,dp];},permute:function(dr,ds){var dt,du;dt=h(ds.length);for(du=0;du<=ds.length-1;du++){e.set(dt,dr(du),e.get(ds,du));}return dt;},pick:function(dv,dw){var dx,dy,dz;dx=e.tryPick(dv,dw);if(dx.$==0){dy=f.FailWith("KeyNotFoundException");}else{dz=dx.$0;dy=dz;}return dy;},reduce:function(dA,dB){var dC,dD;e.nonEmpty(dB);dC=e.get(dB,0);for(dD=1;dD<=dB.length-1;dD++){dC=(dA(dC))(e.get(dB,dD));}return dC;},reduceBack:function(dE,dF){var dG,dH,dI;e.nonEmpty(dF);dG=dF.length;dH=e.get(dF,dG-1);for(dI=2;dI<=dG;dI++){dH=(dE(e.get(dF,dG-dI)))(dH);}return dH;},reverse:function(dJ,dK,dL){var dM;dM=e.sub(dJ,dK,dL).slice().reverse();return e.blit(dM,0,dJ,dK,e.length(dM));},scan:function(dN,dO,dP){var dQ,dR;dQ=h(1+dP.length);e.set(dQ,0,dO);for(dR=0;dR<=dP.length-1;dR++){e.set(dQ,dR+1,(dN(e.get(dQ,dR)))(e.get(dP,dR)));}return dQ;},scanBack:function(dS,dT,dU){var dV,dW,dX;dV=dT.length;dW=h(1+dV);e.set(dW,dV,dU);for(dX=0;dX<=dV-1;dX++){e.set(dW,dV-dX-1,(dS(e.get(dT,dV-dX-1)))(e.get(dW,dV-dX)));}return dW;},set:function(dY,dZ,d0){e.checkBounds(dY,dZ);dY[dZ]=d0;return;},set2D:function(d1,d2,d3,d4){e.checkBounds2D(d1,d2,d3);d1[d2][d3]=d4;return;},setSub:function(d5,d6,d7,d8){var d9;for(d9=0;d9<=d7-1;d9++){e.set(d5,d6+d9,e.get(d8,d9));}return;},setSub2D:function(d_,d$,ea,eb,ec,ed){var ee,ef;for(ee=0;ee<=eb-1;ee++){for(ef=0;ef<=ec-1;ef++){e.set2D(d_,d$+ee,ea+ef,e.get2D(ed,ee,ef));}}return;},sort:function(eg){return e.sortBy(function(eh){return eh;},eg);},sortBy:function(ei,ej){return ej.slice().sort(function(ek,el){return f.Compare(ei(ek),ei(el));});},sortInPlace:function(em){return e.sortInPlaceBy(function(en){return en;},em);},sortInPlaceBy:function(eo,ep){return ep.sort(function(eq,er){return f.Compare(eo(eq),eo(er));});},sortInPlaceWith:function(es,et){return et.sort(function(eu,ev){return(es(eu))(ev);});},sortWith:function(ew,ex){return ex.slice().sort(function(ey,ez){return(ew(ey))(ez);});},sub:function(eA,eB,eC){e.checkRange(eA,eB,eC);return eA.slice(eB,eB+eC);},sub2D:function(eD,eE,eF,eG,eH){var eI,eJ,eK,eL,eM;eI=eG<0?0:eG;eJ=eH<0?0:eH;eK=e.zeroCreate2D(eI,eJ);for(eL=0;eL<=eI-1;eL++){for(eM=0;eM<=eJ-1;eM++){e.set2D(eK,eL,eM,e.get2D(eD,eE+eL,eF+eM));}}return eK;},sum:function($arr){var $0=this,$this=this;var sum=0;for(var i=0;i<$arr.length;i++)sum+=$arr[i];return sum;},sumBy:function($f,$arr){var $0=this,$this=this;var sum=0;for(var i=0;i<$arr.length;i++)sum+=$f($arr[i]);return sum;},tryFind:function(eN,eO){var eP,eQ;eP={$:0};eQ=0;while(eQ<eO.length?eP.$==0:false){eN(e.get(eO,eQ))?eP={$:1,$0:e.get(eO,eQ)}:null;eQ=eQ+1;}return eP;},tryFindIndex:function(eR,eS){var eT,eU;eT={$:0};eU=0;while(eU<eS.length?eT.$==0:false){eR(e.get(eS,eU))?eT={$:1,$0:eU}:null;eU=eU+1;}return eT;},tryPick:function(eV,eW){var eX,eY,eZ;eX={$:0};eY=0;while(eY<eW.length?eX.$==0:false){eZ=eV(e.get(eW,eY));eZ.$==1?eX=eZ:null;eY=eY+1;}return eX;},unzip:function(e0){var e1,e2,e3,e4,e5,e6;e1=[];e2=[];for(e3=0;e3<=e0.length-1;e3++){e4=e.get(e0,e3);e5=e4[1];e6=e4[0];e1.push(e6);e2.push(e5);}return[e1,e2];},unzip3:function(e7){var e8,e9,e_,e$,fa,fb,fc,fd;e8=[];e9=[];e_=[];for(e$=0;e$<=e7.length-1;e$++){fa=e.get(e7,e$);fb=fa[2];fc=fa[1];fd=fa[0];e8.push(fd);e9.push(fc);e_.push(fb);}return[e8,e9,e_];},zeroCreate2D:function(fe,ff){var fg;fg=e.init(fe,function(){return h(ff);});fg.dims=2;return fg;},zip:function(fi,fj){var fk,fl;e.checkLength(fi,fj);fk=h(fi.length);for(fl=0;fl<=fi.length-1;fl++){e.set(fk,fl,[e.get(fi,fl),e.get(fj,fl)]);}return fk;},zip3:function(fm,fn,fo){var fp,fq;e.checkLength(fm,fn);e.checkLength(fn,fo);fp=h(fm.length);for(fq=0;fq<=fm.length-1;fq++){e.set(fp,fq,[e.get(fm,fq),e.get(fn,fq),e.get(fo,fq)]);}return fp;}},Arrays2D:{copy:function(fr){return l.init(fr.length,fr.length?fr[0].length:0,function(fs){return function(ft){return e.get2D(fr,fs,ft);};});},init:function(fu,fv,fw){var fx,fy,fz;fx=e.zeroCreate2D(fu,fv);for(fy=0;fy<=fu-1;fy++){for(fz=0;fz<=fv-1;fz++){e.set2D(fx,fy,fz,(fw(fy))(fz));}}return fx;},iter:function(fA,fB){var fC,fD,fE,fF;fC=fB.length;fD=fB.length?fB[0].length:0;for(fE=0;fE<=fC-1;fE++){for(fF=0;fF<=fD-1;fF++){fA(e.get2D(fB,fE,fF));}}return;},iteri:function(fG,fH){var fI,fJ,fK,fL;fI=fH.length;fJ=fH.length?fH[0].length:0;for(fK=0;fK<=fI-1;fK++){for(fL=0;fL<=fJ-1;fL++){((fG(fK))(fL))(e.get2D(fH,fK,fL));}}return;},map:function(fM,fN){return l.init(fN.length,fN.length?fN[0].length:0,function(fO){return function(fP){return fM(e.get2D(fN,fO,fP));};});},mapi:function(fQ,fR){return l.init(fR.length,fR.length?fR[0].length:0,function(fS){return function(fT){return((fQ(fS))(fT))(e.get2D(fR,fS,fT));};});}},AsyncProxy:$.Class({},{get_CancellationToken:function(){return m.GetCT();},get_DefaultCancellationToken:function(){return(m.defCTS())[0];}}),CancellationTokenSource:$.Class({Cancel:function(){var fU,fV,fZ,f0;if(!this.c){this.c=true;fV=function(fW){var fX,fY;try{fW(null);fX={$:0};}catch(fY){fX={$:1,$0:fY};}return fX;};fZ=this.r;f0=e.choose(fV,fZ);fU=e.length(f0)>0?f.Raise(a.New(f0)):null;}else{fU=null;}return fU;},Cancel1:function(f1){var f2,f3,f4,f6;if(!f1){f2=this.Cancel();}else{if(!this.c){this.c=true;f4=function(f5){return f5(null);};f6=this.r;f3=e.iter(f4,f6);}else{f3=null;}f2=f3;}return f2;},CancelAfter:function(f7){var f8,f9,f$,gb=this;if(!this.c){f9=this.pending;n.iter(function(f_){return o(f_);},f9);f$=p(function(){return gb.Cancel();},f7);f8=void(this.pending={$:1,$0:f$});}else{f8=null;}return f8;},get_IsCancellationRequested:function(){return this.c;}},{CreateLinkedTokenSource:function(gc,gd){return q.CreateLinkedTokenSource1([gc,gd]);},CreateLinkedTokenSource1:function(ge){var gf,gg;gf=q.New();gg=function(gh){var gi;gi=m.Register(gh,function(){return function(){return gf.Cancel();}();});return;};return e.iter(gg,ge);},New:function(){var gl;gl=$.New(this,{});gl.c=false;gl.pending={$:0};gl.r=[];return gl;}}),Char:$.Class({},{GetNumericValue:function(gm){return(gm>=48?gm<=57:false)?d(gm)-d(48):-1;},IsControl:function(gn){return(gn>=0?gn<=31:false)?true:gn>=128?gn<=159:false;},IsDigit:function(go){return go>=48?go<=57:false;},IsLetter:function(gp){return(gp>=65?gp<=90:false)?true:gp>=97?gp<=122:false;},IsLetterOrDigit:function(gq){return r.IsLetter(gq)?true:r.IsDigit(gq);},IsLower:function(gr){return gr>=97?gr<=122:false;},IsUpper:function(gs){return gs>=65?gs<=90:false;},IsWhiteSpace:function($c){var $0=this,$this=this;return $$.String.fromCharCode($c).match(/\s/)!==null;},Parse:function(gt){return gt.length===1?gt.charCodeAt(0):f.FailWith("String must be exactly one character long.");}}),Concurrency:{AwaitEvent:function(gu){var gv;gv=function(gw){var gx,gy,gz,gA,gB,gC;gx=function(){return s.subscribeTo(gu,function(gE){var gF;t.Force(gy).Dispose();t.Force(gA).Dispose();gF=function(){return gw.k.call(null,{$:0,$0:gE});};return m.scheduler().Fork(gF);});};gy=t.Create(gx);gz=function(){return m.Register(gw.ct,function(){var gJ;t.Force(gy).Dispose();gJ=function(){return gw.k.call(null,{$:2,$0:u.New()});};return m.scheduler().Fork(gJ);});};gA=t.Create(gz);gB=t.Force(gy);gC=t.Force(gA);return null;};return m.checkCancel(gv);},Bind:function(gL,gM){var gN;gN=function(gO){return gL({k:function(gP){var gQ,gR,gS,gW;if(gP.$==0){gR=gP.$0;gS=function(){var gU,gV;try{gU=(gM(gR))(gO);}catch(gV){gU=gO.k.call(null,{$:1,$0:gV});}return gU;};gQ=m.scheduler().Fork(gS);}else{gW=function(){return gO.k.call(null,gP);};gQ=m.scheduler().Fork(gW);}return gQ;},ct:gO.ct});};return m.checkCancel(gN);},Catch:function(gY){var gZ;gZ=function(g0){var g1,g6;try{g1=gY({k:function(g2){var g3,g4,g5;if(g2.$==0){g4=g2.$0;g3=g0.k.call(null,{$:0,$0:{$:0,$0:g4}});}else{if(g2.$==1){g5=g2.$0;g3=g0.k.call(null,{$:0,$0:{$:1,$0:g5}});}else{g3=g0.k.call(null,g2);}}return g3;},ct:g0.ct});}catch(g6){g1=g0.k.call(null,{$:0,$0:{$:1,$0:g6}});}return g1;};return m.checkCancel(gZ);},Combine:function(g7,g8){return m.Bind(g7,function(){return g8;});},Delay:function(g_){var g$;g$=function(ha){var hb,hc;try{hb=(g_(null))(ha);}catch(hc){hb=ha.k.call(null,{$:1,$0:hc});}return hb;};return m.checkCancel(g$);},For:function(hd,he){var hf;hf=k.Get(hd);return m.While(function(){return hf.MoveNext();},m.Delay(function(){return he(hf.get_Current());}));},FromContinuations:function(hi){var hj;hj=function(hk){var hl,hm;hl=[false];hm=function(hn){var ho;if(hl[0]){ho=f.FailWith("A continuation provided by Async.FromContinuations was invoked multiple times");}else{hl[0]=true;ho=m.scheduler().Fork(hn);}return ho;};return hi([function(hp){return hm(function(){return hk.k.call(null,{$:0,$0:hp});});},function(hr){return hm(function(){return hk.k.call(null,{$:1,$0:hr});});},function(ht){return hm(function(){return hk.k.call(null,{$:2,$0:ht});});}]);};return m.checkCancel(hj);},GetCT:$.Field(function(){var hv;hv=function(hw){return hw.k.call(null,{$:0,$0:hw.ct});};return m.checkCancel(hv);}),Ignore:function(hx){return m.Bind(hx,function(){return m.Return(null);});},OnCancel:function(hz){var hA;hA=function(hB){return hB.k.call(null,{$:0,$0:m.Register(hB.ct,hz)});};return m.checkCancel(hA);},Parallel:function(hC){var hD,hE,hF;hD=e.ofSeq(hC);if(e.length(hD)===0){hE=m.Return([]);}else{hF=function(hG){var hH,hI,hJ,hK;hH=hD.length;hI=[hH];hJ=e.create(hH,undefined);hK=function(hL){return function(hM){var hN,hO,hP,hQ,hR,hS,hT,hU,hV;hN=[hI[0],hM];if(hN[0]===0){hO=null;}else{if(hN[0]===1){if(hN[1].$==0){hQ=hN[1].$0;e.set(hJ,hL,hQ);hI[0]=0;hP=hG.k.call(null,{$:0,$0:hJ});}else{hN[0];hR=hN[1];hI[0]=0;hP=hG.k.call(null,hR);}hO=hP;}else{if(hN[1].$==0){hT=hN[1].$0;hU=hN[0];e.set(hJ,hL,hT);hS=void(hI[0]=hU-1);}else{hN[0];hV=hN[1];hI[0]=0;hS=hG.k.call(null,hV);}hO=hS;}}return hO;};};return e.iteri(function(hW){return function(hX){var hY;hY=function(){return hX({k:hK(hW),ct:hG.ct});};return m.scheduler().Fork(hY);};},hD);};hE=m.checkCancel(hF);}return hE;},Register:function(h0,h1){var h2;h2=h0.r.push(h1)-1;return{Dispose:function(){return e.set(h0.r,h2,function(){});}};},Return:function(h5){var h6;h6=function(h7){return h7.k.call(null,{$:0,$0:h5});};return m.checkCancel(h6);},Scheduler:$.Class({Fork:function(h8){var h9,h_,ia=this;this.robin.push(h8);if(this.idle){this.idle=false;h_=p(function(){return ia.tick();},0);h9=void h_;}else{h9=null;}return h9;},tick:function(){var ib,ic,id,ie,_if,ig,ii=this;ib=v.now();ic=true;while(ic){id=this.robin.length;if(id===0){this.idle=true;ie=ic=false;}else{(this.robin.shift())(null);if(v.now()-ib>40){ig=p(function(){return ii.tick();},0);_if=ic=false;}else{_if=null;}ie=_if;}}return;}},{New:function(){var ij;ij=$.New(this,{});ij.idle=true;ij.robin=[];return ij;}}),Sleep:function(ik){var il;il=function(im){var _in,io,ip,iq,ir,is;_in=function(){return p(function(){var iv;t.Force(iq).Dispose();iv=function(){return im.k.call(null,{$:0,$0:null});};return m.scheduler().Fork(iv);},ik);};io=t.Create(_in);ip=function(){return m.Register(im.ct,function(){var iz;o(t.Force(io));iz=function(){return im.k.call(null,{$:2,$0:u.New()});};return m.scheduler().Fork(iz);});};iq=t.Create(ip);ir=t.Force(io);is=t.Force(iq);return null;};return m.checkCancel(il);},Start:function(iB,iC){return m.StartWithContinuations(iB,function(){},function(iE){var iF;iF=[iE];return w?w.log.apply(w,["WebSharper: Uncaught asynchronous exception"].concat(iF)):undefined;},function(){},iC);},StartChild:function(iH){var iI;iI=function(iJ){var iK,iL,iM,iP,iU;iK=[{$:0}];iL=[];iM=function(){return iH({k:function(iO){iK[0]={$:1,$0:iO};while(iL.length>0){(iL.shift())(iO);}return;},ct:iJ.ct});};m.scheduler().Fork(iM);iP=function(iQ){var iR,iS,iT;iR=iK[0];if(iR.$==0){iS=iL.push(iQ.k);}else{iT=iR.$0;iS=iQ.k.call(null,iT);}return iS;};iU=m.checkCancel(iP);return iJ.k.call(null,{$:0,$0:iU});};return m.checkCancel(iI);},StartWithContinuations:function(iV,iW,iX,iY,iZ){var i0,i1;i0=f.DefaultArg(iZ,(m.defCTS())[0]);i1=function(){return iV({k:function(i3){var i4,i5,i6,i7;if(i3.$==1){i5=i3.$0;i4=iX(i5);}else{if(i3.$==2){i6=i3.$0;i4=iY(i6);}else{i7=i3.$0;i4=iW(i7);}}return i4;},ct:i0});};return m.scheduler().Fork(i1);},TryCancelled:function(i8,i9){var i_;i_=function(i$){return i8({k:function(ja){var jb,jc;if(ja.$==2){jc=ja.$0;i9(jc);jb=i$.k.call(null,ja);}else{jb=i$.k.call(null,ja);}return jb;},ct:i$.ct});};return m.checkCancel(i_);},TryFinally:function(jd,je){var jf;jf=function(jg){return jd({k:function(jh){var ji,jj;try{je(null);ji=jg.k.call(null,jh);}catch(jj){ji=jg.k.call(null,{$:1,$0:jj});}return ji;},ct:jg.ct});};return m.checkCancel(jf);},TryWith:function(jk,jl){var jm;jm=function(jn){return jk({k:function(jo){var jp,jq,jr,js,jt;if(jo.$==0){jq=jo.$0;jp=jn.k.call(null,{$:0,$0:jq});}else{if(jo.$==1){jr=jo.$0;try{js=(jl(jr))(jn);}catch(jt){js=jn.k.call(null,jo);}jp=js;}else{jp=jn.k.call(null,jo);}}return jp;},ct:jn.ct});};return m.checkCancel(jm);},Using:function(ju,jv){return m.TryFinally(jv(ju),function(){return ju.Dispose();});},While:function(jx,jy){return jx(null)?m.Bind(jy,function(){return m.While(jx,jy);}):m.Return(null);},checkCancel:function(jA){return function(jB){return jB.ct.c?jB.k.call(null,{$:2,$0:u.New()}):jA(jB);};},defCTS:$.Field(function(){return[q.New()];}),scheduler:$.Field(function(){return x.New();})},Control:{createEvent:function(jC,jD,jE){return{AddHandler:jC,RemoveHandler:jD,Subscribe:function(jF){var jG;jG=jE(function(){return function(jI){return jF.OnNext.call(null,jI);};});jC(jG);return{Dispose:function(){return jD(jG);}};}};}},DateTimeHelpers:{AddMonths:function(jK,jL){var jM;jM=new v(jK);return(new v(jM.getFullYear(),jM.getMonth()+jL,jM.getDate(),jM.getHours(),jM.getMinutes(),jM.getSeconds(),jM.getMilliseconds())).getTime();},AddYears:function(jN,jO){var jP;jP=new v(jN);return(new v(jP.getFullYear()+jO,jP.getMonth(),jP.getDate(),jP.getHours(),jP.getMinutes(),jP.getSeconds(),jP.getMilliseconds())).getTime();},DatePortion:function(jQ){var jR;jR=new v(jQ);return(new v(jR.getFullYear(),jR.getMonth(),jR.getDate())).getTime();},TimePortion:function(jS){var jT;jT=new v(jS);return(((24*0+jT.getHours())*60+jT.getMinutes())*60+jT.getSeconds())*1000+jT.getMilliseconds();}},Enumerable:{Of:function(jU){return{GetEnumerator:jU};}},Enumerator:{Get:function(jV){return jV instanceof $$.Array?y.New(0,null,function(jW){var jX,jY;jX=jW.s;if(jX<e.length(jV)){jW.c=e.get(jV,jX);jW.s=jX+1;jY=true;}else{jY=false;}return jY;}):j.Equals(typeof jV,"string")?y.New(0,null,function(jZ){var j0,j1;j0=jZ.s;if(j0<jV.length){jZ.c=jV.charCodeAt(j0);jZ.s=j0+1;j1=true;}else{j1=false;}return j1;}):jV.GetEnumerator();},T:$.Class({MoveNext:function(){return this.n.call(null,this);},get_Current:function(){return this.c;}},{New:function(j2,j3,j4){var j5;j5=$.New(this,{});j5.s=j2;j5.c=j3;j5.n=j4;return j5;}})},Exception:$.Class({},{New:function(){return $.New(this,b.New1("Exception of type 'System.Exception' was thrown."));},New1:function($message){var $0=this,$this=this;return new $$.Error($message);}}),Guid:$.Class({},{NewGuid:function(){var $0=this,$this=this;return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(c){var r=$$.Math.random()*16|0,v=c=="x"?r:r&0x3|0x8;return v.toString(16);});}}),Html:{Client:{Activator:{Activate:$.Field(function(){var j6,j7;if(B.hasDocument()){j7=C.getElementById("websharper-data");j6=j7?D(C).ready(function(){var j9,j_,j$,kf;j9=j7.getAttribute("content");j_=E.Activate(F.parse(j9));j$=function(ka){var kb,kc,kd,ke;kb=ka[0];kc=ka[1];kd=kc.get_Body();ke=C.getElementById(kb);return kd.ReplaceInDom(ke);};kf=H.GetFields(j_);return e.iter(j$,kf);}):null;}else{j6=null;}return j6;}),hasDocument:function(){var $0=this,$this=this;return typeof $$.document!=="undefined";}},HtmlContentExtensions:{"IControlBody.SingleNode.Static":function(kg){return J.New(kg);},SingleNode:$.Class({ReplaceInDom:function(kh){var ki;ki=this.node.parentNode.replaceChild(this.node,kh);return;}},{New:function(kj){var kk;kk=$.New(this,{});kk.node=kj;return kk;}})}}},IndexOutOfRangeException:$.Class({},{New:function(){return $.New(this,g.New1("Index was outside the bounds of the array."));},New1:function(kl){return $.New(this,b.New1(kl));}}),InvalidOperationException:$.Class({},{New:function(){return $.New(this,K.New1("Operation is not valid due to the current state of the object."));},New1:function(km){return $.New(this,b.New1(km));}}),JavaScript:{JSModule:{Delete:function($x,$field){var $0=this,$this=this;return delete $x[$field];},ForEach:function($x,$iter){var $0=this,$this=this;for(var k in $x){if($iter(k))break;}},GetFieldNames:function($o){var $0=this,$this=this;var r=[];for(var k in $o)r.push(k);return r;},GetFieldValues:function($o){var $0=this,$this=this;var r=[];for(var k in $o)r.push($o[k]);return r;},GetFields:function($o){var $0=this,$this=this;var r=[];for(var k in $o)r.push([k,$o[k]]);return r;},Log:function($x){var $0=this,$this=this;if($$.console)$$.console.log($x);},LogMore:function($args){var $0=this,$this=this;if($$.console)$$.console.log.apply($$.console,$args);}},Pervasives:{NewFromList:function(kn){var ko,kp,kq,kr,ks;ko={};kp=k.Get(kn);while(kp.MoveNext()){kq=kp.get_Current();kr=kq[1];ks=kq[0];ko[ks]=kr;}return ko;}}},Json:{Activate:function(kt){var ku,kv,kw;ku=kt.$TYPES;for(kv=0;kv<=e.length(ku)-1;kv++){e.set(ku,kv,E.lookup(e.get(ku,kv)));}kw=function(kx){var ky,kz,kA,kB,kC,kD,kE,kF;if(j.Equals(kx,null)){ky=kx;}else{kz=typeof kx;if(kz==="object"){if(kx instanceof $$.Array){kB=E.shallowMap(kw,kx);}else{kC=E.shallowMap(kw,kx.$V);kD=kx.$T;if(j.Equals(typeof kD,"undefined")){kE=kC;}else{kF=new(e.get(ku,kD))();H.ForEach(kC,function(kG){kF[kG]=kC[kG];return false;});kE=kF;}kB=kE;}kA=kB;}else{kA=kx;}ky=kA;}return ky;};return kw(kt.$DATA);},lookup:function(kH){var kI,kJ,kK,kL,kM,kN;kI=e.length(kH);kJ=$$;kK=0;while(kK<kI){kL=e.get(kH,kK);kM=kJ[kL];if(!j.Equals(typeof kM,undefined)){kJ=kM;kN=kK=kK+1;}else{kN=f.FailWith("Invalid server reply. Failed to find type: "+kL);}}return kJ;},shallowMap:function(kO,kP){var kQ,kR,kS,kT;if(kP instanceof $$.Array){kQ=e.map(kO,kP);}else{kR=typeof kP;if(kR==="object"){kT={};H.ForEach(kP,function(kU){kT[kU]=kO(kP[kU]);return false;});kS=kT;}else{kS=kP;}kQ=kS;}return kQ;}},Lazy:{Create:function(kV){var kW,kX;kW={value:undefined,created:false,eval:kV};kX=function(){var kZ;if(kW.created){kZ=kW.value;}else{kW.created=true;kW.value=kV(null);kZ=kW.value;}return kZ;};kW.eval=kX;return kW;},CreateFromValue:function(k0){return{value:k0,created:true,eval:function(){return k0;},eval:function(){return k0;}};},Force:function(k3){return k3.eval.call(null,null);}},List:{T:$.Class({GetEnumerator:function(){return y.New(this,null,function(k4){var k5,k6,k7,k8;k5=k4.s;if(k5.$==0){k6=false;}else{k7=k5.$1;k8=k5.$0;k4.c=k8;k4.s=k7;k6=true;}return k6;});},get_Item:function(k9){return i.nth(k9,this);},get_Length:function(){return i.length(this);}},{Construct:function(k_,k$){return $.New(M,{$:1,$0:k_,$1:k$});},get_Nil:function(){return $.New(M,{$:0});}}),append:function(la,lb){return L.ofSeq(i.append(la,lb));},choose:function(lc,ld){return L.ofSeq(i.choose(lc,ld));},collect:function(le,lf){return L.ofSeq(i.collect(le,lf));},concat:function(lg){return L.ofSeq(i.concat(lg));},exists2:function(lh,li,lj){return e.exists2(lh,e.ofSeq(li),e.ofSeq(lj));},filter:function(lk,ll){return L.ofSeq(i.filter(lk,ll));},fold2:function(lm,ln,lo,lp){return e.fold2(lm,ln,e.ofSeq(lo),e.ofSeq(lp));},foldBack:function(lq,lr,ls){return e.foldBack(lq,e.ofSeq(lr),ls);},foldBack2:function(lt,lu,lv,lw){return e.foldBack2(lt,e.ofSeq(lu),e.ofSeq(lv),lw);},forall2:function(lx,ly,lz){return e.forall2(lx,e.ofSeq(ly),e.ofSeq(lz));},head:function(lA){var lB,lC;if(lA.$==1){lC=lA.$0;lB=lC;}else{lB=f.FailWith("The input list was empty.");}return lB;},init:function(lD,lE){return L.ofArray(e.init(lD,lE));},iter2:function(lF,lG,lH){return e.iter2(lF,e.ofSeq(lG),e.ofSeq(lH));},iteri2:function(lI,lJ,lK){return e.iteri2(lI,e.ofSeq(lJ),e.ofSeq(lK));},map:function(lL,lM){return L.ofSeq(i.map(lL,lM));},map2:function(lN,lO,lP){return L.ofArray(e.map2(lN,e.ofSeq(lO),e.ofSeq(lP)));},map3:function(lQ,lR,lS,lT){var lU;lU=e.map2(function(lV){return function(lW){return lV(lW);};},e.map2(lQ,e.ofSeq(lR),e.ofSeq(lS)),e.ofSeq(lT));return L.ofArray(lU);},mapi:function(lX,lY){return L.ofSeq(i.mapi(lX,lY));},mapi2:function(lZ,l0,l1){return L.ofArray(e.mapi2(lZ,e.ofSeq(l0),e.ofSeq(l1)));},max:function(l2){return i.reduce(function(l3){return function(l4){return f.Max(l3,l4);};},l2);},maxBy:function(l5,l6){return i.reduce(function(l7){return function(l8){return j.Compare(l5(l7),l5(l8))===1?l7:l8;};},l6);},min:function(l9){return i.reduce(function(l_){return function(l$){return f.Min(l_,l$);};},l9);},minBy:function(ma,mb){return i.reduce(function(mc){return function(md){return j.Compare(ma(mc),ma(md))===-1?mc:md;};},mb);},ofArray:function(me){var mf,mg;mf=$.New(M,{$:0});for(mg=0;mg<=e.length(me)-1;mg++){mf=$.New(M,{$:1,$0:e.get(me,e.length(me)-mg-1),$1:mf});}return mf;},ofSeq:function(mh){var mi,mj,mk;mi=[];mj=k.Get(mh);while(mj.MoveNext()){mi.unshift(mj.get_Current());}mk=mi.slice(0);mk.reverse();return L.ofArray(mk);},partition:function(ml,mm){var mn,mo,mp;mn=e.partition(ml,e.ofSeq(mm));mo=mn[1];mp=mn[0];return[L.ofArray(mp),L.ofArray(mo)];},permute:function(mq,mr){return L.ofArray(e.permute(mq,e.ofSeq(mr)));},reduceBack:function(ms,mt){return e.reduceBack(ms,e.ofSeq(mt));},replicate:function(mu,mv){return L.ofArray(e.create(mu,mv));},rev:function(mw){var mx;mx=e.ofSeq(mw);mx.reverse();return L.ofArray(mx);},scan:function(my,mz,mA){return L.ofSeq(i.scan(my,mz,mA));},scanBack:function(mB,mC,mD){return L.ofArray(e.scanBack(mB,e.ofSeq(mC),mD));},sort:function(mE){var mF;mF=e.ofSeq(mE);e.sortInPlace(mF);return L.ofArray(mF);},sortBy:function(mG,mH){return L.sortWith(function(mI){return function(mJ){return f.Compare(mG(mI),mG(mJ));};},mH);},sortWith:function(mK,mL){var mM;mM=e.ofSeq(mL);e.sortInPlaceWith(mK,mM);return L.ofArray(mM);},tail:function(mN){var mO,mP;if(mN.$==1){mP=mN.$1;mO=mP;}else{mO=f.FailWith("The input list was empty.");}return mO;},unzip:function(mQ){var mR,mS,mT,mU,mV,mW;mR=[];mS=[];mT=k.Get(mQ);while(mT.MoveNext()){mU=mT.get_Current();mV=mU[1];mW=mU[0];mR.push(mW);mS.push(mV);}return[L.ofArray(mR.slice(0)),L.ofArray(mS.slice(0))];},unzip3:function(mX){var mY,mZ,m0,m1,m2,m3,m4,m5;mY=[];mZ=[];m0=[];m1=k.Get(mX);while(m1.MoveNext()){m2=m1.get_Current();m3=m2[2];m4=m2[1];m5=m2[0];mY.push(m5);mZ.push(m4);m0.push(m3);}return[L.ofArray(mY.slice(0)),L.ofArray(mZ.slice(0)),L.ofArray(m0.slice(0))];},zip:function(m6,m7){return L.ofArray(e.zip(e.ofSeq(m6),e.ofSeq(m7)));},zip3:function(m8,m9,m_){return L.ofArray(e.zip3(e.ofSeq(m8),e.ofSeq(m9),e.ofSeq(m_)));}},MatchFailureException:$.Class({},{New:function(m$,na,nb){return $.New(this,b.New1(m$+" at "+$$.String(na)+":"+$$.String(nb)));}}),OperationCanceledException:$.Class({},{New:function(){return $.New(this,u.New1("The operation was canceled."));},New1:function(nc){return $.New(this,b.New1(nc));}}),Operators:{Compare:function(nd,ne){return j.Compare(nd,ne);},DefaultArg:function(nf,ng){var nh,ni;if(nf.$==0){nh=ng;}else{ni=nf.$0;nh=ni;}return nh;},FailWith:function(nj){return f.Raise(b.New1(nj));},KeyValue:function(nk){return[nk.K,nk.V];},Max:function(nl,nm){return j.Compare(nl,nm)===1?nl:nm;},Min:function(nn,no){return j.Compare(nn,no)===-1?nn:no;},Pown:function(np,nq){var nr;nr=function(ns){var nt,nu,nv;if(ns===1){nt=np;}else{if(ns%2===0){nv=nr(ns/2>>0);nu=nv*nv;}else{nu=np*nr(ns-1);}nt=nu;}return nt;};return nr(nq);},Raise:function($e){var $0=this,$this=this;throw $e;},Sign:function(nw){return nw===0?0:nw<0?-1:1;},Truncate:function(nx){return nx<0?O.ceil(nx):O.floor(nx);},Using:function(ny,nz){var nA;try{nA=nz(ny);}finally{ny.Dispose();}return nA;},range:function(nB,nC){return i.init(1+nC-nB,function(nD){return nD+nB;});},step:function(nE,nF,nG){var nH,nI,nK,nM;nH=f.Sign(nF);nI=function(nJ){return nH*(nG-nJ)>=0;};nK=i.initInfinite(function(nL){return nE+nL*nF;});nM=i.takeWhile(nI,nK);return nM;}},Option:{bind:function(nN,nO){var nP,nQ;if(nO.$==0){nP={$:0};}else{nQ=nO.$0;nP=nN(nQ);}return nP;},exists:function(nR,nS){var nT,nU;if(nS.$==0){nT=false;}else{nU=nS.$0;nT=nR(nU);}return nT;},fold:function(nV,nW,nX){var nY,nZ;if(nX.$==0){nY=nW;}else{nZ=nX.$0;nY=(nV(nW))(nZ);}return nY;},foldBack:function(n0,n1,n2){var n3,n4;if(n1.$==0){n3=n2;}else{n4=n1.$0;n3=(n0(n4))(n2);}return n3;},forall:function(n5,n6){var n7,n8;if(n6.$==0){n7=true;}else{n8=n6.$0;n7=n5(n8);}return n7;},iter:function(n9,n_){var n$,oa;if(n_.$==0){n$=null;}else{oa=n_.$0;n$=n9(oa);}return n$;},map:function(ob,oc){var od,oe;if(oc.$==0){od={$:0};}else{oe=oc.$0;od={$:1,$0:ob(oe)};}return od;},toArray:function(of){var og,oh;if(of.$==0){og=[];}else{oh=of.$0;og=[oh];}return og;},toList:function(oi){var oj,ok;if(oi.$==0){oj=$.New(M,{$:0});}else{ok=oi.$0;oj=L.ofArray([ok]);}return oj;}},PrintfHelpers:{padNumLeft:function(ol,om){var on;on=e.get(ol,0);return((on===" "?true:on==="+")?true:on==="-")?on+P.PadLeftWith(ol.substr(1),om-1,48):P.PadLeftWith(ol,om,48);},plusForPos:function(oo,op){return 0<=oo?"+"+op:op;},prettyPrint:function(oq){var or,oB,oC,oD,oE,oF,oH;or=function(os){var ot,ou,ov,oz,oA;ot=$$.String(os);if(ot==="[object Object]"){ov=function(ow){var ox,oy;ox=ow[0];oy=ow[1];return ox+" = "+Q.prettyPrint(oy);};oz=H.GetFields(os);oA=e.map(ov,oz);ou="{"+P.concat("; ",oA)+"}";}else{ou=ot;}return ou;};oB=typeof oq;if(oB=="string"){oC="\""+oq+"\"";}else{if(oB=="object"){if(oq instanceof $$.Array){oF=function(oG){return Q.prettyPrint(oG);};oH=e.map(oF,oq);oE="[|"+P.concat("; ",oH)+"|]";}else{oE=or(oq);}oD=oE;}else{oD=$$.String(oq);}oC=oD;}return oC;},printArray:function(oI,oJ){var oK;oK=e.map(oI,oJ);return"[|"+P.concat("; ",oK)+"|]";},printArray2D:function(oL,oM){var oN;oN=i.delay(function(){var oP;oP=oM.length?oM[0].length:0;return i.map(function(oQ){var oR;oR=i.delay(function(){return i.map(function(oT){return oL(e.get2D(oM,oQ,oT));},f.range(0,oP-1));});return P.concat("; ",oR);},f.range(0,oM.length-1));});return"[["+P.concat("][",oN)+"]]";},printList:function(oU,oV){var oW;oW=i.map(oU,oV);return"["+P.concat("; ",oW)+"]";},spaceForPos:function(oX,oY){return 0<=oX?" "+oY:oY;},toSafe:function(oZ){return oZ==null?"":oZ;}},Queue:{Clear:function(o0){return o0.splice(0,e.length(o0));},Contains:function(o1,o2){return i.exists(function(o3){return j.Equals(o2,o3);},o1);},CopyTo:function(o4,o5,o6){return e.blit(o4,0,o5,o6,e.length(o4));}},Random:$.Class({Next:function(){return O.floor(O.random()*2147483648);},Next1:function(o7){return o7<0?f.FailWith("'maxValue' must be greater than zero."):O.floor(O.random()*o7);},Next2:function(o8,o9){var o_,o$;if(o8>o9){o_=f.FailWith("'minValue' cannot be greater than maxValue.");}else{o$=o9-o8;o_=o8+O.floor(O.random()*o$);}return o_;},NextBytes:function(pa){var pb;for(pb=0;pb<=e.length(pa)-1;pb++){e.set(pa,pb,O.floor(O.random()*256));}return;}},{New:function(){return $.New(this,{});}}),Ref:{decr:function($x){var $0=this,$this=this;return void($x[0]--);},incr:function($x){var $0=this,$this=this;return void($x[0]++);}},Remoting:{AjaxProvider:$.Field(function(){return S.New();}),AjaxRemotingProvider:$.Class({},{Async:function(pc,pd){var pe,pf;pe=R.makeHeaders(pc);pf=R.makePayload(pd);return m.Delay(function(){var ph;ph=T.get_CancellationToken();return m.Bind(ph,function(pi){return m.FromContinuations(function(pj){var pk,pl,pm,pn,po,ps,pv,py;pk=pj[0];pl=pj[1];pm=pj[2];pn=[true];po=m.Register(pi,function(){return function(){var pr;if(pn[0]){pn[0]=false;pr=pm(u.New());}else{pr=null;}return pr;}();});ps=function(pt){var pu;if(pn[0]){pn[0]=false;po.Dispose();pu=pk(E.Activate(F.parse(pt)));}else{pu=null;}return pu;};pv=function(pw){var px;if(pn[0]){pn[0]=false;po.Dispose();px=pl(pw);}else{px=null;}return px;};py=R.EndPoint();return R.AjaxProvider().Async(py,pe,pf,ps,pv);});});});},Send:function(pz,pA){return m.Start(m.Ignore(U.Async(pz,pA)),{$:0});},Sync:function(pB,pC){var pD,pE,pF,pG;pD=R.EndPoint();pE=R.makeHeaders(pB);pF=R.makePayload(pC);pG=R.AjaxProvider().Sync(pD,pE,pF);return E.Activate(F.parse(pG));}}),EndPoint:$.Field(function(){return"?";}),UseHttps:function(){var pH,pI,pJ,pK;try{if(!P.StartsWith(V.location.href,"https://")){pJ=P.Replace(V.location.href,"http://","https://");R.EndPoint=function(){return pJ;};pI=true;}else{pI=false;}pH=pI;}catch(pK){pH=false;}return pH;},XhrProvider:$.Class({Async:function(pL,pM,pN,pO,pP){return R.ajax(true,pL,pM,pN,pO,pP);},Sync:function(pQ,pR,pS){var pT;pT=[undefined];R.ajax(false,pQ,pR,pS,function(pU){pT[0]=pU;},function(pV){return f.Raise(pV);});return pT[0];}},{New:function(){return $.New(this,{});}}),ajax:function($async,$url,$headers,$data,$ok,$err){var $0=this,$this=this;var xhr=new $$.XMLHttpRequest();xhr.open("POST",$url,$async);if($async==true){xhr.withCredentials=true;}for(var h in $headers){xhr.setRequestHeader(h,$headers[h]);}function k(){if(xhr.status==200){$ok(xhr.responseText);}else{var msg="Response status is not 200: ";$err(new $$.Error(msg+xhr.status));}}if("onload"in xhr){xhr.onload=xhr.onerror=xhr.onabort=k;}else{xhr.onreadystatechange=function(){if(xhr.readyState==4){k();}};}xhr.send($data);},makeHeaders:function(pW){var pX;pX={};pX["content-type"]="application/json";pX["x-websharper-rpc"]=pW;return pX;},makePayload:function(pY){return F.stringify(pY);}},Seq:{append:function(pZ,p0){return W.Of(function(){var p2;p2=k.Get(pZ);return y.New(p2,null,function(p3){var p4,p5,p6,p7;if(p3.s.MoveNext()){p3.c=p3.s.get_Current();p4=true;}else{if(p3.s===p2){p6=k.Get(p0);p3.s=p6;if(p6.MoveNext()){p3.c=p6.get_Current();p7=true;}else{p7=false;}p5=p7;}else{p5=false;}p4=p5;}return p4;});});},average:function(p8){var p9,qc,qd;p9=i.fold(function(p_){var p$,qa;p$=p_[0];qa=p_[1];return function(qb){return[p$+1,qa+qb];};},[0,0],p8);qc=p9[1];qd=p9[0];return qc/qd;},averageBy:function(qe,qf){var qg,ql,qm;qg=i.fold(function(qh){var qi,qj;qi=qh[0];qj=qh[1];return function(qk){return[qi+1,qj+qe(qk)];};},[0,0],qf);ql=qg[1];qm=qg[0];return ql/qm;},cache:function(qn){var qo,qp,qq;qo=[];qp=k.Get(qn);qq=function(){var qs;qs=function(qt){var qu,qv;if(qt.s+1<qo.length){qt.s=qt.s+1;qt.c=qo[qt.s];qu=true;}else{if(qp.MoveNext()){qt.s=qt.s+1;qt.c=qp.get_Current();qo.push(qt.get_Current());qv=true;}else{qv=false;}qu=qv;}return qu;};return y.New(0,null,qs);};return W.Of(qq);},choose:function(qw,qx){var qy;qy=function(qz){var qA,qB,qC;qA=qw(qz);if(qA.$==0){qB=$.New(M,{$:0});}else{qC=qA.$0;qB=L.ofArray([qC]);}return qB;};return i.collect(qy,qx);},collect:function(qD,qE){return i.concat(i.map(qD,qE));},compareWith:function(qF,qG,qH){var qI,qJ,qK,qL,qM;qI=k.Get(qG);qJ=k.Get(qH);qK=0;qL=true;while(qL?qK===0:false){qM=[qI.MoveNext(),qJ.MoveNext()];qM[0]?qM[1]?qK=(qF(qI.get_Current()))(qJ.get_Current()):qK=1:qM[1]?qK=-1:qL=false;}return qK;},concat:function(qN){return W.Of(function(){var qP,qQ;qP=k.Get(qN);qQ=function(qR){var qS,qT,qU,qV;qS=qR.s;if(j.Equals(qS,null)){if(qP.MoveNext()){qR.s=k.Get(qP.get_Current());qU=qQ(qR);}else{qU=false;}qT=qU;}else{if(qS.MoveNext()){qR.c=qS.get_Current();qV=true;}else{qR.s=null;qV=qQ(qR);}qT=qV;}return qT;};return y.New(null,null,qQ);});},countBy:function(qW,qX){var qY;qY=function(){var q0,q1,q2,q3,q4,q5,q6,q8,q9;q0={};q1=k.Get(qX);q2=[];while(q1.MoveNext()){q3=qW(q1.get_Current());q4=j.Hash(q3);if(q0.hasOwnProperty(q4)){q5=void(q0[q4]=q0[q4]+1);}else{q2.push(q3);q5=void(q0[q4]=1);}}q6=function(q7){return[q7,q0[j.Hash(q7)]];};q8=q2.slice(0);q9=e.map(q6,q8);return q9;};return i.delay(qY);},delay:function(q_){return W.Of(function(){return k.Get(q_(null));});},distinct:function(ra){return i.distinctBy(function(rb){return rb;},ra);},distinctBy:function(rc,rd){var re;re=function(){var rg,rh,ri;rg=k.Get(rd);rh={};ri=function(rj){var rk,rl,rm,ro,rq,rr;if(rg.MoveNext()){rl=rg.get_Current();rm=function(rn){return j.Hash(rc(rn));};ro=function(rp){return rh.hasOwnProperty(rm(rp));};rq=ro(rl);while(rq?rg.MoveNext():false){rl=rg.get_Current();rq=ro(rl);}if(rq){rr=false;}else{rh[rm(rl)]=null;rj.c=rl;rr=true;}rk=rr;}else{rk=false;}return rk;};return y.New(null,null,ri);};return W.Of(re);},empty:function(){return[];},enumFinally:function(rs,rt){return W.Of(function(){var rv,rw,rx;try{rw=k.Get(rs);}catch(rx){rt(null);rw=f.Raise(rx);}rv=rw;return y.New(null,null,function(ry){var rz,rA,rB;try{if(rv.MoveNext()){ry.c=rv.get_Current();rA=true;}else{rt(null);rA=false;}rz=rA;}catch(rB){rt(null);rz=f.Raise(rB);}return rz;});});},enumUsing:function(rC,rD){return rD(rC);},enumWhile:function(rE,rF){return W.Of(function(){var rH;rH=function(rI){var rJ,rK,rL,rM,rN;rJ=rI.s;if(rJ.$==1){rL=rJ.$0;if(rL.MoveNext()){rI.c=rL.get_Current();rM=true;}else{rI.s={$:0};rM=rH(rI);}rK=rM;}else{if(rE(null)){rI.s={$:1,$0:k.Get(rF)};rN=rH(rI);}else{rN=false;}rK=rN;}return rK;};return y.New({$:0},null,rH);});},exists:function(rO,rP){var rQ,rR;rQ=k.Get(rP);rR=false;while(!rR?rQ.MoveNext():false){rR=rO(rQ.get_Current());}return rR;},exists2:function(rS,rT,rU){var rV,rW,rX;rV=k.Get(rT);rW=k.Get(rU);rX=false;while((!rX?rV.MoveNext():false)?rW.MoveNext():false){rX=(rS(rV.get_Current()))(rW.get_Current());}return rX;},filter:function(rY,rZ){var r0;r0=function(){var r2,r3;r2=k.Get(rZ);r3=function(r4){var r5,r6,r7,r8;r5=r2.MoveNext();r6=r2.get_Current();r7=false;while(r5){if(rY(r6)){r4.c=r6;r7=true;r8=r5=false;}else{r8=r2.MoveNext()?r6=r2.get_Current():r5=false;}}return r7;};return y.New(null,null,r3);};return W.Of(r0);},find:function(r9,r_){var r$,sa,sb;r$=i.tryFind(r9,r_);if(r$.$==0){sa=f.FailWith("KeyNotFoundException");}else{sb=r$.$0;sa=sb;}return sa;},findIndex:function(sc,sd){var se,sf,sg;se=i.tryFindIndex(sc,sd);if(se.$==0){sf=f.FailWith("KeyNotFoundException");}else{sg=se.$0;sf=sg;}return sf;},fold:function(sh,si,sj){var sk,sl;sk=si;sl=k.Get(sj);while(sl.MoveNext()){sk=(sh(sk))(sl.get_Current());}return sk;},forall:function(sm,sn){return!i.exists(function(so){return!sm(so);},sn);},forall2:function(sp,sq,sr){return!i.exists2(function(ss){return function(st){return!(sp(ss))(st);};},sq,sr);},groupBy:function(su,sv){return i.delay(function(){var sx,sy,sz,sA,sB,sC,sD;sx={};sy={};sz=[];sA=k.Get(sv);while(sA.MoveNext()){sB=sA.get_Current();sC=su(sB);sD=j.Hash(sC);!sx.hasOwnProperty(sD)?sz.push(sC):null;sy[sD]=sC;sx.hasOwnProperty(sD)?sx[sD].push(sB):void(sx[sD]=[sB]);}return e.map(function(sE){return[sE,sx[j.Hash(sE)]];},sz);});},head:function(sF){var sG;sG=k.Get(sF);return sG.MoveNext()?sG.get_Current():i.insufficient();},init:function(sH,sI){return i.take(sH,i.initInfinite(sI));},initInfinite:function(sJ){var sK;sK=function(){var sM;sM=function(sN){sN.c=sJ(sN.s);sN.s=sN.s+1;return true;};return y.New(0,null,sM);};return W.Of(sK);},insufficient:function(){return f.FailWith("The input sequence has an insufficient number of elements.");},isEmpty:function(sO){var sP;sP=k.Get(sO);return!sP.MoveNext();},iter:function(sQ,sR){return i.iteri(function(){return function(sT){return sQ(sT);};},sR);},iter2:function(sU,sV,sW){var sX,sY;sX=k.Get(sV);sY=k.Get(sW);while(sX.MoveNext()?sY.MoveNext():false){(sU(sX.get_Current()))(sY.get_Current());}return;},iteri:function(sZ,s0){var s1,s2;s1=0;s2=k.Get(s0);while(s2.MoveNext()){(sZ(s1))(s2.get_Current());s1=s1+1;}return;},length:function(s3){var s4,s5;s4=0;s5=k.Get(s3);while(s5.MoveNext()){s4=s4+1;}return s4;},map:function(s6,s7){var s8;s8=function(){var s_,s$;s_=k.Get(s7);s$=function(ta){var tb;if(s_.MoveNext()){ta.c=s6(s_.get_Current());tb=true;}else{tb=false;}return tb;};return y.New(null,null,s$);};return W.Of(s8);},mapi:function(tc,td){return i.mapi2(tc,i.initInfinite(function(te){return te;}),td);},mapi2:function(tf,tg,th){var ti;ti=function(){var tk,tl,tm;tk=k.Get(tg);tl=k.Get(th);tm=function(tn){var to;if(tk.MoveNext()?tl.MoveNext():false){tn.c=(tf(tk.get_Current()))(tl.get_Current());to=true;}else{to=false;}return to;};return y.New(null,null,tm);};return W.Of(ti);},max:function(tp){return i.reduce(function(tq){return function(tr){return j.Compare(tq,tr)>=0?tq:tr;};},tp);},maxBy:function(ts,tt){return i.reduce(function(tu){return function(tv){return j.Compare(ts(tu),ts(tv))>=0?tu:tv;};},tt);},min:function(tw){return i.reduce(function(tx){return function(ty){return j.Compare(tx,ty)<=0?tx:ty;};},tw);},minBy:function(tz,tA){return i.reduce(function(tB){return function(tC){return j.Compare(tz(tB),tz(tC))<=0?tB:tC;};},tA);},nth:function(tD,tE){var tF,tG;tD<0?f.FailWith("negative index requested"):null;tF=-1;tG=k.Get(tE);while(tF<tD){!tG.MoveNext()?i.insufficient():null;tF=tF+1;}return tG.get_Current();},pairwise:function(tH){var tI,tK;tI=function(tJ){return[e.get(tJ,0),e.get(tJ,1)];};tK=i.windowed(2,tH);return i.map(tI,tK);},pick:function(tL,tM){var tN,tO,tP;tN=i.tryPick(tL,tM);if(tN.$==0){tO=f.FailWith("KeyNotFoundException");}else{tP=tN.$0;tO=tP;}return tO;},readOnly:function(tQ){return W.Of(function(){return k.Get(tQ);});},reduce:function(tS,tT){var tU,tV;tU=k.Get(tT);!tU.MoveNext()?f.FailWith("The input sequence was empty"):null;tV=tU.get_Current();while(tU.MoveNext()){tV=(tS(tV))(tU.get_Current());}return tV;},scan:function(tW,tX,tY){var tZ;tZ=function(){var t1,t2;t1=k.Get(tY);t2=function(t3){var t4,t5;if(t3.s){if(t1.MoveNext()){t3.c=(tW(t3.get_Current()))(t1.get_Current());t5=true;}else{t5=false;}t4=t5;}else{t3.c=tX;t3.s=true;t4=true;}return t4;};return y.New(false,null,t2);};return W.Of(tZ);},skip:function(t6,t7){return W.Of(function(){var t9,t_;t9=k.Get(t7);for(t_=1;t_<=t6;t_++){!t9.MoveNext()?i.insufficient():null;}return t9;});},skipWhile:function(t$,ua){return W.Of(function(){var uc,ud;uc=k.Get(ua);ud=true;while(uc.MoveNext()?t$(uc.get_Current()):false){ud=false;}return ud?k.Get(i.empty()):y.New(true,null,function(ue){var uf,ug;if(ue.s){ue.s=false;ue.c=uc.get_Current();uf=true;}else{ug=uc.MoveNext();ue.c=uc.get_Current();uf=ug;}return uf;});});},sort:function(uh){return i.sortBy(function(ui){return ui;},uh);},sortBy:function(uj,uk){return i.delay(function(){var um;um=e.ofSeq(uk);e.sortInPlaceBy(uj,um);return um;});},sum:function(un){return i.fold(function(uo){return function(up){return uo+up;};},0,un);},sumBy:function(uq,ur){return i.fold(function(us){return function(ut){return us+uq(ut);};},0,ur);},take:function(uu,uv){return W.Of(function(){var ux;ux=k.Get(uv);return y.New(0,null,function(uy){var uz,uA;if(uy.s>=uu){uz=false;}else{if(ux.MoveNext()){uy.s=uy.s+1;uy.c=ux.get_Current();uA=true;}else{ux.Dispose();uy.s=uu;uA=false;}uz=uA;}return uz;});});},takeWhile:function(uB,uC){return i.delay(function(){return i.enumUsing(k.Get(uC),function(uE){return i.enumWhile(function(){return uE.MoveNext()?uB(uE.get_Current()):false;},i.delay(function(){return[uE.get_Current()];}));});});},toArray:function(uH){var uI,uJ,uK;uI=[];uJ=k.Get(uH);while(uJ.MoveNext()){uK=uJ.get_Current();uI.push(uK);}return uI.slice(0);},toList:function(uL){return L.ofSeq(uL);},truncate:function(uM,uN){return i.delay(function(){return i.enumUsing(k.Get(uN),function(uP){var uQ;uQ=[0];return i.enumWhile(function(){return uP.MoveNext()?uQ[0]<uM:false;},i.delay(function(){X.incr(uQ);return[uP.get_Current()];}));});});},tryFind:function(uT,uU){var uV,uW,uX;uV=k.Get(uU);uW={$:0};while(uW.$==0?uV.MoveNext():false){uX=uV.get_Current();uT(uX)?uW={$:1,$0:uX}:null;}return uW;},tryFindIndex:function(uY,uZ){var u0,u1,u2,u3;u0=k.Get(uZ);u1=true;u2=0;while(u1?u0.MoveNext():false){u3=u0.get_Current();uY(u3)?u1=false:u2=u2+1;}return u1?{$:0}:{$:1,$0:u2};},tryPick:function(u4,u5){var u6,u7;u6=k.Get(u5);u7={$:0};while(j.Equals(u7,{$:0})?u6.MoveNext():false){u7=u4(u6.get_Current());}return u7;},unfold:function(u8,u9){var u_;u_=function(){var va;va=function(vb){var vc,vd,ve,vf;vc=u8(vb.s);if(vc.$==0){vd=false;}else{ve=vc.$0[0];vf=vc.$0[1];vb.c=ve;vb.s=vf;vd=true;}return vd;};return y.New(u9,null,va);};return W.Of(u_);},windowed:function(vg,vh){vg<=0?f.FailWith("The input must be non-negative."):null;return i.delay(function(){return i.enumUsing(k.Get(vh),function(vj){var vk;vk=[];return i.append(i.enumWhile(function(){return vk.length<vg?vj.MoveNext():false;},i.delay(function(){vk.push(vj.get_Current());return i.empty();})),i.delay(function(){return vk.length===vg?i.append([vk.slice(0)],i.delay(function(){return i.enumWhile(function(){return vj.MoveNext();},i.delay(function(){vk.shift();vk.push(vj.get_Current());return[vk.slice(0)];}));})):i.empty();}));});});},zip:function(vr,vs){return i.mapi2(function(vt){return function(vu){return[vt,vu];};},vr,vs);},zip3:function(vv,vw,vx){return i.mapi2(function(vy){return function(vz){var vA,vB;vA=vz[0];vB=vz[1];return[vy,vA,vB];};},vv,i.zip(vw,vx));}},Slice:{array:function(vC,vD,vE){var vF,vG,vH,vI,vJ,vK,vL,vM;vF=[vD,vE];if(vF[0].$==0){if(vF[1].$==1){vI=vF[1].$0;vH=vC.slice(0,vI+1);}else{vH=[];}vG=vH;}else{if(vF[1].$==0){vK=vF[0].$0;vJ=vC.slice(vK);}else{vL=vF[1].$0;vM=vF[0].$0;vJ=vC.slice(vM,vL+1);}vG=vJ;}return vG;},array2D:function(vN,vO,vP,vQ,vR){var vS,vT,vU,vV,vW,vX,vY,vZ,v0,v1,v2,v3,v4,v5;if(vO.$==1){vU=vO.$0;vT=vU;}else{vT=0;}vS=vT;if(vQ.$==1){vX=vQ.$0;vW=vX;}else{vW=0;}vV=vW;if(vP.$==1){v0=vP.$0;vZ=v0;}else{vZ=vN.length-1;}vY=vZ;if(vR.$==1){v3=vR.$0;v2=v3;}else{v2=(vN.length?vN[0].length:0)-1;}v1=v2;v4=vY-vS+1;v5=v1-vV+1;return e.sub2D(vN,vS,vV,v4,v5);},array2Dfix1:function(v6,v7,v8,v9){var v_,v$,wa,wb,wc,wd,we,wf,wg;if(v8.$==1){wa=v8.$0;v$=wa;}else{v$=0;}v_=v$;if(v9.$==1){wd=v9.$0;wc=wd;}else{wc=(v6.length?v6[0].length:0)-1;}wb=wc;we=wb-v_+1;wf=h(we);for(wg=0;wg<=we-1;wg++){e.set(wf,wg,e.get2D(v6,v7,v_+wg));}return wf;},array2Dfix2:function(wh,wi,wj,wk){var wl,wm,wn,wo,wp,wq,wr,ws,wt;if(wi.$==1){wn=wi.$0;wm=wn;}else{wm=0;}wl=wm;if(wj.$==1){wq=wj.$0;wp=wq;}else{wp=wh.length-1;}wo=wp;wr=wo-wl+1;ws=h(wr);for(wt=0;wt<=wr-1;wt++){e.set(ws,wt,e.get2D(wh,wl+wt,wk));}return ws;},setArray:function(wu,wv,ww,wx){var wy,wz,wA,wB,wC,wD;if(wv.$==1){wA=wv.$0;wz=wA;}else{wz=0;}wy=wz;if(ww.$==1){wD=ww.$0;wC=wD;}else{wC=wu.length-1;}wB=wC;return e.setSub(wu,wy,wB-wy+1,wx);},setArray2D:function(wE,wF,wG,wH,wI,wJ){var wK,wL,wM,wN,wO,wP,wQ,wR,wS,wT,wU,wV;if(wF.$==1){wM=wF.$0;wL=wM;}else{wL=0;}wK=wL;if(wH.$==1){wP=wH.$0;wO=wP;}else{wO=0;}wN=wO;if(wG.$==1){wS=wG.$0;wR=wS;}else{wR=wE.length-1;}wQ=wR;if(wI.$==1){wV=wI.$0;wU=wV;}else{wU=(wE.length?wE[0].length:0)-1;}wT=wU;return e.setSub2D(wE,wK,wN,wQ-wK+1,wT-wN+1,wJ);},setArray2Dfix1:function(wW,wX,wY,wZ,w0){var w1,w2,w3,w4,w5,w6,w7,w8;if(wY.$==1){w3=wY.$0;w2=w3;}else{w2=0;}w1=w2;if(wZ.$==1){w6=wZ.$0;w5=w6;}else{w5=(wW.length?wW[0].length:0)-1;}w4=w5;w7=w4-w1+1;for(w8=0;w8<=w7-1;w8++){e.set2D(wW,wX,w1+w8,e.get(w0,w8));}return;},setArray2Dfix2:function(w9,w_,w$,xa,xb){var xc,xd,xe,xf,xg,xh,xi,xj;if(w_.$==1){xe=w_.$0;xd=xe;}else{xd=0;}xc=xd;if(w$.$==1){xh=w$.$0;xg=xh;}else{xg=w9.length-1;}xf=xg;xi=xf-xc+1;for(xj=0;xj<=xi-1;xj++){e.set2D(w9,xc+xj,xa,e.get(xb,xj));}return;},string:function(xk,xl,xm){var xn,xo,xp,xq,xr,xs,xt,xu;xn=[xl,xm];if(xn[0].$==0){if(xn[1].$==1){xq=xn[1].$0;xp=xk.slice(0,xq+1);}else{xp="";}xo=xp;}else{if(xn[1].$==0){xs=xn[0].$0;xr=xk.slice(xs);}else{xt=xn[1].$0;xu=xn[0].$0;xr=xk.slice(xu,xt+1);}xo=xr;}return xo;}},Stack:{Clear:function(xv){return xv.splice(0,e.length(xv));},Contains:function(xw,xx){return i.exists(function(xy){return j.Equals(xx,xy);},xw);},CopyTo:function(xz,xA,xB){return e.blit(xA,0,xA,xB,e.length(xz));}},Strings:{Compare:function(xC,xD){return f.Compare(xC,xD);},CopyTo:function(xE,xF,xG,xH,xI){return e.blit(P.ToCharArray(xE),xF,xG,xH,xI);},EndsWith:function($x,$s){var $0=this,$this=this;return $x.substring($x.length-$s.length)==$s;},IndexOf:function($s,$c,$i){var $0=this,$this=this;return $s.indexOf($$.String.fromCharCode($c),$i);},Insert:function($x,$index,$s){var $0=this,$this=this;return $x.substring(0,$index-1)+$s+$x.substring($index);},IsNullOrEmpty:function($x){var $0=this,$this=this;return $x==null||$x=="";},Join:function($sep,$values){var $0=this,$this=this;return $values.join($sep);},LastIndexOf:function($s,$c,$i){var $0=this,$this=this;return $s.lastIndexOf($$.String.fromCharCode($c),$i);},PadLeft:function(xJ,xK){return P.PadLeftWith(xJ,xK,32);},PadLeftWith:function($s,$n,$c){var $0=this,$this=this;return $$.Array($n-$s.length+1).join($$.String.fromCharCode($c))+$s;},PadRight:function(xL,xM){return P.PadRightWith(xL,xM,32);},PadRightWith:function($s,$n,$c){var $0=this,$this=this;return $s+$$.Array($n-$s.length+1).join($$.String.fromCharCode($c));},RegexEscape:function($s){var $0=this,$this=this;return $s.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&");},Remove:function($x,$ix,$ct){var $0=this,$this=this;return $x.substring(0,$ix)+$x.substring($ix+$ct);},Replace:function(xN,xO,xP){var xQ;xQ=function(xR){var xS,xT,xU,xV;xS=xR.indexOf(xO);if(xS!==-1){xU=P.ReplaceOnce(xR,xO,xP);xV=xS+xP.length;xT=P.Substring(xU,0,xS+xP.length)+xQ(xU.substring(xV));}else{xT=xR;}return xT;};return xQ(xN);},ReplaceChar:function(xW,xX,xY){return P.Replace(xW,Y.fromCharCode(xX),Y.fromCharCode(xY));},ReplaceOnce:function($string,$search,$replace){var $0=this,$this=this;return $string.replace($search,$replace);},Split:function(xZ,x0,x1){var x2;x2=P.SplitWith(xZ,x0);return x1===1?e.filter(function(x3){return x3!=="";},x2):x2;},SplitChars:function(x4,x5,x6){var x7;x7="["+P.RegexEscape(Y.fromCharCode.apply(undefined,x5))+"]";return P.Split(x4,new Z(x7),x6);},SplitStrings:function(x8,x9,x_){var x$;x$=P.concat("|",e.map(function(ya){return P.RegexEscape(ya);},x9));return P.Split(x8,new Z(x$),x_);},SplitWith:function($str,$pat){var $0=this,$this=this;return $str.split($pat);},StartsWith:function($t,$s){var $0=this,$this=this;return $t.substring(0,$s.length)==$s;},Substring:function($s,$ix,$ct){var $0=this,$this=this;return $s.substr($ix,$ct);},ToCharArray:function(yb){return e.init(yb.length,function(yc){return yb.charCodeAt(yc);});},ToCharArrayRange:function(yd,ye,yf){return e.init(yf,function(yg){return yd.charCodeAt(ye+yg);});},Trim:function($s){var $0=this,$this=this;return $s.replace(/^\s+/,"").replace(/\s+$/,"");},TrimEnd:function($s){var $0=this,$this=this;return $s.replace(/\s+$/,"");},TrimStart:function($s){var $0=this,$this=this;return $s.replace(/^\s+/,"");},collect:function(yh,yi){return e.init(yi.length,function(yj){return yh(yi.charCodeAt(yj));}).join("");},concat:function(yk,yl){return i.toArray(yl).join(yk);},exists:function(ym,yn){return i.exists(ym,P.protect(yn));},forall:function(yo,yp){return i.forall(yo,P.protect(yp));},init:function(yq,yr){return e.init(yq,yr).join("");},iter:function(ys,yt){return i.iter(ys,P.protect(yt));},iteri:function(yu,yv){return i.iteri(yu,P.protect(yv));},length:function(yw){return P.protect(yw).length;},map:function(yx,yy){return P.collect(function(yz){return Y.fromCharCode(yx(yz));},P.protect(yy));},mapi:function(yA,yB){return i.toArray(i.mapi(function(yC){return function(yD){return Y.fromCharCode((yA(yC))(yD));};},yB)).join("");},protect:function(yE){return yE===null?"":yE;},replicate:function(yF,yG){return P.init(yF,function(){return yG;});}},Unchecked:{Compare:function(yI,yJ){var yK,yL,yM,yN;if(yI===yJ){yK=0;}else{yL=typeof yI;if(yL==="undefined"){yN=typeof yJ;yM=yN==="undefined"?0:-1;}else{yM=yL==="function"?f.FailWith("Cannot compare function values."):yL==="boolean"?yI<yJ?-1:1:yL==="number"?yI<yJ?-1:1:yL==="string"?yI<yJ?-1:1:yI===null?-1:yJ===null?1:"CompareTo"in yI?yI.CompareTo(yJ):(yI instanceof h?yJ instanceof h:false)?j.compareArrays(yI,yJ):(yI instanceof v?yJ instanceof v:false)?j.compareDates(yI,yJ):j.compareArrays(H.GetFields(yI),H.GetFields(yJ));}yK=yM;}return yK;},Equals:function(yO,yP){var yQ,yR;if(yO===yP){yQ=true;}else{yR=typeof yO;yQ=yR==="object"?yO===null?false:yP===null?false:"Equals"in yO?yO.Equals(yP):(yO instanceof h?yP instanceof h:false)?j.arrayEquals(yO,yP):(yO instanceof v?yP instanceof v:false)?j.dateEquals(yO,yP):j.arrayEquals(H.GetFields(yO),H.GetFields(yP)):false;}return yQ;},Hash:function(yS){var yT;yT=typeof yS;return yT==="function"?0:yT==="boolean"?yS?1:0:yT==="number"?yS:yT==="string"?j.hashString(yS):yT==="object"?yS==null?0:yS instanceof h?j.hashArray(yS):j.hashObject(yS):0;},arrayEquals:function(yU,yV){var yW,yX,yY;if(e.length(yU)===e.length(yV)){yX=true;yY=0;while(yX?yY<e.length(yU):false){!j.Equals(e.get(yU,yY),e.get(yV,yY))?yX=false:null;yY=yY+1;}yW=yX;}else{yW=false;}return yW;},compareArrays:function(yZ,y0){var y1,y2,y3,y4;if(e.length(yZ)<e.length(y0)){y1=-1;}else{if(e.length(yZ)>e.length(y0)){y2=1;}else{y3=0;y4=0;while(y3===0?y4<e.length(yZ):false){y3=j.Compare(e.get(yZ,y4),e.get(y0,y4));y4=y4+1;}y2=y3;}y1=y2;}return y1;},compareDates:function(y5,y6){return f.Compare(y5.getTime(),y6.getTime());},dateEquals:function(y7,y8){return y7.getTime()===y8.getTime();},hashArray:function(y9){var y_,y$;y_=-34948909;for(y$=0;y$<=e.length(y9)-1;y$++){y_=j.hashMix(y_,j.Hash(e.get(y9,y$)));}return y_;},hashMix:function(za,zb){return(za<<5)+za+zb;},hashObject:function(zc){var zd,ze,zh;if("GetHashCode"in zc){zd=zc.GetHashCode();}else{ze=function(zf,zg){return j.hashMix(zf,zg);};zh=[0];H.ForEach(zc,function(zi){zh[0]=ze(ze(zh[0],j.hashString(zi)),j.Hash(zc[zi]));return false;});zd=zh[0];}return zd;},hashString:function(zj){var zk,zl,zm;if(zj===null){zk=0;}else{zl=5381;for(zm=0;zm<=zj.length-1;zm++){zl=j.hashMix(zl,zj.charCodeAt(zm)<<0);}zk=zl;}return zk;}},Util:{addListener:function(zn,zo){zn.Subscribe(s.observer(zo));},observer:function(zp){return{OnCompleted:function(){},OnError:function(){},OnNext:zp};},subscribeTo:function(zs,zt){return zs.Subscribe(s.observer(zt));}}}});$.OnInit(function(){a=$.Safe($$.WebSharper.AggregateException);b=$.Safe($$.WebSharper.Exception);c=$.Safe($$.WebSharper.ArgumentException);d=$.Safe($$.Number);e=$.Safe($$.WebSharper.Arrays);f=$.Safe($$.WebSharper.Operators);g=$.Safe($$.WebSharper.IndexOutOfRangeException);h=$.Safe($$.Array);i=$.Safe($$.WebSharper.Seq);j=$.Safe($$.WebSharper.Unchecked);k=$.Safe($$.WebSharper.Enumerator);l=$.Safe($$.WebSharper.Arrays2D);m=$.Safe($$.WebSharper.Concurrency);n=$.Safe($$.WebSharper.Option);o=$.Safe($$.clearTimeout);p=$.Safe($$.setTimeout);q=$.Safe($$.WebSharper.CancellationTokenSource);r=$.Safe($$.WebSharper.Char);s=$.Safe($$.WebSharper.Util);t=$.Safe($$.WebSharper.Lazy);u=$.Safe($$.WebSharper.OperationCanceledException);v=$.Safe($$.Date);w=$.Safe($$.console);x=$.Safe(m.Scheduler);y=$.Safe(k.T);z=$.Safe($$.WebSharper.Html);A=$.Safe(z.Client);B=$.Safe(A.Activator);C=$.Safe($$.document);D=$.Safe($$.jQuery);E=$.Safe($$.WebSharper.Json);F=$.Safe($$.JSON);G=$.Safe($$.WebSharper.JavaScript);H=$.Safe(G.JSModule);I=$.Safe(A.HtmlContentExtensions);J=$.Safe(I.SingleNode);K=$.Safe($$.WebSharper.InvalidOperationException);L=$.Safe($$.WebSharper.List);M=$.Safe(L.T);N=$.Safe($$.WebSharper.MatchFailureException);O=$.Safe($$.Math);P=$.Safe($$.WebSharper.Strings);Q=$.Safe($$.WebSharper.PrintfHelpers);R=$.Safe($$.WebSharper.Remoting);S=$.Safe(R.XhrProvider);T=$.Safe($$.WebSharper.AsyncProxy);U=$.Safe(R.AjaxRemotingProvider);V=$.Safe($$.window);W=$.Safe($$.WebSharper.Enumerable);X=$.Safe($$.WebSharper.Ref);Y=$.Safe($$.String);return Z=$.Safe($$.RegExp);});$.OnLoad(function(){$.Inherit(a,b);$.Inherit(c,b);$.Inherit(g,b);$.Inherit(K,b);$.Inherit(N,b);$.Inherit(u,b);R.EndPoint();R.AjaxProvider();B.Activate();m.scheduler();m.defCTS();m.GetCT();return;});}());

(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o;$.Define($$,{WebSharper:{Testing:{Assert:{For:function(p,q,r){var s,t;for(s=0;s<=a.length(q.Base)-1;s++){r(a.get(q.Base,s));}for(t=1;t<=p;t++){r(q.Next.call(null,null));}return;},Raises:function(u){var v,w;try{u(null);v=b(false,"Assert raises exception test failed.");}catch(w){v=b(true,"Pass.");}return v;}},Pervasives:{Is:function(x,y){var z,A;if(!c.Equals(x,y)){A=[x,y];if(d){d.log.apply(d,["Equality test failed."].concat(A));}z=b(false,"Equality test failed.");}else{z=b(true,"Pass.");}return z;},Isnt:function(B,C){var D,E;if(c.Equals(B,C)){E=[B,C];if(d){d.log.apply(d,["Inequality test failed."].concat(E));}D=b(false,"Inequality test failed.");}else{D=b(true,"Pass.");}return D;},Test:function(F){return g.New(F);},TestBuilder:$.Class({Delay:function(G){return h(this.name,G);},Zero:function(){return null;}},{New:function(H){var I;I=$.New(this,{});I.name=H;return I;}})},Random:{ArrayOf:function(J){return{Base:[[]],Next:function(){var L;L=i.Natural().Next.call(null,null)%100;return a.init(L,function(){return J.Next.call(null,null);});}};},Boolean:$.Field(function(){return{Base:[true,false],Next:function(){return i.StandardUniform().Next.call(null,null)>0.5;}};}),Const:function(O){return{Base:[O],Next:function(){return O;}};},Exponential:function(Q){return{Base:[],Next:function(){var S;S=i.StandardUniform().Next.call(null,null);return-j.log(1-S)/Q;}};},Float:$.Field(function(){return{Base:[0],Next:function(){var U;U=i.Boolean().Next.call(null,null)?1:-1;return U*i.Exponential(0.1).Next.call(null,null);}};}),FloatExhaustive:$.Field(function(){return{Base:[0,k,l,-l],Next:function(){return i.Float().Next.call(null,null);}};}),FloatWithin:function(W,X){return{Base:[W,X],Next:function(){return W+(X-W)*j.random();}};},Implies:function(Z,_0){return!Z?true:_0;},Imply:function(_1,_2){return i.Implies(_1,_2);},Int:$.Field(function(){return{Base:[0,1,-1],Next:function(){return j.round(i.Float().Next.call(null,null));}};}),ListOf:function(_4){var _5,_7;_5=function(_6){return m.ofArray(_6);};_7=i.ArrayOf(_4);return i.Map(_5,_7);},Map:function(_8,_9){var _;_=_9.Next;return{Base:a.map(_8,_9.Base),Next:function(ba){return _8(_(ba));}};},Mix:function(ba,bb){var bc;bc=[false];return{Base:ba.Base.concat(bb.Base),Next:function(){bc[0]=!bc[0];return bc[0]?ba.Next.call(null,null):bb.Next.call(null,null);}};},Natural:$.Field(function(){var be;be=i.Int().Next;return{Base:[0,1],Next:function(bf){var bg;bg=be(bf);return j.abs(bg);}};}),OneOf:function(bh){var bi;bi=i.Within(1,a.length(bh));return{Base:bh,Next:function(){return a.get(bh,bi.Next.call(null,null)-1);}};},OptionOf:function(bk){return i.Mix(i.Const({$:0}),i.Map(function(bl){return{$:1,$0:bl};},bk));},StandardUniform:$.Field(function(){return{Base:[],Next:function(){return j.random();}};}),String:$.Field(function(){return{Base:[""],Next:function(){var bo,bp;bo=i.Natural().Next.call(null,null)%100;bp=a.init(bo,function(){return i.Int().Next.call(null,null)%256;});return n.fromCharCode.apply(undefined,bp);}};}),StringExhaustive:$.Field(function(){return{Base:[null,""],Next:i.String().Next};}),Tuple2Of:function(br,bs){return{Base:o.toArray(o.delay(function(){return o.collect(function(bu){return o.map(function(bv){return[bu,bv];},bs.Base);},br.Base);})),Next:function(){return[br.Next.call(null,null),bs.Next.call(null,null)];}};},Tuple3Of:function(bx,by,bz){return{Base:o.toArray(o.delay(function(){return o.collect(function(bB){return o.collect(function(bC){return o.map(function(bD){return[bB,bC,bD];},bz.Base);},by.Base);},bx.Base);})),Next:function(){return[bx.Next.call(null,null),by.Next.call(null,null),bz.Next.call(null,null)];}};},Within:function(bF,bG){return{Base:[bF,bG],Next:function(){return i.Natural().Next.call(null,null)%(bG-bF)+bF;}};}}}}});$.OnInit(function(){a=$.Safe($$.WebSharper.Arrays);b=$.Safe($$.ok);c=$.Safe($$.WebSharper.Unchecked);d=$.Safe($$.console);e=$.Safe($$.WebSharper.Testing);f=$.Safe(e.Pervasives);g=$.Safe(f.TestBuilder);h=$.Safe($$.test);i=$.Safe(e.Random);j=$.Safe($$.Math);k=$.Safe($$.NaN);l=$.Safe($$.Infinity);m=$.Safe($$.WebSharper.List);n=$.Safe($$.String);return o=$.Safe($$.WebSharper.Seq);});$.OnLoad(function(){i.StringExhaustive();i.String();i.StandardUniform();i.Natural();i.Int();i.FloatExhaustive();i.Float();i.Boolean();return;});}());

(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t;$.Define($$,{WebSharper:{Html:{Client:{Attr:{Attr:$.Field(function(){return c.Attr();})},Attribute:$.Class({get_Body:function(){var u;u=this.HtmlProvider.CreateAttribute(this.Name);u.value=this.Value;return u;}},{New:function(v,w,x){var y;y=d.New1(v);y.Name=w;y.Value=x;return y;},New1:function(z){var A;A=$.New(this,e.New());A.HtmlProvider=z;return A;}}),AttributeBuilder:$.Class({NewAttr:function(B,C){var D;D=d.New(this.HtmlProvider,B,C);return D;}},{New:function(E){var F;F=$.New(this,{});F.HtmlProvider=E;return F;}}),Default:{OnLoad:function(G){return c.HtmlProvider().OnDocumentReady(G);}},DeprecatedAttributeBuilder:$.Class({NewAttr:function(H,I){var J;J=d.New(this.HtmlProvider,H,I);return J;}},{New:function(K){var L;L=$.New(this,{});L.HtmlProvider=K;return L;}}),DeprecatedTagBuilder:$.Class({NewTag:function(M,N){var O,P,Q;O=f.New(this.HtmlProvider,M);P=g.Get(N);while(P.MoveNext()){Q=P.get_Current();O.AppendI(Q);}return O;}},{New:function(R){var S;S=$.New(this,{});S.HtmlProvider=R;return S;}}),Element:$.Class({AppendI:function(T){var U,V,W,X,Y,Z,_0,_1,_2;U=T.get_Body();if(U.nodeType===2){W=this["HtmlProvider@33"];X=this.get_Body();V=W.AppendAttribute(X,U);}else{Y=this["HtmlProvider@33"];Z=this.get_Body();_0=T.get_Body();V=Y.AppendNode(Z,_0);}if(this.IsRendered){_1=T.Render();}else{_2=this.RenderInternal;_1=void(this.RenderInternal=function(){_2(null);return T.Render();});}return _1;},AppendN:function(_4){var _5,_6;_5=this["HtmlProvider@33"];_6=this.get_Body();return _5.AppendNode(_6,_4);},OnLoad:function(_7){var _8,_9;_8=this["HtmlProvider@33"];_9=this.get_Body();return _8.OnLoad(_9,_7);},Render:function(){var _;if(!this.IsRendered){this.RenderInternal.call(null,null);_=void(this.IsRendered=true);}else{_=null;}return _;},get_Body:function(){return this.Dom;},get_Html:function(){return this["HtmlProvider@33"].GetHtml(this.get_Body());},get_HtmlProvider:function(){return this["HtmlProvider@33"];},get_Id:function(){var ba,bb,bc,bd,be,bf,bg;ba=this["HtmlProvider@33"];bb=this.get_Body();bc=ba.GetProperty(bb,"id");if(bc===undefined?true:bc===""){be="id"+h.round(h.random()*100000000);bf=this["HtmlProvider@33"];bg=this.get_Body();bf.SetProperty(bg,"id",be);bd=be;}else{bd=bc;}return bd;},get_Item:function(bg){var bh,bi,bj,bk;bh=this["HtmlProvider@33"];bi=this.get_Body();bh.GetAttribute(bi,bg);bj=this["HtmlProvider@33"];bk=this.get_Body();return bj.GetAttribute(bk,bg);},get_Text:function(){return this["HtmlProvider@33"].GetText(this.get_Body());},get_Value:function(){return this["HtmlProvider@33"].GetValue(this.get_Body());},set_Html:function(bl){var bm,bn;bm=this["HtmlProvider@33"];bn=this.get_Body();return bm.SetHtml(bn,bl);},set_Item:function(bo,bp){var bq,br;bq=this["HtmlProvider@33"];br=this.get_Body();return bq.SetAttribute(br,bo,bp);},set_Text:function(bs){var bt,bu;bt=this["HtmlProvider@33"];bu=this.get_Body();return bt.SetText(bu,bs);},set_Value:function(bv){var bw,bx;bw=this["HtmlProvider@33"];bx=this.get_Body();return bw.SetValue(bx,bv);}},{New:function(by,bz){var bA,bB;bA=f.New1(by);bB=i.createElement(bz);bA.RenderInternal=function(){};bA.Dom=bB;bA.IsRendered=false;return bA;},New1:function(bD){var bE;bE=$.New(this,e.New());bE["HtmlProvider@33"]=bD;return bE;}}),Events:{JQueryEventSupport:$.Class({OnBlur:function(bF,bG){return j(bG.get_Body()).bind("blur",function(){return bF(bG);});},OnChange:function(bH,bI){return j(bI.get_Body()).bind("change",function(){return bH(bI);});},OnClick:function(bJ,bK){return this.OnMouse("click",bJ,bK);},OnDoubleClick:function(bL,bM){return this.OnMouse("dblclick",bL,bM);},OnError:function(bN,bO){return j(bO.get_Body()).bind("error",function(){return bN(bO);});},OnEvent:function(bP,bQ,bR){return j(bR.get_Body()).bind(bP,function(bS){return(bQ(bR))(bS);});},OnFocus:function(bT,bU){return j(bU.get_Body()).bind("focus",function(){return bT(bU);});},OnKeyDown:function(bV,bW){return j(bW.get_Body()).bind("keydown",function(bX){return(bV(bW))({KeyCode:bX.keyCode,Event:bX});});},OnKeyPress:function(bY,bZ){return j(bZ.get_Body()).keypress(function(b0){return(bY(bZ))({CharacterCode:b0.which,Event:b0});});},OnKeyUp:function(b1,b2){return j(b2.get_Body()).bind("keyup",function(b3){return(b1(b2))({KeyCode:b3.keyCode,Event:b3});});},OnLoad:function(b4,b5){return j(b5.get_Body()).bind("load",function(){return b4(b5);});},OnMouse:function(b6,b7,b8){return j(b8.get_Body()).bind(b6,function(b9){return(b7(b8))({X:b9.pageX,Y:b9.pageY,Event:b9});});},OnMouseDown:function(b_,b$){return this.OnMouse("mousedown",b_,b$);},OnMouseEnter:function(ca,cb){return this.OnMouse("mouseenter",ca,cb);},OnMouseLeave:function(cc,cd){return this.OnMouse("mouseleave",cc,cd);},OnMouseMove:function(ce,cf){return this.OnMouse("mousemove",ce,cf);},OnMouseOut:function(cg,ch){return this.OnMouse("mouseout",cg,ch);},OnMouseUp:function(ci,cj){return this.OnMouse("mouseup",ci,cj);},OnResize:function(ck,cl){return j(cl.get_Body()).bind("resize",function(){return ck(cl);});},OnScroll:function(cm,cn){return j(cn.get_Body()).bind("scroll",function(){return cm(cn);});},OnSelect:function(co,cp){return j(cp.get_Body()).bind("select",function(){return co(cp);});},OnSubmit:function(cq,cr){return j(cr.get_Body()).bind("submit",function(){return cq(cr);});},OnUnLoad:function(cs,ct){return j(ct.get_Body()).bind("unload",function(){return cs(ct);});}},{New:function(){return $.New(this,{});}})},EventsPervasives:{Events:$.Field(function(){return l.New();})},Implementation:{Attr:$.Field(function(){return m.New(c.HtmlProvider());}),DeprecatedHtml:$.Field(function(){return n.New(c.HtmlProvider());}),HtmlProvider:$.Field(function(){return o.New();}),JQueryHtmlProvider:$.Class({AddClass:function(cu,cv){return j(cu).addClass(cv);},AppendAttribute:function(cw,cx){var cy,cz;cy=cx.nodeName;cz=cx.value;return this.SetAttribute(cw,cy,cz);},AppendNode:function(cA,cB){return j(cA).append(j(cB));},Clear:function(cC){return j(cC).contents().detach();},CreateAttribute:function(cD){return i.createAttribute(cD);},CreateElement:function(cE){return i.createElement(cE);},CreateTextNode:function(cF){return i.createTextNode(cF);},GetAttribute:function(cG,cH){return j(cG).attr(cH);},GetHtml:function(cI){return j(cI).html();},GetProperty:function(cJ,cK){var cL;cL=j(cJ).prop(cK);return cL;},GetText:function(cM){return cM.textContent;},GetValue:function(cN){var cO;cO=j(cN).val();return cO;},HasAttribute:function(cP,cQ){return j(cP).attr(cQ)!=null;},OnDocumentReady:function(cR){return j(i).ready(cR);},OnLoad:function(cS,cT){return j(cS).ready(cT);},Remove:function(cU){return j(cU).remove();},RemoveAttribute:function(cV,cW){return j(cV).removeAttr(cW);},RemoveClass:function(cX,cY){return j(cX).removeClass(cY);},SetAttribute:function(cZ,c0,c1){return j(cZ).attr(c0,c1);},SetCss:function(c2,c3,c4){return j(c2).css(c3,c4);},SetHtml:function(c5,c6){return j(c5).html(c6);},SetProperty:function(c7,c8,c9){var c_;c_=j(c7).prop(c8,c9);return c_;},SetStyle:function(c$,da){return j(c$).attr("style",da);},SetText:function(db,dc){db.textContent=dc;},SetValue:function(dd,de){return j(dd).val(de);}},{New:function(){return $.New(this,{});}}),Tags:$.Field(function(){return p.New(c.HtmlProvider());})},Operators:{OnAfterRender:function(df,dg){var dh;dh=dg.Render;dg.Render=function(){dh.apply(dg);return df(dg);};return;},OnBeforeRender:function(dj,dk){var dl;dl=dk.Render;dk.Render=function(){dj(dk);return dl.apply(dk);};return;},add:function(dn,_do){var dp,dq;dp=g.Get(_do);while(dp.MoveNext()){dq=dp.get_Current();dn.AppendI(dq);}return dn;}},Pagelet:$.Class({AppendTo:function(dr){var ds,dt;ds=i.getElementById(dr);dt=ds.appendChild(this.get_Body());return this.Render();},Render:function(){return null;},ReplaceInDom:function(du){var dv;dv=du.parentNode.replaceChild(this.get_Body(),du);return this.Render();}},{New:function(){return $.New(this,{});}}),TagBuilder:$.Class({NewTag:function(dw,dx){var dy,dz,dA;dy=f.New(this.HtmlProvider,dw);dz=g.Get(dx);while(dz.MoveNext()){dA=dz.get_Current();dy.AppendI(dA);}return dy;},text:function(dB){return q.New(dB);}},{New:function(dC){var dD;dD=$.New(this,{});dD.HtmlProvider=dC;return dD;}}),Tags:{Deprecated:$.Field(function(){return c.DeprecatedHtml();}),Tags:$.Field(function(){return c.Tags();})},Text:$.Class({get_Body:function(){return i.createTextNode(this.text);}},{New:function(dE){var dF;dF=$.New(this,e.New());dF.text=dE;return dF;}})}}}});$.OnInit(function(){a=$.Safe($$.WebSharper.Html);b=$.Safe(a.Client);c=$.Safe(b.Implementation);d=$.Safe(b.Attribute);e=$.Safe(b.Pagelet);f=$.Safe(b.Element);g=$.Safe($$.WebSharper.Enumerator);h=$.Safe($$.Math);i=$.Safe($$.document);j=$.Safe($$.jQuery);k=$.Safe(b.Events);l=$.Safe(k.JQueryEventSupport);m=$.Safe(b.AttributeBuilder);n=$.Safe(b.DeprecatedTagBuilder);o=$.Safe(c.JQueryHtmlProvider);p=$.Safe(b.TagBuilder);q=$.Safe(b.Text);r=$.Safe(b.Attr);s=$.Safe(b.EventsPervasives);return t=$.Safe(b.Tags);});$.OnLoad(function(){$.Inherit(d,e);$.Inherit(f,e);$.Inherit(q,e);t.Tags();t.Deprecated();c.Tags();c.HtmlProvider();c.DeprecatedHtml();c.Attr();s.Events();r.Attr();return;});}());

(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E;$.Define($$,{WebSharper:{Control:{Disposable:{Of:function(F){return{Dispose:F};}},Event:{Event:$.Class({AddHandler:function(G){return this.Handlers.Add(G);},RemoveHandler:function(H){var I,K,L,N,O;I=function(J){return a.Equals(H,J);};K=this.Handlers;L=function(M){return K.RemoveAt(M);};N=this.Handlers;O=b.tryFindIndex(I,N);return c.iter(L,O);},Subscribe:function(P){var Q,T=this;Q=function(R){return P.OnNext(R);};this.AddHandler(Q);return e.Of(function(){return T.RemoveHandler(Q);});},Trigger:function(U){var V,W,X;V=this.Handlers.ToArray();for(W=0;W<=V.length-1;W++){X=f.get(V,W);X(U);}return;}})},EventModule:{Choose:function(Y,Z){var _0;_0=g.New();h.addListener(Z,function(_1){var _2,_3,_4;_2=Y(_1);if(_2.$==0){_3=null;}else{_4=_2.$0;_3=_0.event.Trigger(_4);}return _3;});return _0.event;},Filter:function(_5,_6){var _7;_7=$.New(j,{Handlers:m.New2()});h.addListener(_6,function(_8){return _5(_8)?_7.Trigger(_8):null;});return _7;},Map:function(_9,_){var ba;ba=$.New(j,{Handlers:m.New2()});h.addListener(_,function(bb){return ba.Trigger(_9(bb));});return ba;},Merge:function(bb,bc){var bd;bd=$.New(j,{Handlers:m.New2()});h.addListener(bb,function(be){return bd.Trigger(be);});h.addListener(bc,function(bf){return bd.Trigger(bf);});return bd;},Pairwise:function(bg){var bh,bi;bh=[{$:0}];bi=$.New(j,{Handlers:m.New2()});h.addListener(bg,function(bj){var bk,bl,bm;bk=bh[0];if(bk.$==1){bm=bk.$0;bh[0]={$:1,$0:bj};bl=bi.Trigger([bm,bj]);}else{bl=void(bh[0]={$:1,$0:bj});}return bl;});return bi;},Partition:function(bn,bo){return[n.Filter(bn,bo),n.Filter(function(bp){var bq;bq=bn(bp);return!bq;},bo)];},Scan:function(br,bs,bt){var bu,bv;bu=[bs];bv=function(bw){bu[0]=(br(bu[0]))(bw);return bu[0];};return n.Map(bv,bt);},Split:function(bx,by){var bz,bE;bz=function(bA){var bB,bC,bD;bB=bx(bA);if(bB.$==0){bD=bB.$0;bC={$:1,$0:bD};}else{bC={$:0};}return bC;};bE=function(bF){var bG,bH,bI;bG=bx(bF);if(bG.$==1){bI=bG.$0;bH={$:1,$0:bI};}else{bH={$:0};}return bH;};return[n.Choose(bz,by),n.Choose(bE,by)];}},FSharpEvent:$.Class({},{New:function(){var bJ;bJ=$.New(this,{});bJ.event=$.New(j,{Handlers:m.New2()});return bJ;}}),HotStream:{HotStream:$.Class({Subscribe:function(bK){var bL;this.Latest[0].$==1?bK.OnNext(this.Latest[0].$0):null;bL=h.subscribeTo(this.Event.event,function(bM){return bK.OnNext(bM);});return bL;},Trigger:function(bN){this.Latest[0]={$:1,$0:bN};return this.Event.event.Trigger(bN);}},{New:function(){return $.New(p,{Latest:[{$:0}],Event:g.New()});}})},MailboxProcessor:$.Class({PostAndAsyncReply:function(bO,bP){var bR=this;return q.Delay(function(){return q.Bind(bR.PostAndTryAsyncReply(bO,bP),function(bS){var bT,bU;if(bS.$==1){bU=bS.$0;bT=bU;}else{bT=r.Raise(new s("TimeoutException"));}return q.Return(bT);});});},PostAndTryAsyncReply:function(bV,bW){var bX,bY,b6=this;bX=r.DefaultArg(bW,this.get_DefaultTimeout());bY=function(bZ){var b0,b1,b2,b3,b4,b7,b8,b$;b0=bZ[0];b1=bZ[1];b2=bZ[2];if(bX<0){b4=bV(function(b5){return b0({$:1,$0:b5});});b6.mailbox.AddLast(b4);b3=b6.resume();}else{b7=[true];b8=bV(function(b9){var b_;if(b7[0]){b7[0]=false;b_=b0({$:1,$0:b9});}else{b_=null;}return b_;});b6.mailbox.AddLast(b8);b6.resume();b$=t(function(){var cb;if(b7[0]){b7[0]=false;cb=b0({$:0});}else{cb=null;}return cb;},bX);b3=void b$;}return b3;};return q.FromContinuations(bY);},Receive:function(cc){var ce=this;return q.Delay(function(){return q.Bind(ce.TryReceive(cc),function(cf){var cg,ch;if(cf.$==1){ch=cf.$0;cg=ch;}else{cg=r.Raise(new s("TimeoutException"));}return q.Return(cg);});});},Scan:function(ci,cj){var cl=this;return q.Delay(function(){return q.Bind(cl.TryScan(ci,cj),function(cm){var cn,co;if(cm.$==1){co=cm.$0;cn=co;}else{cn=r.Raise(new s("TimeoutException"));}return q.Return(cn);});});},Start:function(){var cp,cq,ct=this;if(this.started){cp=r.FailWith("The MailboxProcessor has already been started.");}else{this.started=true;cq=q.Delay(function(){return q.TryWith(q.Delay(function(){return q.Bind(ct.initial.call(null,ct),function(){return q.Return(null);});}),function(cv){ct.errorEvent.event.Trigger(cv);return q.Return(null);});});cp=ct.startAsync(cq);}return cp;},TryReceive:function(cw){var cx,cy,cD=this;cx=r.DefaultArg(cw,this.get_DefaultTimeout());cy=function(cz){var cA,cB,cC,cE,cF,cG,cJ,cK,cN,cR;cA=cz[0];cB=cz[1];cC=cz[2];if(a.Equals(cD.mailbox.get_First(),null)){if(cx<0){cG=q.Delay(function(){var cI;cI=cD.dequeue();cA({$:1,$0:cI});return q.Return(null);});cF=void(cD.savedCont={$:1,$0:cG});}else{cJ=[true];cK=t(function(){var cM;if(cJ[0]){cJ[0]=false;cD.savedCont={$:0};cM=cA({$:0});}else{cM=null;}return cM;},cx);cN=q.Delay(function(){var cP,cQ;if(cJ[0]){cJ[0]=false;u(cK);cQ=cD.dequeue();cA({$:1,$0:cQ});cP=q.Return(null);}else{cP=q.Return(null);}return cP;});cF=void(cD.savedCont={$:1,$0:cN});}cE=cF;}else{cR=cD.dequeue();cE=cA({$:1,$0:cR});}return cE;};return q.FromContinuations(cy);},TryScan:function(cS,cT){var cU,cZ=this;cU=r.DefaultArg(cT,this.get_DefaultTimeout());return q.Delay(function(){var cW,c3,c4,c5,c7;cW=function(){var cY,c0,c1,c2;cY=cZ.mailbox.get_First();c0={$:0};while(!a.Equals(cY,null)){c1=cS(cY.v);if(c1.$==0){c2=cY=cY.n;}else{cZ.mailbox.Remove(cY);cY=null;c2=c0=c1;}}return c0;};c3=cW(null);if(c3.$==1){c5=c3.$0;c4=q.Bind(c5,function(c6){return q.Return({$:1,$0:c6});});}else{c7=function(c8){var c9,c_,c$,da,db,dj,dk,dn;c9=c8[0];c_=c8[1];c$=c8[2];if(cU<0){db=function(){var dd;dd=q.Delay(function(){var df,dg,dh;df=cS(cZ.mailbox.get_First().v);if(df.$==1){dh=df.$0;cZ.mailbox.RemoveFirst();dg=q.Bind(dh,function(di){c9({$:1,$0:di});return q.Return(null);});}else{db(null);dg=q.Return(null);}return dg;});cZ.savedCont={$:1,$0:dd};return;};da=db(null);}else{dj=[true];dk=t(function(){var dm;if(dj[0]){dj[0]=false;cZ.savedCont={$:0};dm=c9({$:0});}else{dm=null;}return dm;},cU);dn=function(){var dp;dp=q.Delay(function(){var dr,ds,dt;dr=cS(cZ.mailbox.get_First().v);if(dr.$==1){dt=dr.$0;cZ.mailbox.RemoveFirst();ds=q.Bind(dt,function(du){var dv;if(dj[0]){dj[0]=false;u(dk);c9({$:1,$0:du});dv=q.Return(null);}else{dv=q.Return(null);}return dv;});}else{dn(null);ds=q.Return(null);}return ds;});cZ.savedCont={$:1,$0:dp};return;};da=dn(null);}return da;};c4=q.FromContinuations(c7);}return c4;});},dequeue:function(){var dw;dw=this.mailbox.get_First().v;this.mailbox.RemoveFirst();return dw;},get_CurrentQueueLength:function(){return this.mailbox.get_Count();},get_DefaultTimeout:function(){return this["DefaultTimeout@"];},get_Error:function(){return this.errorEvent.event;},resume:function(){var dx,dy,dz;dx=this.savedCont;if(dx.$==1){dz=dx.$0;this.savedCont={$:0};dy=this.startAsync(dz);}else{dy=null;}return dy;},set_DefaultTimeout:function(dA){this["DefaultTimeout@"]=dA;return;},startAsync:function(dB){return q.Start(dB,this.token);}},{New:function(dC,dD){var dE,dF,dG,dH,dI;dE=$.New(this,{});dE.initial=dC;dE.token=dD;dE.started=false;dE.errorEvent=g.New();dE.mailbox=w.New();dE.savedCont={$:0};dF=dE.token;if(dF.$==0){dG=null;}else{dH=dF.$0;dI=q.Register(dH,function(){return function(){return dE.resume();}();});dG=void dI;}dE["DefaultTimeout@"]=-1;return dE;},Start:function(dL,dM){var dN;dN=x.New(dL,dM);dN.Start();return dN;}}),Observable:{Aggregate:function(dO,dP,dQ){var dR;dR=function(dS){var dT,dU,dZ;dT=[dP];dU=function(dV){return y.Protect(function(){return(dQ(dT[0]))(dV);},function(dX){dT[0]=dX;return dS.OnNext(dX);},function(dY){return dS.OnError(dY);});};dZ=z.New(dU,function(d0){return dS.OnError(d0);},function(){return dS.OnCompleted();});return dO.Subscribe(dZ);};return y.New(dR);},Choose:function(d2,d3){var d4;d4=function(d5){var d6,eb;d6=function(d7){var d9;d9=function(d_){return d5.OnNext(d_);};return y.Protect(function(){return d2(d7);},function(d$){return c.iter(d9,d$);},function(ea){return d5.OnError(ea);});};eb=z.New(d6,function(ec){return d5.OnError(ec);},function(){return d5.OnCompleted();});return d3.Subscribe(eb);};return y.New(d4);},CombineLatest:function(ee,ef,eg){var eh;eh=function(ei){var ej,ek,el,ev,ex,eA,eC,eF,eG;ej=[{$:0}];ek=[{$:0}];el=function(){var en,eo,ep,eq,er;en=[ej[0],ek[0]];if(en[0].$==1){if(en[1].$==1){eq=en[0].$0;er=en[1].$0;ep=y.Protect(function(){return(eg(eq))(er);},function(et){return ei.OnNext(et);},function(eu){return ei.OnError(eu);});}else{ep=null;}eo=ep;}else{eo=null;}return eo;};ev=function(ew){ej[0]={$:1,$0:ew};return el(null);};ex=z.New(ev,function(){},function(){});eA=function(eB){ek[0]={$:1,$0:eB};return el(null);};eC=z.New(eA,function(){},function(){});eF=ee.Subscribe(ex);eG=ef.Subscribe(eC);return e.Of(function(){eF.Dispose();return eG.Dispose();});};return y.New(eh);},Concat:function(eI,eJ){var eK;eK=function(eL){var eM,eN,eS;eM=[{$:0}];eN=eI.Subscribe(z.New(function(eO){return eL.OnNext(eO);},function(){},function(){var eR;eR=eJ.Subscribe(eL);eM[0]={$:1,$0:eR};}));eS=function(){eM[0].$==1?eM[0].$0.Dispose():null;return eN.Dispose();};return e.Of(eS);};return y.New(eK);},Drop:function(eU,eV){var eW;eW=function(eX){var eY,eZ,e1;eY=[0];eZ=function(e0){A.incr(eY);return eY[0]>eU?eX.OnNext(e0):null;};e1=z.New(eZ,function(e2){return eX.OnError(e2);},function(){return eX.OnCompleted();});return eV.Subscribe(e1);};return y.New(eW);},Filter:function(e4,e5){var e6;e6=function(e7){var e8,fd;e8=function(e9){var e$;e$=function(fa){return e7.OnNext(fa);};return y.Protect(function(){return e4(e9)?{$:1,$0:e9}:{$:0};},function(fb){return c.iter(e$,fb);},function(fc){return e7.OnError(fc);});};fd=z.New(e8,function(fe){return e7.OnError(fe);},function(){return e7.OnCompleted();});return e5.Subscribe(fd);};return y.New(e6);},Map:function(fg,fh){var fi;fi=function(fj){var fk,fp;fk=function(fl){return y.Protect(function(){return fg(fl);},function(fn){return fj.OnNext(fn);},function(fo){return fj.OnError(fo);});};fp=z.New(fk,function(fq){return fj.OnError(fq);},function(){return fj.OnCompleted();});return fh.Subscribe(fp);};return y.New(fi);},Merge:function(fs,ft){var fu;fu=function(fv){var fw,fx,fy,fC,fD,fH;fw=[false];fx=[false];fy=z.New(function(fz){return fv.OnNext(fz);},function(){},function(){fw[0]=true;return(fw[0]?fx[0]:false)?fv.OnCompleted():null;});fC=fs.Subscribe(fy);fD=z.New(function(fE){return fv.OnNext(fE);},function(){},function(){fx[0]=true;return(fw[0]?fx[0]:false)?fv.OnCompleted():null;});fH=ft.Subscribe(fD);return e.Of(function(){fC.Dispose();return fH.Dispose();});};return y.New(fu);},Never:function(){return y.New(function(){return e.Of(function(){});});},New:function(fL){return $.New(B,{Subscribe1:fL});},Observable:$.Class({Subscribe:function(fM){return this.Subscribe1.call(null,fM);}}),Of:function(fN){return y.New(function(fO){return e.Of(fN(function(fP){return fO.OnNext(fP);}));});},Protect:function(fQ,fR,fS){var fT,fU,fV,fW,fX,fY;try{fU={$:0,$0:fQ(null)};}catch(fV){fU={$:1,$0:fV};}fT=fU;if(fT.$==1){fX=fT.$0;fW=fS(fX);}else{fY=fT.$0;fW=fR(fY);}return fW;},Range:function(fZ,f0){var f1;f1=function(f2){var f3;for(f3=fZ;f3<=fZ+f0;f3++){f2.OnNext(f3);}return e.Of(function(){});};return y.New(f1);},Return:function(f5){var f6;f6=function(f7){f7.OnNext(f5);f7.OnCompleted();return e.Of(function(){});};return y.New(f6);},SelectMany:function(f9){return y.New(function(f_){var f$,gb;f$=[function(){}];gb=h.subscribeTo(f9,function(gc){var gd;gd=h.subscribeTo(gc,function(ge){return f_.OnNext(ge);});f$[0]=function(){f$[0].call(null,null);return gd.Dispose();};return;});return e.Of(function(){f$[0].call(null,null);return gb.Dispose();});});},Sequence:function(gh){var gi;gi=function(gj){var gk,gl,gm,gn;if(gj.$==1){gl=gj.$1;gm=gj.$0;gn=gi(gl);gk=y.CombineLatest(gm,gn,function(go){return function(gp){return $.New(D,{$:1,$0:go,$1:gp});};});}else{gk=y.Return($.New(D,{$:0}));}return gk;};return gi(C.ofSeq(gh));},Switch:function(gq){return y.New(function(gr){var gs,gt,gu;gs=[0];gt=[{$:0}];gu=h.subscribeTo(gq,function(gv){var gw,gx,gz;A.incr(gs);gt[0].$==1?gt[0].$0.Dispose():null;gw=gs[0];gx=h.subscribeTo(gv,function(gy){return gw===gs[0]?gr.OnNext(gy):null;});gz={$:1,$0:gx};gt[0]=gz;return;});return gu;});}},ObservableModule:{Pairwise:function(gA){var gB;gB=function(gC){var gD,gE,gJ;gD=[{$:0}];gE=function(gF){var gG,gH,gI;gG=gD[0];if(gG.$==1){gI=gG.$0;gH=gC.OnNext([gI,gF]);}else{gH=null;}gD[0]={$:1,$0:gF};return;};gJ=z.New(gE,function(gK){return gC.OnError(gK);},function(){return gC.OnCompleted();});return gA.Subscribe(gJ);};return y.New(gB);},Partition:function(gM,gN){return[y.Filter(gM,gN),y.Filter(function(gO){var gP;gP=gM(gO);return!gP;},gN)];},Scan:function(gQ,gR,gS){var gT;gT=function(gU){var gV,gW,g1;gV=[gR];gW=function(gX){return y.Protect(function(){return(gQ(gV[0]))(gX);},function(gZ){gV[0]=gZ;return gU.OnNext(gZ);},function(g0){return gU.OnError(g0);});};g1=z.New(gW,function(g2){return gU.OnError(g2);},function(){return gU.OnCompleted();});return gS.Subscribe(g1);};return y.New(gT);},Split:function(g4,g5){var g6,g$,ha,hf;g6=function(g7){var g8,g9,g_;g8=g4(g7);if(g8.$==0){g_=g8.$0;g9={$:1,$0:g_};}else{g9={$:0};}return g9;};g$=y.Choose(g6,g5);ha=function(hb){var hc,hd,he;hc=g4(hb);if(hc.$==1){he=hc.$0;hd={$:1,$0:he};}else{hd={$:0};}return hd;};hf=y.Choose(ha,g5);return[g$,hf];}},Observer:{New:function(hg,hh,hi){return $.New(E,{onNext:hg,onError:hh,onCompleted:hi});},Observer:$.Class({OnCompleted:function(){return this.onCompleted.call(null,null);},OnError:function(hj){return this.onError.call(null,hj);},OnNext:function(hk){return this.onNext.call(null,hk);}}),Of:function(hl){return $.New(E,{onNext:function(hm){return hl(hm);},onError:function(hn){return r.Raise(hn);},onCompleted:function(){return null;}});}}}}});$.OnInit(function(){a=$.Safe($$.WebSharper.Unchecked);b=$.Safe($$.WebSharper.Seq);c=$.Safe($$.WebSharper.Option);d=$.Safe($$.WebSharper.Control);e=$.Safe(d.Disposable);f=$.Safe($$.WebSharper.Arrays);g=$.Safe(d.FSharpEvent);h=$.Safe($$.WebSharper.Util);i=$.Safe(d.Event);j=$.Safe(i.Event);k=$.Safe($$.WebSharper.Collections);l=$.Safe(k.ResizeArray);m=$.Safe(l.ResizeArrayProxy);n=$.Safe(d.EventModule);o=$.Safe(d.HotStream);p=$.Safe(o.HotStream);q=$.Safe($$.WebSharper.Concurrency);r=$.Safe($$.WebSharper.Operators);s=$.Safe($$.Error);t=$.Safe($$.setTimeout);u=$.Safe($$.clearTimeout);v=$.Safe(k.LinkedList);w=$.Safe(v.T);x=$.Safe(d.MailboxProcessor);y=$.Safe(d.Observable);z=$.Safe(d.Observer);A=$.Safe($$.WebSharper.Ref);B=$.Safe(y.Observable);C=$.Safe($$.WebSharper.List);D=$.Safe(C.T);return E=$.Safe(z.Observer);});$.OnLoad(function(){return;});}());

(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B;$.Define($$,{WebSharper:{Collections:{BalancedTree:{Add:function(C,D){return b.Put(function(){return function(F){return F;};},C,D);},Branch:function(G,H,I){return{Node:G,Left:H,Right:I,Height:1+c.Max(H==null?0:H.Height,I==null?0:I.Height),Count:1+(H==null?0:H.Count)+(I==null?0:I.Count)};},Build:function(J,K,L){var M,N,O,P,Q;M=L-K+1;if(M<=0){N=null;}else{O=(K+L)/2>>0;P=b.Build(J,K,O-1);Q=b.Build(J,O+1,L);N=b.Branch(d.get(J,O),P,Q);}return N;},Contains:function(R,S){return!((b.Lookup(R,S))[0]==null);},Enumerate:function(T,U){var V;V=function(W){var X,Y,Z,_0,_1,_2,_3;X=W[0];Y=W[1];if(X==null){if(Y.$==1){_1=Y.$0[0];_2=Y.$1;_3=Y.$0[1];_0={$:1,$0:[_1,[_3,_2]]};}else{_0={$:0};}Z=_0;}else{Z=T?V([X.Right,$.New(g,{$:1,$0:[X.Node,X.Left],$1:Y})]):V([X.Left,$.New(g,{$:1,$0:[X.Node,X.Right],$1:Y})]);}return Z;};return e.unfold(V,[U,$.New(g,{$:0})]);},Lookup:function(_4,_5){var _6,_7,_8,_9,_,ba;_6=[];_7=_5;_8=true;while(_8){if(_7==null){_9=_8=false;}else{_=c.Compare(_4,_7.Node);if(_===0){ba=_8=false;}else{if(_===1){_6.unshift([true,_7.Node,_7.Left]);ba=_7=_7.Right;}else{_6.unshift([false,_7.Node,_7.Right]);ba=_7=_7.Left;}}_9=ba;}}return[_7,_6];},OfSeq:function(ba){var bb;bb=d.sort(e.toArray(e.distinct(ba)));return b.Build(bb,0,bb.length-1);},Put:function(bc,bd,be){var bf,bg,bh;bf=b.Lookup(bd,be);bg=bf[0];bh=bf[1];return bg==null?b.Rebuild(bh,b.Branch(bd,null,null)):b.Rebuild(bh,b.Branch((bc(bg.Node))(bd),bg.Left,bg.Right));},Rebuild:function(bi,bj){var bk,bm,bn,bo,bp,bq,br,bs,bt,bu,bv,bw,bx,by,bz;bk=function(bl){return bl==null?0:bl.Height;};bm=bj;for(bn=0;bn<=d.length(bi)-1;bn++){bo=d.get(bi,bn);if(bo[0]){bq=bo[1];br=bo[2];if(bk(bm)>bk(br)+1){if(bk(bm.Left)===bk(bm.Right)+1){bu=bm.Left;bt=b.Branch(bu.Node,b.Branch(bq,br,bu.Left),b.Branch(bm.Node,bu.Right,bm.Right));}else{bt=b.Branch(bm.Node,b.Branch(bq,br,bm.Left),bm.Right);}bs=bt;}else{bs=b.Branch(bq,br,bm);}bp=bs;}else{bv=bo[1];bw=bo[2];if(bk(bm)>bk(bw)+1){if(bk(bm.Right)===bk(bm.Left)+1){bz=bm.Right;by=b.Branch(bz.Node,b.Branch(bm.Node,bm.Left,bz.Left),b.Branch(bv,bz.Right,bw));}else{by=b.Branch(bm.Node,bm.Left,b.Branch(bv,bm.Right,bw));}bx=by;}else{bx=b.Branch(bv,bm,bw);}bp=bx;}bm=bp;}return bm;},Remove:function(bA,bB){var bC,bD,bE,bF,bG,bH,bI,bJ,bK;bC=b.Lookup(bA,bB);bD=bC[0];bE=bC[1];if(bD==null){bF=bB;}else{if(bD.Right==null){bG=b.Rebuild(bE,bD.Left);}else{if(bD.Left==null){bH=b.Rebuild(bE,bD.Right);}else{bI=e.append(b.Enumerate(false,bD.Left),b.Enumerate(false,bD.Right));bJ=e.toArray(bI);bK=b.Build(bJ,0,bJ.length-1);bH=b.Rebuild(bE,bK);}bG=bH;}bF=bG;}return bF;},TryFind:function(bL,bM){var bN;bN=(b.Lookup(bL,bM))[0];return bN==null?{$:0}:{$:1,$0:bN.Node};}},Dictionary:$.Class({Add:function(bO,bP){var bQ,bR;bQ=this.hash.call(null,bO);if(this.data.hasOwnProperty(bQ)){bR=c.FailWith("An item with the same key has already been added.");}else{this.data[bQ]={K:bO,V:bP};bR=void(this.count=this.count+1);}return bR;},Clear:function(){this.data={};this.count=0;return;},ContainsKey:function(bS){return this.data.hasOwnProperty(this.hash.call(null,bS));},GetEnumerator:function(){var bT;bT=i.GetFieldValues(this.data);return j.Get(bT);},Remove:function(bU){var bV,bW;bV=this.hash.call(null,bU);if(this.data.hasOwnProperty(bV)){i.Delete(this.data,bV);this.count=this.count-1;bW=true;}else{bW=false;}return bW;},get_Item:function(bX){var bY,bZ,b0;bY=this.hash.call(null,bX);if(this.data.hasOwnProperty(bY)){b0=this.data[bY];bZ=b0.V;}else{bZ=k.notPresent();}return bZ;},set_Item:function(b1,b2){var b3;b3=this.hash.call(null,b1);!this.data.hasOwnProperty(b3)?void(this.count=this.count+1):null;this.data[b3]={K:b1,V:b2};return;}},{New:function(b4){return $.New(this,l.New4(b4,function(b5){return function(b6){return m.Equals(b5,b6);};},function(b7){return m.Hash(b7);}));},New1:function(b8,b9){return $.New(this,l.New4(b8,function(b_){return function(b$){return b9.Equals(b_,b$);};},function(ca){return b9.GetHashCode(ca);}));},New11:function(cb,cc){return $.New(this,l.New3(cc));},New12:function(){return $.New(this,l.New4([],function(cd){return function(ce){return m.Equals(cd,ce);};},function(cf){return m.Hash(cf);}));},New2:function(){return $.New(this,l.New12());},New3:function(ch){return $.New(this,l.New4([],function(ci){return function(cj){return ch.Equals(ci,cj);};},function(ck){return ch.GetHashCode(ck);}));},New4:function(cl,cm,cn){var co,cp,cq,cr;co=$.New(this,{});co.hash=cn;co.count=0;co.data={};cp=j.Get(cl);while(cp.MoveNext()){cq=cp.get_Current();cr=cq.K;co.data[co.hash.call(null,cr)]=cq.V;}return co;}}),DictionaryUtil:{notPresent:function(){return c.FailWith("The given key was not present in the dictionary.");}},FSharpMap:$.Class({Add:function(cs,ct){var cu,cv;cu=this.tree;cv=$.New(o,{Key:cs,Value:ct});return n.New(b.Add(cv,cu));},CompareTo:function(cw){return e.compareWith(function(cx){return function(cy){return c.Compare(cx,cy);};},this,cw);},ContainsKey:function(cz){var cA,cB;cA=this.tree;cB=$.New(o,{Key:cz,Value:undefined});return b.Contains(cB,cA);},Equals:function(cC){return this.get_Count()===cC.get_Count()?e.forall2(function(cD){return function(cE){return m.Equals(cD,cE);};},this,cC):false;},GetEnumerator:function(){var cF,cH,cI;cF=function(cG){return{K:cG.Key,V:cG.Value};};cH=b.Enumerate(false,this.tree);cI=e.map(cF,cH);return j.Get(cI);},GetHashCode:function(){return m.Hash(e.toArray(this));},Remove:function(cJ){var cK,cL;cK=this.tree;cL=$.New(o,{Key:cJ,Value:undefined});return n.New(b.Remove(cL,cK));},TryFind:function(cM){var cN,cO,cP,cR;cN=this.tree;cO=$.New(o,{Key:cM,Value:undefined});cP=function(cQ){return cQ.Value;};cR=b.TryFind(cO,cN);return p.map(cP,cR);},get_Count:function(){var cS;cS=this.tree;return cS==null?0:cS.Count;},get_IsEmpty:function(){return this.tree==null;},get_Item:function(cT){var cU,cV,cW;cU=this.TryFind(cT);if(cU.$==0){cV=c.FailWith("The given key was not present in the dictionary.");}else{cW=cU.$0;cV=cW;}return cV;},get_Tree:function(){return this.tree;}},{New:function(cX){var cY;cY=$.New(this,{});cY.tree=cX;return cY;},New1:function(cZ){return $.New(this,n.New(q.fromSeq(cZ)));}}),FSharpSet:$.Class({Add:function(c0){return r.New1(b.Add(c0,this.tree));},CompareTo:function(c1){return e.compareWith(function(c2){return function(c3){return c.Compare(c2,c3);};},this,c1);},Contains:function(c4){return b.Contains(c4,this.tree);},Equals:function(c5){return this.get_Count()===c5.get_Count()?e.forall2(function(c6){return function(c7){return m.Equals(c6,c7);};},this,c5):false;},GetEnumerator:function(){return j.Get(b.Enumerate(false,this.tree));},GetHashCode:function(){return-1741749453+m.Hash(e.toArray(this));},IsProperSubsetOf:function(c8){return this.IsSubsetOf(c8)?this.get_Count()<c8.get_Count():false;},IsProperSupersetOf:function(c9){return this.IsSupersetOf(c9)?this.get_Count()>c9.get_Count():false;},IsSubsetOf:function(c_){return e.forall(function(c$){return c_.Contains(c$);},this);},IsSupersetOf:function(da){var dc=this;return e.forall(function(db){return dc.Contains(db);},da);},Remove:function(dd){return r.New1(b.Remove(dd,this.tree));},add:function(de){return r.New1(b.OfSeq(e.append(this,de)));},get_Count:function(){var df;df=this.tree;return df==null?0:df.Count;},get_IsEmpty:function(){return this.tree==null;},get_MaximumElement:function(){return e.head(b.Enumerate(true,this.tree));},get_MinimumElement:function(){return e.head(b.Enumerate(false,this.tree));},get_Tree:function(){return this.tree;},sub:function(dg){return s.Filter(function(dh){return!dg.Contains(dh);},this);}},{New:function(di){return $.New(this,r.New1(t.ofSeq(di)));},New1:function(dj){var dk;dk=$.New(this,{});dk.tree=dj;return dk;}}),HashSetProxy:$.Class({Add:function(dl){return this.add(dl);},Clear:function(){this.data=u.prototype.constructor.apply(u,[]);this.count=0;return;},Contains:function(dm){var dn;dn=this.data[this.hash.call(null,dm)];return dn==null?false:this.arrContains(dm,dn);},CopyTo:function(_do){var dp,dq,dr;dp=0;dq=v.concat(this.data);for(dr=0;dr<=dq.length-1;dr++){d.set(_do,dr,dq[dr]);}return;},ExceptWith:function(ds){var dt,du,dv;dt=j.Get(ds);while(dt.MoveNext()){du=dt.get_Current();dv=this.Remove(du);}return;},GetEnumerator:function(){return j.Get(v.concat(this.data));},IntersectWith:function(dw){var dx,dy,dz,dA,dB,dC,dD;dx=w.New3(dw,this.equals,this.hash);dy=v.concat(this.data);for(dz=0;dz<=dy.length-1;dz++){dA=dy[dz];dB=dx.Contains(dA);if(!dB){dD=this.Remove(dA);dC=void dD;}else{dC=null;}}return;},IsProperSubsetOf:function(dE){var dF;dF=d.ofSeq(dE);return this.count<d.length(dF)?this.IsSubsetOf(dF):false;},IsProperSupersetOf:function(dG){var dH;dH=d.ofSeq(dG);return this.count>d.length(dH)?this.IsSupersetOf(dH):false;},IsSubsetOf:function(dI){var dJ,dK,dM;dJ=w.New3(dI,this.equals,this.hash);dK=function(dL){return dJ.Contains(dL);};dM=v.concat(this.data);return e.forall(dK,dM);},IsSupersetOf:function(dN){var dO,dQ=this;dO=function(dP){return dQ.Contains(dP);};return e.forall(dO,dN);},Overlaps:function(dR){var dS,dU=this;dS=function(dT){return dU.Contains(dT);};return e.exists(dS,dR);},Remove:function(dV){var dW,dX,dY,dZ;dW=this.hash.call(null,dV);dX=this.data[dW];if(dX==null){dY=false;}else{if(this.arrRemove(dV,dX)){this.count=this.count-1;dZ=true;}else{dZ=false;}dY=dZ;}return dY;},RemoveWhere:function(d0){var d1,d2,d3,d4,d5;d1=v.concat(this.data);for(d2=0;d2<=d1.length-1;d2++){d3=d1[d2];if(d0(d3)){d5=this.Remove(d3);d4=void d5;}else{d4=null;}}return;},SetEquals:function(d6){var d7;d7=w.New3(d6,this.equals,this.hash);return this.get_Count()===d7.get_Count()?this.IsSupersetOf(d7):false;},SymmetricExceptWith:function(d8){var d9,d_,d$,ea,eb;d9=j.Get(d8);while(d9.MoveNext()){d_=d9.get_Current();if(this.Contains(d_)){ea=this.Remove(d_);d$=void ea;}else{eb=this.Add(d_);d$=void eb;}}return;},UnionWith:function(ec){var ed,ee,ef;ed=j.Get(ec);while(ed.MoveNext()){ee=ed.get_Current();ef=this.Add(ee);}return;},add:function(eg){var eh,ei,ej,ek,el;eh=this.hash.call(null,eg);ei=this.data[eh];if(ei==null){this.data[eh]=[eg];this.count=this.count+1;ej=true;}else{if(this.arrContains(eg,ei)){ek=false;}else{el=ei.push(eg);this.count=this.count+1;ek=true;}ej=ek;}return ej;},arrContains:function(em,en){var eo,ep,eq;eo=true;ep=0;eq=en.length;while(eo?ep<eq:false){(this.equals.call(null,en[ep]))(em)?eo=false:ep=ep+1;}return!eo;},arrRemove:function(er,es){var et,eu,ev,ew,ex,ey,ez;et=true;eu=0;ev=es.length;while(et?eu<ev:false){if((this.equals.call(null,es[eu]))(er)){ex=eu;ey=[];ez=es.splice.apply(es,[ex,1].concat(ey));ew=et=false;}else{ew=eu=eu+1;}}return!et;},get_Count:function(){return this.count;}},{New:function(eA){return $.New(this,w.New3(eA,function(eB){return function(eC){return m.Equals(eB,eC);};},function(eD){return m.Hash(eD);}));},New1:function(eE){return $.New(this,w.New3(e.empty(),function(eF){return function(eG){return eE.Equals(eF,eG);};},function(eH){return eE.GetHashCode(eH);}));},New11:function(){return $.New(this,w.New3(e.empty(),function(eI){return function(eJ){return m.Equals(eI,eJ);};},function(eK){return m.Hash(eK);}));},New2:function(eL,eM){return $.New(this,w.New3(eL,function(eN){return function(eO){return eM.Equals(eN,eO);};},function(eP){return eM.GetHashCode(eP);}));},New3:function(eQ,eR,eS){var eT,eU,eV,eW;eT=$.New(this,{});eT.equals=eR;eT.hash=eS;eT.data=u.prototype.constructor.apply(u,[]);eT.count=0;eU=j.Get(eQ);while(eU.MoveNext()){eV=eU.get_Current();eW=eT.add(eV);}return eT;}}),HashSetUtil:{concat:function($o){var $0=this,$this=this;var r=[];for(var k in $o){r.push.apply(r,$o[k]);};return r;}},LinkedList:{E:$.Class({Dispose:function(){return null;},MoveNext:function(){this.c=this.c.n;return!m.Equals(this.c,null);},get_Current:function(){return this.c.v;}},{New:function(eX){var eY;eY=$.New(this,{});eY.c=eX;return eY;}}),T:$.Class({AddAfter:function(eZ,e0){var e1,e2,e3;e1=eZ.n;e2={p:eZ,n:e1,v:e0};m.Equals(eZ.n,null)?void(this.p=e2):null;eZ.n=e2;if(!m.Equals(e1,null)){e1.p=e2;e3=e2;}else{e3=null;}this.c=this.c+1;return e2;},AddBefore:function(e4,e5){var e6,e7,e8;e6=e4.p;e7={p:e6,n:e4,v:e5};m.Equals(e4.p,null)?void(this.n=e7):null;e4.p=e7;if(!m.Equals(e6,null)){e6.n=e7;e8=e7;}else{e8=null;}this.c=this.c+1;return e7;},AddFirst:function(e9){var e_,e$;if(this.c===0){e$={p:null,n:null,v:e9};this.n=e$;this.p=this.n;this.c=1;e_=e$;}else{e_=this.AddBefore(this.n,e9);}return e_;},AddLast:function(fa){var fb,fc;if(this.c===0){fc={p:null,n:null,v:fa};this.n=fc;this.p=this.n;this.c=1;fb=fc;}else{fb=this.AddAfter(this.p,fa);}return fb;},Clear:function(){this.c=0;this.n=null;this.p=null;return;},Contains:function(fd){var fe,ff;fe=false;ff=this.n;while(!m.Equals(ff,null)?!fe:false){ff.v==fd?fe=true:ff=ff.n;}return fe;},Find:function(fg){var fh,fi;fh=this.n;fi=true;while(fi?!m.Equals(fh,null):false){fh.v==fg?fi=false:fh=fh.n;}return fi?null:fh;},FindLast:function(fj){var fk,fl;fk=this.p;fl=true;while(fl?!m.Equals(fk,null):false){fk.v==fj?fl=false:fk=fk.p;}return fl?null:fk;},GetEnumerator:function(){return y.New(this);},Remove:function(fm){var fn,fo,fp,fq;fn=fm.p;fo=fm.n;if(m.Equals(fn,null)){fp=void(this.n=fo);}else{fn.n=fo;fp=fo;}if(m.Equals(fo,null)){fq=void(this.p=fn);}else{fo.p=fn;fq=fn;}this.c=this.c-1;return;},Remove1:function(fr){var fs,ft;fs=this.Find(fr);if(m.Equals(fs,null)){ft=false;}else{this.Remove(fs);ft=true;}return ft;},RemoveFirst:function(){return this.Remove(this.n);},RemoveLast:function(){return this.Remove(this.p);},get_Count:function(){return this.c;},get_First:function(){return this.n;},get_Last:function(){return this.p;}},{New:function(){return $.New(this,z.New1(e.empty()));},New1:function(fu){var fv,fw,fx,fy;fv=$.New(this,{});fv.c=0;fv.n=null;fv.p=null;fw=j.Get(fu);if(fw.MoveNext()){fv.n={p:null,n:null,v:fw.get_Current()};fv.p=fv.n;fx=void(fv.c=1);}else{fx=null;}while(fw.MoveNext()){fy={p:fv.p,n:null,v:fw.get_Current()};fv.p.n=fy;fv.p=fy;fv.c=fv.c+1;}return fv;}})},MapModule:{Exists:function(fz,fA){var fB;fB=function(fC){return(fz(fC.K))(fC.V);};return e.exists(fB,fA);},Filter:function(fD,fE){var fF,fH,fI,fJ,fK;fF=function(fG){return(fD(fG.Key))(fG.Value);};fH=b.Enumerate(false,fE.get_Tree());fI=e.filter(fF,fH);fJ=e.toArray(fI);fK=b.Build(fJ,0,fJ.length-1);return n.New(fK);},FindKey:function(fL,fM){var fN;fN=function(fO){return(fL(fO.K))(fO.V)?{$:1,$0:fO.K}:{$:0};};return e.pick(fN,fM);},Fold:function(fP,fQ,fR){var fS,fV;fS=function(fT){return function(fU){return((fP(fT))(fU.Key))(fU.Value);};};fV=b.Enumerate(false,fR.get_Tree());return e.fold(fS,fQ,fV);},FoldBack:function(fW,fX,fY){var fZ,f2;fZ=function(f0){return function(f1){return((fW(f1.Key))(f1.Value))(f0);};};f2=b.Enumerate(true,fX.get_Tree());return e.fold(fZ,fY,f2);},ForAll:function(f3,f4){var f5;f5=function(f6){return(f3(f6.K))(f6.V);};return e.forall(f5,f4);},Iterate:function(f7,f8){var f9;f9=function(f_){return(f7(f_.K))(f_.V);};return e.iter(f9,f8);},Map:function(f$,ga){var gb,gd,ge,gf;gb=function(gc){return $.New(o,{Key:gc.Key,Value:(f$(gc.Key))(gc.Value)});};gd=b.Enumerate(false,ga.get_Tree());ge=e.map(gb,gd);gf=b.OfSeq(ge);return n.New(gf);},OfArray:function(gg){var gh,gl,gm;gh=function(gi){var gj,gk;gj=gi[0];gk=gi[1];return $.New(o,{Key:gj,Value:gk});};gl=e.map(gh,gg);gm=b.OfSeq(gl);return n.New(gm);},Partition:function(gn,go){var gp,gr,gs,gt,gu;gp=function(gq){return(gn(gq.Key))(gq.Value);};gr=e.toArray(b.Enumerate(false,go.get_Tree()));gs=d.partition(gp,gr);gt=gs[1];gu=gs[0];return[n.New(b.Build(gu,0,gu.length-1)),n.New(b.Build(gt,0,gt.length-1))];},Pick:function(gv,gw){var gx;gx=function(gy){return(gv(gy.K))(gy.V);};return e.pick(gx,gw);},ToSeq:function(gz){var gA,gC;gA=function(gB){return[gB.Key,gB.Value];};gC=b.Enumerate(false,gz.get_Tree());return e.map(gA,gC);},TryFind:function(gD,gE){return gE.TryFind(gD);},TryFindKey:function(gF,gG){var gH;gH=function(gI){return(gF(gI.K))(gI.V)?{$:1,$0:gI.K}:{$:0};};return e.tryPick(gH,gG);},TryPick:function(gJ,gK){var gL;gL=function(gM){return(gJ(gM.K))(gM.V);};return e.tryPick(gL,gK);}},MapUtil:{fromSeq:function(gN){var gO;gO=e.toArray(e.delay(function(){return e.collect(function(gQ){var gR,gS;gR=gQ[1];gS=gQ[0];return[$.New(o,{Key:gS,Value:gR})];},e.distinctBy(function(gT){return gT[0];},gN));}));d.sortInPlace(gO);return b.Build(gO,0,gO.length-1);}},Pair:$.Class({CompareTo:function(gU){return c.Compare(this.Key,gU.Key);},Equals:function(gV){return m.Equals(this.Key,gV.Key);},GetHashCode:function(){return m.Hash(this.Key);}}),ResizeArray:{ResizeArrayProxy:$.Class({Add:function(gW){return this.arr.push(gW);},AddRange:function(gX){var gZ=this;return e.iter(function(gY){return gZ.Add(gY);},gX);},Clear:function(){var g0;g0=A.splice(this.arr,0,d.length(this.arr),[]);return;},CopyTo:function(g1){return this.CopyTo1(g1,0);},CopyTo1:function(g2,g3){return this.CopyTo2(0,g2,g3,this.get_Count());},CopyTo2:function(g4,g5,g6,g7){return d.blit(this.arr,g4,g5,g6,g7);},GetEnumerator:function(){return j.Get(this.arr);},GetRange:function(g8,g9){return B.New11(d.sub(this.arr,g8,g9));},Insert:function(g_,g$){var ha;ha=A.splice(this.arr,g_,0,[g$]);return;},InsertRange:function(hb,hc){var hd;hd=A.splice(this.arr,hb,0,e.toArray(hc));return;},RemoveAt:function(he){var hf;hf=A.splice(this.arr,he,1,[]);return;},RemoveRange:function(hg,hh){var hi;hi=A.splice(this.arr,hg,hh,[]);return;},Reverse:function(){return this.arr.reverse();},Reverse1:function(hj,hk){return d.reverse(this.arr,hj,hk);},ToArray:function(){return this.arr.slice();},get_Count:function(){return d.length(this.arr);},get_Item:function(hl){return d.get(this.arr,hl);},set_Item:function(hm,hn){return d.set(this.arr,hm,hn);}},{New:function(ho){return $.New(this,B.New11(e.toArray(ho)));},New1:function(){return $.New(this,B.New11([]));},New11:function(hq){var hr;hr=$.New(this,{});hr.arr=hq;return hr;},New2:function(){return $.New(this,B.New11([]));}}),splice:function($arr,$index,$howMany,$items){var $0=this,$this=this;return $$.Array.prototype.splice.apply($arr,[$index,$howMany].concat($items));}},SetModule:{Filter:function(hs,ht){var hu;hu=e.toArray(e.filter(hs,ht));return r.New1(b.Build(hu,0,hu.length-1));},FoldBack:function(hv,hw,hx){return e.fold(function(hy){return function(hz){return(hv(hz))(hy);};},hx,b.Enumerate(true,hw.get_Tree()));},Partition:function(hA,hB){var hC,hD,hE;hC=d.partition(hA,e.toArray(hB));hD=hC[1];hE=hC[0];return[r.New1(b.OfSeq(hE)),r.New1(b.OfSeq(hD))];}},SetUtil:{ofSeq:function(hF){var hG;hG=e.toArray(hF);d.sortInPlace(hG);return b.Build(hG,0,hG.length-1);}}}}});$.OnInit(function(){a=$.Safe($$.WebSharper.Collections);b=$.Safe(a.BalancedTree);c=$.Safe($$.WebSharper.Operators);d=$.Safe($$.WebSharper.Arrays);e=$.Safe($$.WebSharper.Seq);f=$.Safe($$.WebSharper.List);g=$.Safe(f.T);h=$.Safe($$.WebSharper.JavaScript);i=$.Safe(h.JSModule);j=$.Safe($$.WebSharper.Enumerator);k=$.Safe(a.DictionaryUtil);l=$.Safe(a.Dictionary);m=$.Safe($$.WebSharper.Unchecked);n=$.Safe(a.FSharpMap);o=$.Safe(a.Pair);p=$.Safe($$.WebSharper.Option);q=$.Safe(a.MapUtil);r=$.Safe(a.FSharpSet);s=$.Safe(a.SetModule);t=$.Safe(a.SetUtil);u=$.Safe($$.Array);v=$.Safe(a.HashSetUtil);w=$.Safe(a.HashSetProxy);x=$.Safe(a.LinkedList);y=$.Safe(x.E);z=$.Safe(x.T);A=$.Safe(a.ResizeArray);return B=$.Safe(A.ResizeArrayProxy);});$.OnLoad(function(){return;});}());

(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q;$.Define($$,{IntelliFactory:{Reactive:{Disposable:$.Class({Dispose:function(){return this.Dispose1.call(null,null);}},{New:function(r){return $.New(c,{Dispose1:r});}}),HotStream:$.Class({Subscribe:function(s){if(this.Latest[0].$==1){s.OnNext(this.Latest[0].$0);}return this.Event.event.Subscribe(s);},Trigger:function(t){this.Latest[0]={$:1,$0:t};return this.Event.event.Trigger(t);}},{New:function(u){return $.New(d,{Latest:[{$:1,$0:u}],Event:f.New()});},New1:function(){return $.New(d,{Latest:[{$:0}],Event:f.New()});}}),Observable:$.Class({Subscribe:function(v){return this.OnSubscribe.call(null,v);},SubscribeWith:function(w,x){return this.OnSubscribe.call(null,g.New(w,x));}},{New:function(y){return $.New(h,{OnSubscribe:y});}}),Observer:$.Class({OnCompleted:function(){return this.OnCompleted1.call(null,null);},OnError:function(){return null;},OnNext:function(A){return this.OnNext1.call(null,A);}},{New:function(B,C){return $.New(g,{OnNext1:B,OnCompleted1:C});}}),Reactive:{Aggregate:function(D,E,F){return h.New(function(G){var H;H=[E];return i.subscribeTo(D,function(I){H[0]=(F(H[0]))(I);return G.OnNext(H[0]);});});},Choose:function(J,K){return h.New(function(L){return i.subscribeTo(J,function(M){var N;N=K(M);return N.$==0?null:L.OnNext(N.$0);});});},CollectLatest:function(O){return h.New(function(P){var Q,R;Q=k.New12();R=[0];return i.subscribeTo(O,function(S){var T;l.incr(R);T=R[0];i.subscribeTo(S,function(U){Q.set_Item(T,U);return P.OnNext(m.delay(function(){return m.map(function(W){return W.V;},Q);}));});return;});});},CombineLatest:function(X,Y,Z){return h.New(function(_0){var _1,_2,_3,_7,_,bb,bc;_1=[{$:0}];_2=[{$:0}];_3=function(){var _5,_6;_5=[_1[0],_2[0]];if(_5[0].$==1){if(_5[1].$==1){_6=_5[1].$0;return _0.OnNext((Z(_5[0].$0))(_6));}else{return null;}}else{return null;}};_7=g.New(function(_8){_1[0]={$:1,$0:_8};return _3(null);},function(){});_=g.New(function(ba){_2[0]={$:1,$0:ba};return _3(null);},function(){});bb=X.Subscribe(_7);bc=Y.Subscribe(_);return c.New(function(){bb.Dispose();return bc.Dispose();});});},Concat:function(be,bf){return h.New(function(bg){var bh,bi;bh=[{$:0}];bi=be.Subscribe(g.New(function(bj){return bg.OnNext(bj);},function(){bh[0]={$:1,$0:bf.Subscribe(bg)};}));return c.New(function(){if(bh[0].$==1){bh[0].$0.Dispose();}return bi.Dispose();});});},Default:$.Field(function(){return o.New();}),Drop:function(bm,bn){return h.New(function(bo){var bp;bp=[0];return i.subscribeTo(bm,function(bq){l.incr(bp);return bp[0]>bn?bo.OnNext(bq):null;});});},Heat:function(br){var bs;bs=d.New1();i.subscribeTo(br,function(bt){return bs.Trigger(bt);});return bs;},Merge:function(bu,bv){return h.New(function(bw){var bx,by,bz,bC;bx=[false];by=[false];bz=bu.Subscribe(g.New(function(bA){return bw.OnNext(bA);},function(){bx[0]=true;return(bx[0]?by[0]:false)?bw.OnCompleted():null;}));bC=bv.Subscribe(g.New(function(bD){return bw.OnNext(bD);},function(){by[0]=true;return(bx[0]?by[0]:false)?bw.OnCompleted():null;}));return c.New(function(){bz.Dispose();return bC.Dispose();});});},Never:function(){return h.New(function(){return c.New(function(){});});},Range:function(bI,bJ){return h.New(function(bK){var bL;for(bL=bI;bL<=bI+bJ;bL++){bK.OnNext(bL);}return c.New(function(){});});},Reactive:$.Class({Aggregate:function(bN,bO,bP){return n.Aggregate(bN,bO,bP);},Choose:function(bQ,bR){return n.Choose(bQ,bR);},CollectLatest:function(bS){return n.CollectLatest(bS);},CombineLatest:function(bT,bU,bV){return n.CombineLatest(bT,bU,bV);},Concat:function(bW,bX){return n.Concat(bW,bX);},Drop:function(bY,bZ){return n.Drop(bY,bZ);},Heat:function(b0){return n.Heat(b0);},Merge:function(b1,b2){return n.Merge(b1,b2);},Never:function(){return n.Never();},Return:function(b3){return n.Return(b3);},Select:function(b4,b5){return n.Select(b4,b5);},SelectMany:function(b6){return n.SelectMany(b6);},Sequence:function(b7){return n.Sequence(b7);},Switch:function(b8){return n.Switch(b8);},Where:function(b9,b_){return n.Where(b9,b_);}},{New:function(){return $.New(this,{});}}),Return:function(b$){return h.New(function(ca){ca.OnNext(b$);ca.OnCompleted();return c.New(function(){});});},Select:function(cc,cd){return h.New(function(ce){return i.subscribeTo(cc,function(cf){return ce.OnNext(cd(cf));});});},SelectMany:function(cg){return h.New(function(ch){var ci,ck;ci=[function(){}];ck=i.subscribeTo(cg,function(cl){var cm;cm=i.subscribeTo(cl,function(cn){return ch.OnNext(cn);});ci[0]=function(){ci[0].call(null,null);return cm.Dispose();};return;});return c.New(function(){ci[0].call(null,null);return ck.Dispose();});});},Sequence:function(cq){var cr;cr=function(cs){return cs.$==1?n.CombineLatest(cs.$0,cr(cs.$1),function(ct){return function(cu){return $.New(q,{$:1,$0:ct,$1:cu});};}):n.Return($.New(q,{$:0}));};return n.Select(cr(p.ofSeq(cq)),function(cv){return cv;});},Switch:function(cw){return h.New(function(cx){var cy,cz;cy=[0];cz=[{$:0}];return i.subscribeTo(cw,function(cA){var cB;l.incr(cy);if(cz[0].$==1){cz[0].$0.Dispose();}cB=cy[0];cz[0]={$:1,$0:i.subscribeTo(cA,function(cC){return cB===cy[0]?cx.OnNext(cC):null;})};return;});});},Where:function(cD,cE){return h.New(function(cF){return i.subscribeTo(cD,function(cG){return cE(cG)?cF.OnNext(cG):null;});});}}}}});$.OnInit(function(){a=$.Safe($$.IntelliFactory);b=$.Safe(a.Reactive);c=$.Safe(b.Disposable);d=$.Safe(b.HotStream);e=$.Safe($$.WebSharper.Control);f=$.Safe(e.FSharpEvent);g=$.Safe(b.Observer);h=$.Safe(b.Observable);i=$.Safe($$.WebSharper.Util);j=$.Safe($$.WebSharper.Collections);k=$.Safe(j.Dictionary);l=$.Safe($$.WebSharper.Ref);m=$.Safe($$.WebSharper.Seq);n=$.Safe(b.Reactive);o=$.Safe(n.Reactive);p=$.Safe($$.WebSharper.List);return q=$.Safe(p.T);});$.OnLoad(function(){n.Default();return;});}());

(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W;$.Define($$,{WebSharper:{Piglets:{Choose:{Stream:$.Class({Choice:function(X,Y){var Z,_0,_5=this;Z=f.New12();_0=[false];this.subscriptions[0]=$.New(h,{$:1,$0:this.pStream.Subscribe(function(_1){var _2,_3,_4;if(_1.$==0){_2=_1.$0[1];_3=_1.$0[0];_4=Z.ContainsKey(_3)?Z.get_Item(_3):_2.view.call(null,Y);_5.out.Trigger(_2.stream.get_Latest());if(_0[0]){X.Remove(0);}_0[0]=true;return X.Add(_4);}else{return null;}}),$1:_5.subscriptions[0]});return X.get_Container();},Chooser:function(_6){return this.chooser.view.call(null,_6);},Dispose:function(){var _7;_7=i.Get(this.subscriptions[0]);while(_7.MoveNext()){_7.get_Current().Dispose();}return j.iter(function(_8){return(k.KeyValue(_8))[1][1].Dispose();},this.choiceSubscriptions);},Subscribe:function(_9){return this.out.Subscribe(_9);},get_ChooserStream:function(){return this.chooser.stream;},get_Latest:function(){return this.out.get_Latest();}},{New:function(_,ba,bb){var bc;bc=$.New(this,d.New(bb.get_Id()));bc.chooser=_;bc.out=bb;bc.pStream=l.New($.New(m,{$:1,$0:$.New(h,{$:0})}),{$:0});bc.choiceSubscriptions=f.New12();bc.subscriptions=[g.ofArray([bc.chooser.stream.Subscribe(function(bd){return bc.pStream.Trigger(m.Map(function(be){var bf,bg,bh;if(bc.choiceSubscriptions.ContainsKey(be)){bf=(bc.choiceSubscriptions.get_Item(be))[0];}else{bg=ba(be);bh=bc.out;bc.choiceSubscriptions.set_Item(be,[bg,bg.stream.Subscribe(function(bi){return bh.Trigger(bi);})]);bf=bg;}return[be,bf];},bd));})])];return bc;}})},ConcreteReader:$.Class({Subscribe:function(bi){return this.subscribe.call(null,bi);},get_Latest:function(){return this.latest.call(null,null);}},{New:function(bj,bk){var bl;bl=$.New(this,d.New((o.next())(null)));bl.latest=bj;bl.subscribe=bk;return bl;}}),ConcreteWriter:$.Class({Trigger:function(bm){return this.trigger.call(null,bm);}},{New:function(bn){var bo;bo=$.New(this,{});bo.trigger=bn;return bo;},New1:function(bp){return p.New(function(bq){return bq.$==1?null:bp(bq.$0);});}}),ConstReader:$.Class({Subscribe:function(){return r.New(function(){});},get_Latest:function(){return this.x;}},{New:function(bt){var bu;bu=$.New(this,d.New((o.next())(null)));bu.x=bt;return bu;}}),Controls:{Attr:function(bv,bw,bx,by){u.OnAfterRender(function(bz){var bA;bA=function(bB){var bC;if(bB.$==0){bC=bx(bB.$0);return bz["HtmlProvider@33"].SetAttribute(bz.get_Body(),bw,bC);}else{return null;}};bA(bv.get_Latest());bv.Subscribe(bA);return;},by);return by;},AttrResult:function(bD,bE,bF,bG){u.OnAfterRender(function(bH){var bI;bI=function(bJ){var bK;bK=bF(bJ);return bH["HtmlProvider@33"].SetAttribute(bH.get_Body(),bE,bK);};bI(bD.get_Latest());bD.Subscribe(bI);return;},bG);return bG;},Button:function(bL){var bM,bN,bO;bM=$.New(h,{$:0});bN=v.Tags().NewTag("button",bM);bO=function(){return function(){return bL.Trigger($.New(m,{$:0,$0:null}));};};w.Events().OnClick(bO,bN);return bN;},ButtonValidate:function(bR){var bS;bS=x.Button(bR);return x.EnableOnSuccess(bR.get_Input(),bS);},CheckBox:function(bT){var bU,bV,bW,bX,bY,bZ,b2;bU=(x.nextId())(null);bV=v.Tags();bW=g.ofArray([y.Attr().NewAttr("type","checkbox"),y.Attr().NewAttr("id",bU)]);bX=bV.NewTag("input",bW);bY=bT.get_Latest();if(bY.$==0){bZ=bY.$0;bX.get_Body().checked=bZ;}bT.Subscribe(function(b0){var b1;if(b0.$==1){return null;}else{b1=b0.$0;return!z.Equals(bX.get_Body().checked,b1)?void(bX.get_Body().checked=b1):null;}});b2=function(){return bT.Trigger($.New(m,{$:0,$0:bX.get_Body().checked}));};bX.get_Body().addEventListener("change",b2,true);return bX;},Css:function(b4,b5,b6,b7){u.OnAfterRender(function(b8){var b9;b9=function(b_){var b$;if(b_.$==0){b$=b6(b_.$0);return b8["HtmlProvider@33"].SetCss(b8.get_Body(),b5,b$);}else{return null;}};b9(b4.get_Latest());b4.Subscribe(b9);return;},b7);return b7;},CssResult:function(ca,cb,cc,cd){u.OnAfterRender(function(ce){var cf;cf=function(cg){var ch;ch=cc(cg);return ce["HtmlProvider@33"].SetCss(ce.get_Body(),cb,ch);};cf(ca.get_Latest());ca.Subscribe(cf);return;},cd);return cd;},EnableOnSuccess:function(ci,cj){u.OnAfterRender(function(ck){ck.get_Body().disabled=!ci.get_Latest().get_isSuccess();ci.Subscribe(function(cl){ck.get_Body().disabled=!cl.get_isSuccess();});return;},cj);return cj;},HtmlContainer:$.Class({Add:function(cm){return this.container.AppendI(cm);},MoveUp:function(cn){var co,cp;co=this.container.get_Body().childNodes[cn];cp=this.container.get_Body().childNodes[cn-1];this.container.get_Body().removeChild(co);this.container.get_Body().insertBefore(co,cp);return;},Remove:function(cq){this.container.get_Body().removeChild(this.container.get_Body().childNodes[cq]);},get_Container:function(){return this.container;}},{New:function(cr){var cs;cs=$.New(this,{});cs.container=cr;return cs;}}),IntInput:function(ct){return x.input("number",function(cu){return cu<<0;},function(cv){return $$.String(cv);},ct);},Link:function(cw){var cx,cy;cx=g.ofArray([y.Attr().NewAttr("href","#")]);cy=v.Tags().NewTag("a",cx);u.OnAfterRender(function(cz){return A(cz.get_Body()).on("click",function(cA){cw.Trigger($.New(m,{$:0,$0:null}));return cA.preventDefault();});},cy);return cy;},Radio:function(cB,cC){var cD,cE,cF,cK;cD=(x.nextId())(null);cE=g.ofSeq(cC);cF=g.map(function(cG){var cH,cI;cH=v.Tags().NewTag("input",g.ofArray([y.Attr().NewAttr("type","radio"),y.Attr().NewAttr("name",cD)]));cI=function(cJ){return cJ.get_Body().checked?cB.Trigger($.New(m,{$:0,$0:cG})):null;};w.Events().OnChange(cI,cH);return cH;},cE);cK=function(cL){var cM;if(cL.$==1){return null;}else{cM=cL.$0;return g.iter2(function(cN){return function(cO){cO.get_Body().checked=z.Equals(cN,cM);};},cE,cF);}};cK(cB.get_Latest());cB.Subscribe(cK);return cF;},RadioLabelled:function(cP,cQ){var cR,cT;cR=x.Radio(cP,j.map(function(cS){return cS[0];},cQ));cT=j.mapi2(function(cU){var cV;cV=cU[1];return function(cW){var cX,cY,cZ;cX=(x.nextId())(null);cZ=g.ofArray([y.Attr().NewAttr("for",cX),v.Tags().text(cV)]);cY=g.ofArray([u.add(cW,g.ofArray([y.Attr().NewAttr("id",cX)])),v.Tags().NewTag("label",cZ)]);return v.Tags().NewTag("span",cY);};},cQ,cR);return v.Tags().NewTag("div",cT);},RenderChoice:function(c0,c1,c2){return c0.Choice(B.New(c2),c1);},RenderMany:function(c3,c4,c5){return c3.Render(B.New(c5),c4);},Select:function(c6,c7){var c8,c9,c_,dc,dd,df;c8=(x.nextId())(null);c9=C.ofSeq(c7);c_=C.map(function(c$){var da,db;da=c$[1];db=(x.nextId())(null);return u.add(v.Tags().NewTag("option",g.ofArray([y.Attr().NewAttr("value",db)])),g.ofArray([v.Tags().text(da)]));},c9);dc=v.Tags().NewTag("select",c_);dd=function(de){return de.get_Body().selectedIndex>=0?c6.Trigger($.New(m,{$:0,$0:(C.get(c9,de.get_Body().selectedIndex))[0]})):null;};w.Events().OnChange(dd,dc);df=dc;u.OnAfterRender(function(){c6.Subscribe(function(dh){var di,dj,dl;if(dh.$==1){return null;}else{di=dh.$0;dj=C.tryFindIndex(function(dk){return z.Equals(di,dk[0]);},c9);if(dj.$==0){return null;}else{dl=C.get(c_,dj.$0);return dl["HtmlProvider@33"].SetAttribute(dl.get_Body(),"selected","");}}});},df);return df;},Show:function(dm,dn,_do){return x.ShowResult(dm,function(dp){return dp.$==1?j.empty():dn(dp.$0);},_do);},ShowErrors:function(dq,dr,ds){return x.ShowResult(dq,function(dt){return dt.$==1?dr(g.map(function(du){return du.get_Message();},dt.$0)):j.empty();},ds);},ShowResult:function(dv,dw,dx){var dy;dy=i.Get(dw(dv.get_Latest()));while(dy.MoveNext()){dx.AppendI(dy.get_Current());}dv.Subscribe(function(dz){var dA;dx["HtmlProvider@33"].Clear(dx.get_Body());dA=i.Get(dw(dz));while(dA.MoveNext()){dx.AppendI(dA.get_Current());}return;});return dx;},ShowString:function(dB,dC,dD){return x.Show(dB,function(dE){var dF;dF=dC(dE);return g.ofArray([v.Tags().text(dF)]);},dD);},Submit:function(dG){var dH,dI;dH=v.Tags().NewTag("input",g.ofArray([y.Attr().NewAttr("type","submit")]));dI=function(){return function(){return dG.Trigger($.New(m,{$:0,$0:null}));};};w.Events().OnClick(dI,dH);return dH;},SubmitValidate:function(dL){var dM;dM=x.Submit(dL);return x.EnableOnSuccess(dL.get_Input(),dM);},TextArea:function(dN){var dO,dP,dQ,dR,dU;dO=v.Tags();dP=$.New(h,{$:0});dQ=dO.NewTag("textarea",dP);dR=dN.get_Latest();if(dR.$==0){dQ.set_Value(dR.$0);}dN.Subscribe(function(dS){var dT;if(dS.$==1){return null;}else{dT=dS.$0;return dQ.get_Value()!==dT?dQ.set_Value(dT):null;}});dU=function(){return dN.Trigger($.New(m,{$:0,$0:dQ.get_Value()}));};dQ.get_Body().addEventListener("keyup",dU,true);dQ.get_Body().addEventListener("change",dU,true);return dQ;},WithLabel:function(dW,dX){var dY,dZ,d0;dY=(x.nextId())(null);d0=g.ofArray([y.Attr().NewAttr("for",dY),v.Tags().text(dW)]);dZ=g.ofArray([v.Tags().NewTag("label",d0),u.add(dX,g.ofArray([y.Attr().NewAttr("id",dY)]))]);return v.Tags().NewTag("span",dZ);},WithLabelAfter:function(d1,d2){var d3,d4,d5;d3=(x.nextId())(null);d5=g.ofArray([y.Attr().NewAttr("for",d3),v.Tags().text(d1)]);d4=g.ofArray([u.add(d2,g.ofArray([y.Attr().NewAttr("id",d3)])),v.Tags().NewTag("label",d5)]);return v.Tags().NewTag("span",d4);},input:function(d6,d7,d8,d9){var d_,d$,ea,eb,ee;d_=v.Tags();d$=g.ofArray([y.Attr().NewAttr("type",d6)]);ea=d_.NewTag("input",d$);eb=d9.get_Latest();if(eb.$==0){ea.set_Value(d8(eb.$0));}d9.Subscribe(function(ec){var ed;if(ec.$==1){return null;}else{ed=d8(ec.$0);return ea.get_Value()!==ed?ea.set_Value(ed):null;}});ee=function(){var eg;eg=$.New(m,{$:0,$0:d7(ea.get_Value())});return!z.Equals(eg,d9.get_Latest())?d9.Trigger(eg):null;};ea.get_Body().addEventListener("keyup",ee,true);ea.get_Body().addEventListener("change",ee,true);return ea;},nextId:$.Field(function(){var eh;eh=[0];return function(){D.incr(eh);return"pl__"+$$.String(eh[0]);};})},Disposable:$.Class({Dispose:function(){return this.dispose.call(null,null);}},{New:function(ej){var ek;ek=$.New(this,{});ek.dispose=ej;return ek;}}),ErrorMessage:$.Class({get_Message:function(){return this.message;},get_Source:function(){return this.source;}},{Create:function(el,em){return E.New(el,em.get_Id());},New:function(en,eo){var ep;ep=$.New(this,{});ep.message=en;ep.source=eo;return ep;}}),Id:{next:$.Field(function(){var eq;eq=[0];return function(){D.incr(eq);return eq[0];};})},Many:{Operations:$.Class({get_Delete:function(){return p.New1(this["delete"]);},get_MoveDown:function(){return this.moveDown;},get_MoveUp:function(){return this.moveUp;}},{New:function(es,et,eu){var ev;ev=$.New(this,{});ev["delete"]=es;ev.moveUp=et;ev.moveDown=eu;return ev;}}),Stream:$.Class({AddRender:function(ew){return this.adder.view.call(null,ew);},Render:function(ex,ey){var ez,eC=this,e2;ez=function(eA){var eB,eE,eH,eK,eM,eO,eQ,eS,eT,eU,eW,eX,eY,eZ;eB=eC.p.call(null,eA);eC.streams.Add(eB.stream);eB.stream.Subscribe(function(){return eC.update();});eE=function(){return j.findIndex(function(eG){return eG.get_Id()===eB.stream.get_Id();},eC.streams);};eH=function(eI){var eJ;if(eI>0?eI<eC.streams.get_Count():false){eJ=eC.streams.get_Item(eI);eC.streams.set_Item(eI,eC.streams.get_Item(eI-1));eC.streams.set_Item(eI-1,eJ);ex.MoveUp(eI);return eC.update();}else{return null;}};eK=function(){return eH(eE(null)+1);};eM=function(){return eH(eE(null));};eO=function(){return eE(null)>0?$.New(m,{$:0,$0:null}):$.New(m,{$:1,$0:$.New(h,{$:0})});};eQ=function(){return eE(null)<eC.streams.get_Count()-1?$.New(m,{$:0,$0:null}):$.New(m,{$:1,$0:$.New(h,{$:0})});};eS=l.New(eO(null),{$:0});eT=l.New(eQ(null),{$:0});eU=eC.out.Subscribe(function(){eS.Trigger(eO(null));return eT.Trigger(eQ(null));});eW=H.New(eS,false);eX=H.New(eT,false);eY=eW.Subscribe(m.Iter(eM));eZ=eX.Subscribe(m.Iter(eK));return ex.Add(eB.view.call(null,ey(I.New(function(){var e1;e1=eE(null);eC.streams.RemoveAt(e1);ex.Remove(e1);eU.Dispose();eY.Dispose();eZ.Dispose();return eC.update();},eW,eX))));};e2=eC.out.get_Latest();if(e2.$==0){C.iter(ez,e2.$0);}eC.adder.stream.Subscribe(function(e3){return e3.$==0?ez(e3.$0):null;});return ex.get_Container();},Subscribe:function(e4){return this.out.Subscribe(e4);},get_Add:function(){return this.adder.stream;},get_Latest:function(){return this.out.get_Latest();},update:function(){var e5;e5=this.out;return e5.Trigger(m.Map(function(e6){return C.ofSeq(g.rev(e6));},j.fold(function(e7){return function(e8){var e9;e9=[e7,e8.get_Latest()];return e9[0].$==1?e9[1].$==1?$.New(m,{$:1,$0:g.append(e9[1].$0,e9[0].$0)}):$.New(m,{$:1,$0:e9[0].$0}):e9[1].$==1?$.New(m,{$:1,$0:e9[1].$0}):$.New(m,{$:0,$0:$.New(h,{$:1,$0:e9[1].$0,$1:e9[0].$0})});};},$.New(m,{$:0,$0:$.New(h,{$:0})}),this.streams)));}},{New:function(e_,e$,fa){var fb;fb=$.New(this,d.New(e$.get_Id()));fb.p=e_;fb.out=e$;fb.adder=fa;fb.streams=K.New2();return fb;}}),UnitStream:$.Class({get_Add:function(){return this.submitStream;}},{New:function(fc,fd,fe,ff){var fg,fh,fi,fj;fg=$.New(this,G.New(fc,fd,fe));fh=l.New($.New(m,{$:1,$0:$.New(h,{$:0})}),{$:0});fi=fe.get_Stream();fj=function(fk){return fi.Trigger(fk);};fh.Subscribe(function(fl){return fl.$==0?fj($.New(m,{$:0,$0:ff})):fj($.New(m,{$:1,$0:fl.$0}));});fg.submitStream=fh;return fg;}})},Pervasives:{"Writer`1.Wrap.Static":function(fm,fn){return p.New(function(fo){return fn.Trigger(m.Map(fm,fo));});},"Writer`1.WrapAsync.Static":function(fp,fq){return M["Writer`1.WrapToAsyncResult.Static"](function(fr){return N.Delay(function(){return N.Bind(fp(fr),function(ft){return N.Return($.New(m,{$:0,$0:ft}));});});},fq);},"Writer`1.WrapAsyncResult.Static":function(fu,fv){return p.New(function(fw){return N.Start(N.Delay(function(){return N.Bind(fu(fw),function(fy){fv.Trigger(fy);return N.Return(null);});}),{$:0});});},"Writer`1.WrapResult.Static":function(fz,fA){return p.New(function(fB){return fA.Trigger(fz(fB));});},"Writer`1.WrapToAsyncResult.Static":function(fC,fD){return M["Writer`1.WrapAsyncResult.Static"](function(fE){return N.Delay(function(){return fE.$==1?N.Return($.New(m,{$:1,$0:fE.$0})):fC(fE.$0);});},fD);},"Writer`1.WrapToResult.Static":function(fG,fH){return p.New(function(fI){return fH.Trigger((m.Bind(fG))(fI));});},op_LessMultiplyGreater:function(fJ,fK){var fL,fM;fL=fJ.view;fM=fK.view;return $.New(O,{stream:P.Ap(fJ.stream,fK.stream),view:function(fN){return fM(fL(fN));}});},op_LessMultiplyQmarkGreater:function(fO,fP){var fQ,fR;fQ=fO.view;fR=fP.view;return $.New(O,{stream:P.ApJoin(fO.stream,fP.stream),view:function(fS){return fR(fQ(fS));}});}},Piglet:{Builder:$.Class({Bind:function(fT,fU){return Q.Choose(fT,fU);},Return:function(fV){return Q.Return(fV);},ReturnFrom:function(fW){return fW;},Yield:function(fX){return Q.Yield(fX);},YieldFrom:function(fY){return fY;},Zero:function(){return Q.ReturnFailure();}}),Choose:function(fZ,f0){var f1,f2;f1=l.New($.New(m,{$:1,$0:$.New(h,{$:0})}),{$:0});f2=c.New(fZ,f0,f1);return $.New(O,{stream:f1,view:function(f3){return f3(f2);}});},Confirm:function(f4,f5,f6){var f7,f8;f7=Q.Yield(f4);f8=M.op_LessMultiplyGreater(M.op_LessMultiplyGreater(Q.Return(function(f9){return function(f_){return[f9,f_];};}),f5(Q.Yield(f4))),f7);return Q.MapViewArgs(function(f$){return function(ga){return[f$,ga];};},Q.Map(function(gb){return gb[0];},R["Is'"](function(gc){return z.Equals(gc[0],gc[1]);},E.Create(f6,f7.get_Stream()),f8)));},FlushErrors:function(gd){return Q.MapResult(function(ge){return ge.$==1?$.New(m,{$:1,$0:$.New(h,{$:0})}):ge;},gd);},Many:function(gf,gg){return Q.ManyInit([gf],gf,gg);},ManyInit:function(gh,gi,gj){var gk,gl;gk=l.New($.New(m,{$:0,$0:gh}),{$:0});gl=L.New(gj,gk,gj(gi),gi);return $.New(O,{stream:gk,view:function(gm){return gm(gl);}});},ManyPiglet:function(gn,go,gp){var gq,gr;gq=l.New($.New(m,{$:0,$0:gn}),{$:0});gr=G.New(gp,gq,go);return $.New(O,{stream:gq,view:function(gs){return gs(gr);}});},Map:function(gt,gu){return Q.MapResult(function(gv){return gv.$==0?$.New(m,{$:0,$0:gt(gv.$0)}):$.New(m,{$:1,$0:gv.$0});},gu);},MapAsync:function(gw,gx){return Q.MapAsyncResult(function(gy){var gz;if(gy.$==0){gz=gy.$0;return N.Delay(function(){return N.Bind(gw(gz),function(gB){return N.Return($.New(m,{$:0,$0:gB}));});});}else{return N.Return($.New(m,{$:1,$0:gy.$0}));}},gx);},MapAsyncResult:function(gC,gD){var gE;gE=l.New($.New(m,{$:1,$0:$.New(h,{$:0})}),{$:0});gD.stream.Subscribe(function(gF){return N.Start(N.Delay(function(){return N.Bind(gC(gF),function(gH){return N.Return(gE.Trigger(gH));});}),{$:0});});N.Start(N.Delay(function(){return N.Bind(gC(gD.stream.get_Latest()),function(gJ){return N.Return(gE.Trigger(gJ));});}),{$:0});return $.New(O,{stream:gE,view:gD.view});},MapResult:function(gK,gL){var gM;gM=l.New(gK(gL.stream.get_Latest()),{$:0});gL.stream.Subscribe(function(gN){return gM.Trigger(gK(gN));});return $.New(O,{stream:gM,view:gL.view});},MapResultWithWriter:function(gO,gP){var gQ;gQ=l.New($.New(m,{$:1,$0:$.New(h,{$:0})}),{$:0});gP.stream.Subscribe(gO(gQ));return $.New(O,{stream:gQ,view:gP.view});},MapToAsyncResult:function(gR,gS){return Q.MapAsyncResult(function(gT){return gT.$==0?gR(gT.$0):N.Return($.New(m,{$:1,$0:gT.$0}));},gS);},MapToResult:function(gU,gV){return Q.MapResult(function(gW){return gW.$==0?gU(gW.$0):$.New(m,{$:1,$0:gW.$0});},gV);},MapViewArgs:function(gX,gY){var gZ;gZ=gY.view;return $.New(O,{stream:gY.stream,view:function(g0){return g0(gZ(gX));}});},MapWithWriter:function(g1,g2){return Q.MapResultWithWriter(function(g3){return function(g4){var g5;if(g4.$==0){g5=g4.$0;return(g1(g3))(g5);}else{return g3.Trigger($.New(m,{$:1,$0:g4.$0}));}};},g2);},Render:function(g6,g7){return g7.view.call(null,g6);},Return:function(g8){return $.New(O,{stream:l.New($.New(m,{$:0,$0:g8}),{$:0}),view:function(g9){return g9;}});},ReturnFailure:function(){return $.New(O,{stream:l.New($.New(m,{$:1,$0:$.New(h,{$:0})}),{$:0}),view:function(g_){return g_;}});},Run:function(g$,ha){return Q.RunResult(m.Iter(g$),ha);},RunResult:function(hb,hc){hc.stream.Subscribe(hb);return hc;},TransmitReader:function(hd){var he,hf;he=hd.view;hf=hd.stream;return $.New(O,{stream:hd.stream,view:function(hg){return(he(hg))(hf);}});},TransmitReaderMap:function(hh,hi){var hj,hk;hj=hi.view;hk=d.Map(hh,hi.stream);return $.New(O,{stream:hi.stream,view:function(hl){return(hj(hl))(hk);}});},TransmitReaderMapResult:function(hm,hn){var ho,hp;ho=hn.view;hp=d.MapResult(hm,hn.stream);return $.New(O,{stream:hn.stream,view:function(hq){return(ho(hq))(hp);}});},TransmitReaderMapToResult:function(hr,hs){var ht,hu;ht=hs.view;hu=d.MapToResult(hr,hs.stream);return $.New(O,{stream:hs.stream,view:function(hv){return(ht(hv))(hu);}});},TransmitStream:function(hw){var hx,hy;hx=hw.view;hy=hw.stream;return $.New(O,{stream:hw.stream,view:function(hz){return(hx(hz))(hy);}});},TransmitWriter:function(hA){var hB,hC;hB=hA.view;hC=hA.stream;return $.New(O,{stream:hA.stream,view:function(hD){return(hB(hD))(hC);}});},Validation:{Is:function(hE,hF,hG){var hH;hH=l.New(hG.stream.get_Latest(),{$:1,$0:hG.stream.get_Id()});hG.stream.Subscribe(function(hI){return hI.$==0?hE(hI.$0)?hH.Trigger($.New(m,{$:0,$0:hI.$0})):hH.Trigger($.New(m,{$:1,$0:g.ofArray([E.New(hF,hH.get_Id())])})):hH.Trigger($.New(m,{$:1,$0:hI.$0}));});return $.New(O,{stream:hH,view:hG.view});},"Is'":function(hJ,hK,hL){var hM;hM=l.New(hL.stream.get_Latest(),{$:1,$0:hL.stream.get_Id()});hL.stream.Subscribe(function(hN){return hN.$==0?hJ(hN.$0)?hM.Trigger($.New(m,{$:0,$0:hN.$0})):hM.Trigger($.New(m,{$:1,$0:g.ofArray([hK])})):hM.Trigger($.New(m,{$:1,$0:hN.$0}));});return $.New(O,{stream:hM,view:hL.view});},Match:function(hO){var hP;hP=new S(hO);return function(hQ){return hP.test(hQ);};},NotEmpty:function(hR){return hR!=="";}},WithSubmit:function(hS){var hT,hU;hT=H.New(hS.stream,false);hU=hS.view;return $.New(O,{stream:hT.get_Output(),view:function(hV){return(hU(hV))(hT);}});},WithSubmitClearError:function(hW){var hX,hY;hX=H.New(hW.stream,true);hY=hW.view;return $.New(O,{stream:hX.get_Output(),view:function(hZ){return(hY(hZ))(hX);}});},Yield:function(h0){var h1;h1=l.New($.New(m,{$:0,$0:h0}),{$:0});return $.New(O,{stream:h1,view:function(h2){return h2(h1);}});},YieldFailure:function(){var h3;h3=l.New($.New(m,{$:1,$0:$.New(h,{$:0})}),{$:0});return $.New(O,{stream:h3,view:function(h4){return h4(h3);}});},YieldOption:function(h5,h6){var h7,h9;h7=function(h8){return h8.$==1?h8.$0:h6;};h9=function(h_){return z.Equals(h_,h6)?{$:0}:{$:1,$0:h_};};return Q.MapViewArgs(function(h$){return P.Map(h7,h9,h$);},Q.Yield(h5));}},Piglet1:$.Class({get_Stream:function(){return this.stream;}}),Reader:$.Class({SubscribeImmediate:function(ia){return this.Subscribe(ia);},Through:function(ib){var ic,ig=this;ic=l.New(this.get_Latest(),{$:0});ib.Subscribe(function(id){var ie,_if;if(id.$==1){ie=id.$0;_if=[ig.get_Latest(),g.filter(function(ih){return ih.get_Source()===ig.get_Id();},ie)];return _if[1].$==0?ic.Trigger(ig.get_Latest()):_if[0].$==1?ic.Trigger($.New(m,{$:1,$0:g.append(_if[0].$0,_if[1])})):ic.Trigger($.New(m,{$:1,$0:_if[1]}));}else{return ic.Trigger(ig.get_Latest());}});return ic;},get_Id:function(){return this.id;}},{Const:function(ii){return q.New($.New(m,{$:0,$0:ii}));},ConstResult:function(ij){return q.New(ij);},Map:function(ik,il){return d.MapResult(function(im){return m.Map(ik,im);},il);},Map2:function(_in,io,ip){return d.MapResult2(function(iq){return function(ir){return m.Map2(_in,iq,ir);};},io,ip);},MapResult:function(is,it){var iu;iu=l.New(is(it.get_Latest()),{$:0});it.Subscribe(function(iv){return iu.Trigger(is(iv));});return iu;},MapResult2:function(iw,ix,iy){var iz;iz=l.New((iw(ix.get_Latest()))(iy.get_Latest()),{$:0});ix.Subscribe(function(iA){return iz.Trigger((iw(iA))(iy.get_Latest()));});iy.Subscribe(function(iB){return iz.Trigger((iw(ix.get_Latest()))(iB));});return iz;},MapToResult:function(iC,iD){return d.MapResult(m.Bind(iC),iD);},New:function(iE){var iF;iF=$.New(this,{});iF.id=iE;return iF;}}),Result:$.Class({get_isSuccess:function(){return this.$==1?false:true;}},{Ap:function(iG,iH){var iI;iI=[iG,iH];return iI[0].$==1?iI[1].$==1?$.New(m,{$:1,$0:g.append(iI[0].$0,iI[1].$0)}):$.New(m,{$:1,$0:iI[0].$0}):iI[1].$==1?$.New(m,{$:1,$0:iI[1].$0}):$.New(m,{$:0,$0:iI[0].$0.call(null,iI[1].$0)});},Bind:function(iJ){return function(iK){return iK.$==1?$.New(m,{$:1,$0:iK.$0}):iJ(iK.$0);};},Failwith:function(iL){return $.New(m,{$:1,$0:g.ofArray([E.New(iL,0)])});},Iter:function(iM){return function(iN){return iN.$==1?null:iM(iN.$0);};},Join:function(iO){return iO.$==0?iO.$0.$==0?$.New(m,{$:0,$0:iO.$0.$0}):$.New(m,{$:1,$0:iO.$0.$0}):$.New(m,{$:1,$0:iO.$0});},Map:function(iP,iQ){return iQ.$==1?$.New(m,{$:1,$0:iQ.$0}):$.New(m,{$:0,$0:iP(iQ.$0)});},Map2:function(iR,iS,iT){var iU,iV;iU=[iS,iT];if(iU[0].$==1){return iU[1].$==1?$.New(m,{$:1,$0:g.append(iU[0].$0,iU[1].$0)}):$.New(m,{$:1,$0:iU[0].$0});}else{if(iU[1].$==1){return $.New(m,{$:1,$0:iU[1].$0});}else{iV=iU[1].$0;return $.New(m,{$:0,$0:(iR(iU[0].$0))(iV)});}}}}),Stream:{Ap:function(iW,iX){var iY;iY=l.New(m.Ap(iW.get_Latest(),iX.get_Latest()),{$:0});iW.Subscribe(function(iZ){return iY.Trigger(m.Ap(iZ,iX.get_Latest()));});iX.Subscribe(function(i0){return iY.Trigger(m.Ap(iW.get_Latest(),i0));});return iY;},ApJoin:function(i1,i2){var i3;i3=l.New(m.Ap(i1.get_Latest(),m.Join(i2.get_Latest())),{$:0});i1.Subscribe(function(i4){return i3.Trigger(m.Ap(i4,m.Join(i2.get_Latest())));});i2.Subscribe(function(i5){return i3.Trigger(m.Ap(i1.get_Latest(),m.Join(i5)));});return i3;},Map:function(i6,i7,i8){var i9,i_,i$;i9=l.New(m.Map(i6,i8.get_Latest()),{$:1,$0:i8.get_Id()});i_=[i8.get_Latest()];i$=[i9.get_Latest()];i8.Subscribe(function(ja){if(i_[0]!==ja){i$[0]=m.Map(i6,ja);return i9.Trigger(i$[0]);}else{return null;}});i9.Subscribe(function(jb){if(i$[0]!==jb){i_[0]=m.Map(i7,jb);return i8.Trigger(i_[0]);}else{return null;}});return i9;}},Stream1:$.Class({Subscribe:function(jc){return T.subscribeTo(this.s,jc);},Trigger:function(jd){return this.s.Trigger(jd);},Trigger1:function(je){return this.Trigger(je);},Write:function(jf){var jh=this;return p.New(function(jg){return jg.$==0?jh.Trigger($.New(m,{$:0,$0:jf})):jh.Trigger($.New(m,{$:1,$0:jg.$0}));});},get_Latest:function(){return this.s.Latest[0].$0;}},{New:function(ji,jj){return $.New(this,l.New1(W.New(ji),jj));},New1:function(jk,jl){var jm;jm=$.New(this,d.New(jl.$==0?(o.next())(null):jl.$0));jm.s=jk;return jm;}}),Submitter:$.Class({Subscribe:function(jn){return this.output.Subscribe(jn);},Trigger:function(){return this.writer.Trigger($.New(m,{$:0,$0:null}));},Trigger1:function(jo){return this.writer.Trigger(jo);},get_Input:function(){return this.input;},get_Latest:function(){return this.output.get_Latest();},get_Output:function(){return this.output;}},{New:function(jp,jq){var jr;jr=$.New(this,d.New((o.next())(null)));jr.input=jp;jr.output=l.New($.New(m,{$:1,$0:$.New(h,{$:0})}),{$:0});jr.writer=p.New(function(js){var jt;jt=[js,jr.input.get_Latest()];return jt[0].$==0?jt[1].$==0?jr.output.Trigger($.New(m,{$:0,$0:jt[1].$0})):jr.output.Trigger($.New(m,{$:1,$0:jt[1].$0})):jt[1].$==0?jr.output.Trigger($.New(m,{$:1,$0:jt[0].$0})):jr.output.Trigger($.New(m,{$:1,$0:g.append(jt[0].$0,jt[1].$0)}));});if(jq){jr.input.Subscribe(function(){var jv;jv=jr.output.get_Latest();return jv.$==1?jv.$0.$==0?null:jr.output.Trigger($.New(m,{$:1,$0:$.New(h,{$:0})})):jr.output.Trigger($.New(m,{$:1,$0:$.New(h,{$:0})}));});}return jr;}})}}});$.OnInit(function(){a=$.Safe($$.WebSharper.Piglets);b=$.Safe(a.Choose);c=$.Safe(b.Stream);d=$.Safe(a.Reader);e=$.Safe($$.WebSharper.Collections);f=$.Safe(e.Dictionary);g=$.Safe($$.WebSharper.List);h=$.Safe(g.T);i=$.Safe($$.WebSharper.Enumerator);j=$.Safe($$.WebSharper.Seq);k=$.Safe($$.WebSharper.Operators);l=$.Safe(a.Stream1);m=$.Safe(a.Result);n=$.Safe(a.ConcreteReader);o=$.Safe(a.Id);p=$.Safe(a.ConcreteWriter);q=$.Safe(a.ConstReader);r=$.Safe(a.Disposable);s=$.Safe($$.WebSharper.Html);t=$.Safe(s.Client);u=$.Safe(t.Operators);v=$.Safe(t.Tags);w=$.Safe(t.EventsPervasives);x=$.Safe(a.Controls);y=$.Safe(t.Attr);z=$.Safe($$.WebSharper.Unchecked);A=$.Safe($$.jQuery);B=$.Safe(x.HtmlContainer);C=$.Safe($$.WebSharper.Arrays);D=$.Safe($$.WebSharper.Ref);E=$.Safe(a.ErrorMessage);F=$.Safe(a.Many);G=$.Safe(F.Stream);H=$.Safe(a.Submitter);I=$.Safe(F.Operations);J=$.Safe(e.ResizeArray);K=$.Safe(J.ResizeArrayProxy);L=$.Safe(F.UnitStream);M=$.Safe(a.Pervasives);N=$.Safe($$.WebSharper.Concurrency);O=$.Safe(a.Piglet1);P=$.Safe(a.Stream);Q=$.Safe(a.Piglet);R=$.Safe(Q.Validation);S=$.Safe($$.RegExp);T=$.Safe($$.WebSharper.Util);U=$.Safe($$.IntelliFactory);V=$.Safe(U.Reactive);return W=$.Safe(V.HotStream);});$.OnLoad(function(){$.Inherit(c,d);$.Inherit(n,d);$.Inherit(q,d);$.Inherit(G,d);$.Inherit(G,d);$.Inherit(L,G);$.Inherit(l,d);$.Inherit(H,d);o.next();x.nextId();return;});}());

if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    module.exports = mod();
  else if (typeof define == "function" && define.amd) // AMD
    return define([], mod);
  else // Plain browser env
    this.CodeMirror = mod();
})(function() {
  "use strict";

  // BROWSER SNIFFING

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.

  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var ie = ie_upto10 || ie_11up;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var presto = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);

  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /win/i.test(navigator.platform);

  var presto_version = presto && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) presto_version = Number(presto_version[1]);
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  // EDITOR CONSTRUCTOR

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);

    var doc = options.value;
    if (typeof doc == "string") doc = new Doc(doc, options.mode);
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += " CodeMirror-wrap";
    if (options.autofocus && !mobile) display.input.focus();
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    var cm = this;

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || cm.hasFocus())
      setTimeout(bind(onFocus, this), 20);
    else
      onBlur(this);

    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
      optionHandlers[opt](this, options[opt], Init);
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) options.finishInit(this);
    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      display.lineDiv.style.textRendering = "auto";
  }

  // DISPLAY CONSTRUCTOR

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = elt("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;

    if (place) {
      if (place.appendChild) place.appendChild(d.wrapper);
      else place(d.wrapper);
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    input.init(d);
  }

  // STATE UPDATES

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function(line) {
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) regChange(cm);
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function(){updateScrollbars(cm);}, 100);
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line)) return 0;

      var widgetsHeight = 0;
      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
      }

      if (wrapping)
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return widgetsHeight + th;
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function(){alignHorizontally(cm);}, 20);
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  }

  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find(0, true);
      len -= cur.text.length - found.from.ch;
      cur = found.to.line;
      len += cur.text.length - found.to.ch;
    }
    return len;
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function(line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }

  function NativeScrollbars(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    place(vert); place(horiz);

    on(vert, "scroll", function() {
      if (vert.clientHeight) scroll(vert.scrollTop, "vertical");
    });
    on(horiz, "scroll", function() {
      if (horiz.clientWidth) scroll(horiz.scrollLeft, "horizontal");
    });

    this.checkedOverlay = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
  }

  NativeScrollbars.prototype = copyObj({
    update: function(measure) {
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      var sWidth = measure.nativeBarWidth;

      if (needsV) {
        this.vert.style.display = "block";
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
        // A bug in IE8 can cause this value to be negative, so guard it.
        this.vert.firstChild.style.height =
          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
      } else {
        this.vert.style.display = "";
        this.vert.firstChild.style.height = "0";
      }

      if (needsH) {
        this.horiz.style.display = "block";
        this.horiz.style.right = needsV ? sWidth + "px" : "0";
        this.horiz.style.left = measure.barLeft + "px";
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
        this.horiz.firstChild.style.width =
          (measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
      } else {
        this.horiz.style.display = "";
        this.horiz.firstChild.style.width = "0";
      }

      if (!this.checkedOverlay && measure.clientHeight > 0) {
        if (sWidth == 0) this.overlayHack();
        this.checkedOverlay = true;
      }

      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};
    },
    setScrollLeft: function(pos) {
      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;
    },
    setScrollTop: function(pos) {
      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;
    },
    overlayHack: function() {
      var w = mac && !mac_geMountainLion ? "12px" : "18px";
      this.horiz.style.minHeight = this.vert.style.minWidth = w;
      var self = this;
      var barMouseDown = function(e) {
        if (e_target(e) != self.vert && e_target(e) != self.horiz)
          operation(self.cm, onMouseDown)(e);
      };
      on(this.vert, "mousedown", barMouseDown);
      on(this.horiz, "mousedown", barMouseDown);
    },
    clear: function() {
      var parent = this.horiz.parentNode;
      parent.removeChild(this.horiz);
      parent.removeChild(this.vert);
    }
  }, NativeScrollbars.prototype);

  function NullScrollbars() {}

  NullScrollbars.prototype = copyObj({
    update: function() { return {bottom: 0, right: 0}; },
    setScrollLeft: function() {},
    setScrollTop: function() {},
    clear: function() {}
  }, NullScrollbars.prototype);

  CodeMirror.scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }

    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function() {
        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);
      });
      node.setAttribute("cm-not-content", "true");
    }, function(pos, axis) {
      if (axis == "horizontal") setScrollLeft(cm, pos);
      else setScrollTop(cm, pos);
    }, cm);
    if (cm.display.scrollbars.addClass)
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
  }

  function updateScrollbars(cm, measure) {
    if (!measure) measure = measureForScrollbars(cm);
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        updateHeightsInViewport(cm);
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else d.scrollbarFiller.style.display = "";
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else d.gutterFiller.style.display = "";
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)};
  }

  // LINE NUMBERS

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
      if (cm.options.fixedGutter && view[i].gutter)
        view[i].gutter.style.left = left;
      var align = view[i].alignable;
      if (align) for (var j = 0; j < align.length; j++)
        align[j].style.left = left;
    }
    if (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + "px";
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true;
    }
    return false;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }

  // DISPLAY DRAWING

  function DisplayUpdate(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  }

  DisplayUpdate.prototype.signal = function(emitter, type) {
    if (hasHandler(emitter, type))
      this.events.push(arguments);
  };
  DisplayUpdate.prototype.finish = function() {
    for (var i = 0; i < this.events.length; i++)
      signal.apply(null, this.events[i]);
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      return false;

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      return false;

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var focused = activeElt();
    if (toUpdate > 4) display.lineDiv.style.display = "none";
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) display.lineDiv.style.display = "";
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true;
  }

  function postUpdateDisplay(cm, update) {
    var force = update.force, viewport = update.viewport;
    for (var first = true;; first = false) {
      if (first && cm.options.lineWrapping && update.oldDisplayWidth != displayWidth(cm)) {
        force = true;
      } else {
        force = false;
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          break;
      }
      if (!updateDisplayIfNeeded(cm, update)) break;
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      setDocumentHeight(cm, barMeasure);
      updateScrollbars(cm, barMeasure);
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      setDocumentHeight(cm, barMeasure);
      updateScrollbars(cm, barMeasure);
      update.finish();
    }
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    var total = measure.docHeight + cm.display.barHeight;
    cm.display.heightForcer.style.top = total + "px";
    cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + "px";
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], height;
      if (cur.hidden) continue;
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      var diff = cur.line.height - height;
      if (height < 2) height = textHeight(display);
      if (diff > .001 || diff < -.001) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
          updateWidgetHeight(cur.rest[j]);
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
      line.widgets[i].height = line.widgets[i].node.offsetHeight;
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[cm.options.gutters[i]] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        node.style.display = "none";
      else
        node.parentNode.removeChild(node);
      return next;
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) {
      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) cur = rm(cur);
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) cur = rm(cur);
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") updateLineText(cm, lineView);
      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
      else if (type == "class") updateLineClasses(lineView);
      else if (type == "widget") updateLineWidgets(cm, lineView, dims);
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;
    }
    return lineView.node;
  }

  function updateLineBackground(lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) cls += " CodeMirror-linebackground";
    if (lineView.background) {
      if (cls) lineView.background.className = cls;
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) lineView.node = built.pre;
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(lineView) {
    updateLineBackground(lineView);
    if (lineView.line.wrapClass)
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    else if (lineView.node != lineView.text)
      lineView.node.className = "";
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " +
                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +
                                             "px; width: " + dims.gutterTotalWidth + "px");
      cm.display.input.setUneditable(gutterWrap);
      wrap.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        gutterWrap.className += " " + lineView.line.gutterClass;
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
              + cm.display.lineNumInnerWidth + "px"));
      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
      }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) lineView.alignable = null;
    for (var node = lineView.node.firstChild, next; node; node = next) {
      var next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        lineView.node.removeChild(node);
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) lineView.bgClass = built.bgClass;
    if (built.textClass) lineView.textClass = built.textClass;

    updateLineClasses(lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node;
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) return;
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) node.setAttribute("cm-ignore-events", "true");
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      else
        wrap.appendChild(node);
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
    }
  }

  // POSITION OBJECT

  // A Pos instance represents a position within the text.
  var Pos = CodeMirror.Pos = function(line, ch) {
    if (!(this instanceof Pos)) return new Pos(line, ch);
    this.line = line; this.ch = ch;
  };

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };

  function copyPos(x) {return Pos(x.line, x.ch);}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }

  // INPUT HANDLING

  function ensureFocus(cm) {
    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
  }

  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }

  // This will be set to an array of strings when copying, so that,
  // when pasting, we know what kind of selections the copied text
  // was made out of.
  var lastCopied = null;

  function applyTextInput(cm, inserted, deleted, sel) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) sel = doc.sel;

    var textLines = splitLines(inserted), multiPaste = null;
    // When pasing N lines into N selections, insert one line per selection
    if (cm.state.pasteIncoming && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.join("\n") == inserted)
        multiPaste = sel.ranges.length % lastCopied.length == 0 && map(lastCopied, splitLines);
      else if (textLines.length == sel.ranges.length)
        multiPaste = map(textLines, function(l) { return [l]; });
    }

    // Normal behavior is to insert the new text into every selection
    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      var from = range.from(), to = range.to();
      if (range.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          from = Pos(from.line, from.ch - deleted);
        else if (cm.state.overwrite && !cm.state.pasteIncoming) // Handle overwrite
          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
      }
      var updateInput = cm.curOp.updateInput;
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
                         origin: cm.state.pasteIncoming ? "paste" : cm.state.cutIncoming ? "cut" : "+input"};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
      // When an 'electric' character is inserted, immediately trigger a reindent
      if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&
          cm.options.smartIndent && range.head.ch < 100 &&
          (!i || sel.ranges[i - 1].head.line != range.head.line)) {
        var mode = cm.getModeAt(range.head);
        var end = changeEnd(changeEvent);
        if (mode.electricChars) {
          for (var j = 0; j < mode.electricChars.length; j++)
            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
              indentLine(cm, end.line, "smart");
              break;
            }
        } else if (mode.electricInput) {
          if (mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)))
            indentLine(cm, end.line, "smart");
        }
      }
    }
    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges};
  }

  function disableBrowserMagic(field) {
    field.setAttribute("autocorrect", "off");
    field.setAttribute("autocapitalize", "off");
    field.setAttribute("spellcheck", "false");
  }

  // TEXTAREA INPUT STYLE

  function TextareaInput(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Tracks when input.reset has punted to just putting a short
    // string into the textarea instead of the full selection.
    this.inaccurateSelection = false;
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
  };

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) te.style.width = "1000px";
    else te.setAttribute("wrap", "off");
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) te.style.border = "1px solid black";
    disableBrowserMagic(te);
    return div;
  }

  TextareaInput.prototype = copyObj({
    init: function(display) {
      var input = this, cm = this.cm;

      // Wraps and hides input textarea
      var div = this.wrapper = hiddenTextarea();
      // The semihidden textarea that is focused when the editor is
      // focused, and receives input.
      var te = this.textarea = div.firstChild;
      display.wrapper.insertBefore(div, display.wrapper.firstChild);

      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
      if (ios) te.style.width = "0px";

      on(te, "input", function() {
        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;
        input.poll();
      });

      on(te, "paste", function() {
        // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206
        // Add a char to the end of textarea before paste occur so that
        // selection doesn't span to the end of textarea.
        if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {
          var start = te.selectionStart, end = te.selectionEnd;
          te.value += "$";
          // The selection end needs to be set before the start, otherwise there
          // can be an intermediate non-empty selection between the two, which
          // can override the middle-click paste buffer on linux and cause the
          // wrong thing to get pasted.
          te.selectionEnd = end;
          te.selectionStart = start;
          cm.state.fakedLastChar = true;
        }
        cm.state.pasteIncoming = true;
        input.fastPoll();
      });

      function prepareCopyCut(e) {
        if (cm.somethingSelected()) {
          lastCopied = cm.getSelections();
          if (input.inaccurateSelection) {
            input.prevInput = "";
            input.inaccurateSelection = false;
            te.value = lastCopied.join("\n");
            selectInput(te);
          }
        } else {
          var ranges = copyableRanges(cm);
          lastCopied = ranges.text;
          if (e.type == "cut") {
            cm.setSelections(ranges.ranges, null, sel_dontScroll);
          } else {
            input.prevInput = "";
            te.value = ranges.text.join("\n");
            selectInput(te);
          }
        }
        if (e.type == "cut") cm.state.cutIncoming = true;
      }
      on(te, "cut", prepareCopyCut);
      on(te, "copy", prepareCopyCut);

      on(display.scroller, "paste", function(e) {
        if (eventInWidget(display, e)) return;
        cm.state.pasteIncoming = true;
        input.focus();
      });

      // Prevent normal selection in the editor (we handle our own)
      on(display.lineSpace, "selectstart", function(e) {
        if (!eventInWidget(display, e)) e_preventDefault(e);
      });
    },

    prepareSelection: function() {
      // Redraw the selection and/or cursor
      var cm = this.cm, display = cm.display, doc = cm.doc;
      var result = prepareSelection(cm);

      // Move the hidden textarea near the cursor to prevent scrolling artifacts
      if (cm.options.moveInputWithCursor) {
        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                            headPos.top + lineOff.top - wrapOff.top));
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                             headPos.left + lineOff.left - wrapOff.left));
      }

      return result;
    },

    showSelection: function(drawn) {
      var cm = this.cm, display = cm.display;
      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
      if (drawn.teTop != null) {
        this.wrapper.style.top = drawn.teTop + "px";
        this.wrapper.style.left = drawn.teLeft + "px";
      }
    },

    // Reset the input to correspond to the selection (or to be empty,
    // when not typing and nothing is selected)
    reset: function(typing) {
      if (this.contextMenuPending) return;
      var minimal, selected, cm = this.cm, doc = cm.doc;
      if (cm.somethingSelected()) {
        this.prevInput = "";
        var range = doc.sel.primary();
        minimal = hasCopyEvent &&
          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
        var content = minimal ? "-" : selected || cm.getSelection();
        this.textarea.value = content;
        if (cm.state.focused) selectInput(this.textarea);
        if (ie && ie_version >= 9) this.hasSelection = content;
      } else if (!typing) {
        this.prevInput = this.textarea.value = "";
        if (ie && ie_version >= 9) this.hasSelection = null;
      }
      this.inaccurateSelection = minimal;
    },

    getField: function() { return this.textarea; },

    supportsTouch: function() { return false; },

    focus: function() {
      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
        try { this.textarea.focus(); }
        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
      }
    },

    blur: function() { this.textarea.blur(); },

    resetPosition: function() {
      this.wrapper.style.top = this.wrapper.style.left = 0;
    },

    receivedFocus: function() { this.slowPoll(); },

    // Poll for input changes, using the normal rate of polling. This
    // runs as long as the editor is focused.
    slowPoll: function() {
      var input = this;
      if (input.pollingFast) return;
      input.polling.set(this.cm.options.pollInterval, function() {
        input.poll();
        if (input.cm.state.focused) input.slowPoll();
      });
    },

    // When an event has just come in that is likely to add or change
    // something in the input textarea, we poll faster, to ensure that
    // the change appears on the screen quickly.
    fastPoll: function() {
      var missed = false, input = this;
      input.pollingFast = true;
      function p() {
        var changed = input.poll();
        if (!changed && !missed) {missed = true; input.polling.set(60, p);}
        else {input.pollingFast = false; input.slowPoll();}
      }
      input.polling.set(20, p);
    },

    // Read input from the textarea, and update the document to match.
    // When something is selected, it is present in the textarea, and
    // selected (unless it is huge, in which case a placeholder is
    // used). When nothing is selected, the cursor sits after previously
    // seen text (can be empty), which is stored in prevInput (we must
    // not reset the textarea when typing, because that breaks IME).
    poll: function() {
      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
      // Since this is called a *lot*, try to bail out as cheaply as
      // possible when it is clear that nothing happened. hasSelection
      // will be the case when there is a lot of text in the textarea,
      // in which case reading its value would be expensive.
      if (!cm.state.focused || (hasSelection(input) && !prevInput) ||
          isReadOnly(cm) || cm.options.disableInput || cm.state.keySeq)
        return false;
      // See paste handler for more on the fakedLastChar kludge
      if (cm.state.pasteIncoming && cm.state.fakedLastChar) {
        input.value = input.value.substring(0, input.value.length - 1);
        cm.state.fakedLastChar = false;
      }
      var text = input.value;
      // If nothing changed, bail.
      if (text == prevInput && !cm.somethingSelected()) return false;
      // Work around nonsensical selection resetting in IE9/10, and
      // inexplicable appearance of private area unicode characters on
      // some key combos in Mac (#2689).
      if (ie && ie_version >= 9 && this.hasSelection === text ||
          mac && /[\uf700-\uf7ff]/.test(text)) {
        cm.display.input.reset();
        return false;
      }

      if (cm.doc.sel == cm.display.selForContextMenu) {
        if (text.charCodeAt(0) == 0x200b) {
          if (!prevInput) prevInput = "\u200b";
        } else if (prevInput == "\u200b") {
          text = text.slice(1);
          prevInput = "";
        }
      }
      // Find the part of the input that is actually new
      var same = 0, l = Math.min(prevInput.length, text.length);
      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;

      var self = this;
      runInOp(cm, function() {
        applyTextInput(cm, text.slice(same), prevInput.length - same);

        // Don't leave long text in the textarea, since it makes further polling slow
        if (text.length > 1000 || text.indexOf("\n") > -1) input.value = self.prevInput = "";
        else self.prevInput = text;
      });
      return true;
    },

    ensurePolled: function() {
      if (this.pollingFast && this.poll()) this.pollingFast = false;
    },

    onKeyPress: function() {
      if (ie && ie_version >= 9) this.hasSelection = null;
      this.fastPoll();
    },

    onContextMenu: function(e) {
      var input = this, cm = input.cm, display = cm.display, te = input.textarea;
      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
      if (!pos || presto) return; // Opera is difficult.

      // Reset the current text selection only if the click is done outside of the selection
      // and 'resetSelectionOnContextMenu' option is true.
      var reset = cm.options.resetSelectionOnContextMenu;
      if (reset && cm.doc.sel.contains(pos) == -1)
        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

      var oldCSS = te.style.cssText;
      input.wrapper.style.position = "absolute";
      te.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
        "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: " +
        (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
        "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)
      display.input.focus();
      if (webkit) window.scrollTo(null, oldScrollY);
      display.input.reset();
      // Adds "Select all" to context menu in FF
      if (!cm.somethingSelected()) te.value = input.prevInput = " ";
      input.contextMenuPending = true;
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);

      // Select-all will be greyed out if there's nothing to select, so
      // this adds a zero-width space so that we can later check whether
      // it got selected.
      function prepareSelectAllHack() {
        if (te.selectionStart != null) {
          var selected = cm.somethingSelected();
          var extval = te.value = "\u200b" + (selected ? te.value : "");
          input.prevInput = selected ? "" : "\u200b";
          te.selectionStart = 1; te.selectionEnd = extval.length;
          // Re-set this, in case some other handler touched the
          // selection in the meantime.
          display.selForContextMenu = cm.doc.sel;
        }
      }
      function rehide() {
        input.contextMenuPending = false;
        input.wrapper.style.position = "relative";
        te.style.cssText = oldCSS;
        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);

        // Try to detect the user choosing select-all
        if (te.selectionStart != null) {
          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();
          var i = 0, poll = function() {
            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && input.prevInput == "\u200b")
              operation(cm, commands.selectAll)(cm);
            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);
            else display.input.reset();
          };
          display.detectingSelectAll = setTimeout(poll, 200);
        }
      }

      if (ie && ie_version >= 9) prepareSelectAllHack();
      if (captureRightClick) {
        e_stop(e);
        var mouseup = function() {
          off(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    },

    setUneditable: nothing,

    needsContentAttribute: false
  }, TextareaInput.prototype);

  // CONTENTEDITABLE INPUT STYLE

  function ContentEditableInput(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.gracePeriod = false;
  }

  ContentEditableInput.prototype = copyObj({
    init: function(display) {
      var input = this, cm = input.cm;
      var div = input.div = display.lineDiv;
      div.contentEditable = "true";
      disableBrowserMagic(div);

      on(div, "paste", function(e) {
        var pasted = e.clipboardData && e.clipboardData.getData("text/plain");
        if (pasted) {
          e.preventDefault();
          cm.replaceSelection(pasted, null, "paste");
        }
      });

      on(div, "compositionstart", function(e) {
        var data = e.data;
        input.composing = {sel: cm.doc.sel, data: data, startData: data};
        if (!data) return;
        var prim = cm.doc.sel.primary();
        var line = cm.getLine(prim.head.line);
        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));
        if (found > -1 && found <= prim.head.ch)
          input.composing.sel = simpleSelection(Pos(prim.head.line, found),
                                                Pos(prim.head.line, found + data.length));
      });
      on(div, "compositionupdate", function(e) {
        input.composing.data = e.data;
      });
      on(div, "compositionend", function(e) {
        var ours = input.composing;
        if (!ours) return;
        if (e.data != ours.startData && !/\u200b/.test(e.data))
          ours.data = e.data;
        // Need a small delay to prevent other code (input event,
        // selection polling) from doing damage when fired right after
        // compositionend.
        setTimeout(function() {
          if (!ours.handled)
            input.applyComposition(ours);
          if (input.composing == ours)
            input.composing = null;
        }, 50);
      });

      on(div, "touchstart", function() {
        input.forceCompositionEnd();
      });

      on(div, "input", function() {
        if (input.composing) return;
        if (!input.pollContent())
          runInOp(input.cm, function() {regChange(cm);});
      });

      function onCopyCut(e) {
        if (cm.somethingSelected()) {
          lastCopied = cm.getSelections();
          if (e.type == "cut") cm.replaceSelection("", null, "cut");
        } else {
          var ranges = copyableRanges(cm);
          lastCopied = ranges.text;
          if (e.type == "cut") {
            cm.operation(function() {
              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
              cm.replaceSelection("", null, "cut");
            });
          }
        }
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        if (e.clipboardData && !ios) {
          e.preventDefault();
          e.clipboardData.clearData();
          e.clipboardData.setData("text/plain", lastCopied.join("\n"));
        } else {
          // Old-fashioned briefly-focus-a-textarea hack
          var kludge = hiddenTextarea(), te = kludge.firstChild;
          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
          te.value = lastCopied.join("\n");
          var hadFocus = document.activeElement;
          selectInput(te);
          setTimeout(function() {
            cm.display.lineSpace.removeChild(kludge);
            hadFocus.focus();
          }, 50);
        }
      }
      on(div, "copy", onCopyCut);
      on(div, "cut", onCopyCut);
    },

    prepareSelection: function() {
      var result = prepareSelection(this.cm, false);
      result.focus = this.cm.state.focused;
      return result;
    },

    showSelection: function(info) {
      if (!info || !this.cm.display.view.length) return;
      if (info.focus) this.showPrimarySelection();
      this.showMultipleSelections(info);
    },

    showPrimarySelection: function() {
      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();
      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&
          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
        return;

      var start = posToDOM(this.cm, prim.from());
      var end = posToDOM(this.cm, prim.to());
      if (!start && !end) return;

      var view = this.cm.display.view;
      var old = sel.rangeCount && sel.getRangeAt(0);
      if (!start) {
        start = {node: view[0].measure.map[2], offset: 0};
      } else if (!end) { // FIXME dangerously hacky
        var measure = view[view.length - 1].measure;
        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
      }

      try { var rng = range(start.node, start.offset, end.offset, end.node); }
      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
      if (rng) {
        sel.removeAllRanges();
        sel.addRange(rng);
        if (old && sel.anchorNode == null) sel.addRange(old);
        else if (gecko) this.startGracePeriod();
      }
      this.rememberSelection();
    },

    startGracePeriod: function() {
      var input = this;
      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function() {
        input.gracePeriod = false;
        if (input.selectionChanged())
          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });
      }, 20);
    },

    showMultipleSelections: function(info) {
      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
    },

    rememberSelection: function() {
      var sel = window.getSelection();
      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
    },

    selectionInEditor: function() {
      var sel = window.getSelection();
      if (!sel.rangeCount) return false;
      var node = sel.getRangeAt(0).commonAncestorContainer;
      return contains(this.div, node);
    },

    focus: function() {
      if (this.cm.options.readOnly != "nocursor") this.div.focus();
    },
    blur: function() { this.div.blur(); },
    getField: function() { return this.div; },

    supportsTouch: function() { return true; },

    receivedFocus: function() {
      var input = this;
      if (this.selectionInEditor())
        this.pollSelection();
      else
        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });

      function poll() {
        if (input.cm.state.focused) {
          input.pollSelection();
          input.polling.set(input.cm.options.pollInterval, poll);
        }
      }
      this.polling.set(this.cm.options.pollInterval, poll);
    },

    selectionChanged: function() {
      var sel = window.getSelection();
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    },

    pollSelection: function() {
      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {
        var sel = window.getSelection(), cm = this.cm;
        this.rememberSelection();
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (anchor && head) runInOp(cm, function() {
          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;
        });
      }
    },

    pollContent: function() {
      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
      var from = sel.from(), to = sel.to();
      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;

      var fromIndex;
      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
        var fromLine = lineNo(display.view[0].line);
        var fromNode = display.view[0].node;
      } else {
        var fromLine = lineNo(display.view[fromIndex].line);
        var fromNode = display.view[fromIndex - 1].node.nextSibling;
      }
      var toIndex = findViewIndex(cm, to.line);
      if (toIndex == display.view.length - 1) {
        var toLine = display.viewTo - 1;
        var toNode = display.view[toIndex].node;
      } else {
        var toLine = lineNo(display.view[toIndex + 1].line) - 1;
        var toNode = display.view[toIndex + 1].node.previousSibling;
      }

      var newText = splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
      while (newText.length > 1 && oldText.length > 1) {
        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
        else break;
      }

      var cutFront = 0, cutEnd = 0;
      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
        ++cutFront;
      var newBot = lst(newText), oldBot = lst(oldText);
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                               oldBot.length - (oldText.length == 1 ? cutFront : 0));
      while (cutEnd < maxCutEnd &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
        ++cutEnd;

      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);
      newText[0] = newText[0].slice(cutFront);

      var chFrom = Pos(fromLine, cutFront);
      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
        return true;
      }
    },

    ensurePolled: function() {
      this.forceCompositionEnd();
    },
    reset: function() {
      this.forceCompositionEnd();
    },
    forceCompositionEnd: function() {
      if (!this.composing || this.composing.handled) return;
      this.applyComposition(this.composing);
      this.composing.handled = true;
      this.div.blur();
      this.div.focus();
    },
    applyComposition: function(composing) {
      if (composing.data && composing.data != composing.startData)
        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);
    },

    setUneditable: function(node) {
      node.setAttribute("contenteditable", "false");
    },

    onKeyPress: function(e) {
      e.preventDefault();
      operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
    },

    onContextMenu: nothing,
    resetPosition: nothing,

    needsContentAttribute: true
  }, ContentEditableInput.prototype);

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) return null;
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, "left");
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result;
  }

  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) return null;
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        return locateNodeInLineView(lineView, node, offset);
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) offset = textNode.nodeValue.length;
    }
    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map.length; j += 3) {
          var curNode = map[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map[j] + offset;
            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];
            return Pos(line, ch);
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) return badPos(found, bad);

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        return badPos(Pos(found.line, found.ch - dist), bad);
      else
        dist += after.textContent.length;
    }
    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        return badPos(Pos(found.line, found.ch + dist), bad);
      else
        dist += after.textContent.length;
    }
  }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false;
    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText != null) {
          if (cmText == "") cmText = node.textContent.replace(/\u200b/g, "");
          text += cmText;
          return;
        }
        var markerID = node.getAttribute("cm-marker"), range;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range = found[0].find()))
            text += getBetween(cm.doc, range.from, range.to).join("\n");
          return;
        }
        if (node.getAttribute("contenteditable") == "false") return;
        for (var i = 0; i < node.childNodes.length; i++)
          walk(node.childNodes[i]);
        if (/^(pre|div|p)$/i.test(node.nodeName))
          closing = true;
      } else if (node.nodeType == 3) {
        var val = node.nodeValue;
        if (!val) return;
        if (closing) {
          text += "\n";
          closing = false;
        }
        text += val;
      }
    }
    for (;;) {
      walk(from);
      if (from == to) break;
      from = from.nextSibling;
    }
    return text;
  }

  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // SELECTION / CURSOR

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  function Selection(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  }

  Selection.prototype = {
    primary: function() { return this.ranges[this.primIndex]; },
    equals: function(other) {
      if (other == this) return true;
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
      for (var i = 0; i < this.ranges.length; i++) {
        var here = this.ranges[i], there = other.ranges[i];
        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
      }
      return true;
    },
    deepCopy: function() {
      for (var out = [], i = 0; i < this.ranges.length; i++)
        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
      return new Selection(out, this.primIndex);
    },
    somethingSelected: function() {
      for (var i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].empty()) return true;
      return false;
    },
    contains: function(pos, end) {
      if (!end) end = pos;
      for (var i = 0; i < this.ranges.length; i++) {
        var range = this.ranges[i];
        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
          return i;
      }
      return -1;
    }
  };

  function Range(anchor, head) {
    this.anchor = anchor; this.head = head;
  }

  Range.prototype = {
    from: function() { return minPos(this.anchor, this.head); },
    to: function() { return maxPos(this.anchor, this.head); },
    empty: function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    }
  };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) --primIndex;
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
    else if (ch < 0) return Pos(pos.line, 0);
    else return pos;
  }
  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
  function clipPosArray(doc, array) {
    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
    return out;
  }

  // SELECTION UPDATES

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(doc, range, head, other) {
    if (doc.cm && doc.cm.display.shift || doc.extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options) {
    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head));
      }
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    else return sel;
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      sel = filterSelectionChange(doc, sel);

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      ensureCursorVisible(doc.cm);
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) return;

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) out = sel.ranges.slice(0, i);
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search: for (;;) {
      var line = getLine(doc, curPos.line);
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var sp = line.markedSpans[i], m = sp.marker;
          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&
              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
            if (mayClear) {
              signal(m, "beforeCursorEnter");
              if (m.explicitlyCleared) {
                if (!line.markedSpans) break;
                else {--i; continue;}
              }
            }
            if (!m.atomic) continue;
            var newPos = m.find(dir < 0 ? -1 : 1);
            if (cmp(newPos, curPos) == 0) {
              newPos.ch += dir;
              if (newPos.ch < 0) {
                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));
                else newPos = null;
              } else if (newPos.ch > line.text.length) {
                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);
                else newPos = null;
              }
              if (!newPos) {
                if (flipped) {
                  // Driven in a corner -- no valid cursor position found at all
                  // -- try again *with* clearing, if we didn't already
                  if (!mayClear) return skipAtomic(doc, pos, bias, true);
                  // Otherwise, turn off editing until further notice, and return the start of the doc
                  doc.cantEdit = true;
                  return Pos(doc.first, 0);
                }
                flipped = true; newPos = pos; dir = -dir;
              }
            }
            curPos = newPos;
            continue search;
          }
        }
      }
      return curPos;
    }
  }

  // SELECTION DRAWING

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (primary === false && i == doc.sel.primIndex) continue;
      var range = doc.sel.ranges[i];
      var collapsed = range.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        drawSelectionCursor(cm, range, curFragment);
      if (!collapsed)
        drawSelectionRange(cm, range, selFragment);
    }
    return result;
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, range, output) {
    var pos = cursorCoords(cm, range.head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;

    function add(left, top, width, bottom) {
      if (top < 0) top = 0;
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
                               "px; height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
        var leftPos = coords(from, "left"), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, "right");
          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0) left = leftSide;
        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = leftSide;
          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen) right = rightSide;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < leftSide + 1) left = leftSide;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {start: start, end: end};
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(leftSide, leftEnd.bottom, null, rightStart.top);
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      display.blinker = setInterval(function() {
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    else if (cm.options.cursorBlinkRate < 0)
      display.cursorDiv.style.visibility = "hidden";
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) doc.frontier = doc.first;
    if (doc.frontier >= cm.display.viewTo) return;
    var end = +new Date + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changedLines = [];

    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
      if (doc.frontier >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var highlighted = highlightLine(cm, line, state, true);
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) line.styleClasses = newCls;
        else if (oldCls) line.styleClasses = null;
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        if (ischange) changedLines.push(doc.frontier);
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line.text, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changedLines.length) runInOp(cm, function() {
      for (var i = 0; i < changedLines.length; i++)
        regLineChange(cm, changedLines[i], "text");
    });
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
    if (!state) state = startState(doc.mode);
    else state = copyState(doc.mode, state);
    doc.iter(pos, n, function(line) {
      processLine(cm, line.text, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    if (precise) doc.frontier = pos;
    return state;
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop;}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
  function paddingH(display) {
    if (display.cachedPaddingH) return display.cachedPaddingH;
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
    return data;
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            heights.push((cur.bottom + next.top) / 2 - rect.top);
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      return {map: lineView.measure.map, cache: lineView.measure.cache};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineView.rest[i] == line)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineNo(lineView.rest[i]) > lineN)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      return cm.display.view[findViewIndex(cm, lineN)];
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      return ext;
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text)
      view = null;
    else if (view && view.changes)
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
    if (!view)
      view = updateExternalMeasurement(cm, line);

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    };
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) ch = -1;
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        prepared.rect = prepared.view.text.getBoundingClientRect();
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) prepared.cache[key] = found;
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom};
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map, ch, bias) {
    var node, start, end, collapse;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      var mStart = map[i], mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) collapse = "right";
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          collapse = bias;
        if (bias == "left" && start == 0)
          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          }
        if (bias == "right" && start == mEnd - mStart)
          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          }
        break;
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
          rect = node.parentNode.getBoundingClientRect();
        } else if (ie && cm.options.lineWrapping) {
          var rects = range(node, start, end).getClientRects();
          if (rects.length)
            rect = rects[bias == "right" ? rects.length - 1 : 0];
          else
            rect = nullRect;
        } else {
          rect = range(node, start, end).getBoundingClientRect() || nullRect;
        }
        if (rect.left || rect.right || start == 0) break;
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) collapse = bias = "right";
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      else
        rect = node.getBoundingClientRect();
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
      else
        rect = nullRect;
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    for (var i = 0; i < heights.length - 1; i++)
      if (mid < heights[i]) break;
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) result.bogus = true;
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result;
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      return rect;
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY};
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
        lineView.measure.caches[i] = {};
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      clearLineMeasurementCacheFor(cm.display.view[i]);
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }

  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"/null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
      var size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    if (context == "line") return rect;
    if (!context) context = "local";
    var yOff = heightAtLine(lineObj);
    if (context == "local") yOff += paddingTop(cm.display);
    else yOff -= cm.display.viewOffset;
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect;
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"/null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) m.left = m.right; else m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from) return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order) return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
    return val;
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0, pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height};
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, outside, xRel) {
    var pos = Pos(line, ch);
    pos.xRel = xRel;
    if (outside) pos.outside = true;
    return pos;
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0) x = 0;

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find(0, true);
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineN = lineNo(lineObj = mergedPos.to.line);
      else
        return found;
    }
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);

    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
      wrongLine = true;
      if (innerOff > sp.bottom) return sp.left - adjust;
      else if (innerOff < sp.top) return sp.left + adjust;
      else wrongLine = false;
      return sp.left;
    }

    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var xDiff = x - (ch == from ? fromX : toX);
        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var operationGroup = null;

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: null,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      id: ++nextOpId           // Unique ID
    };
    if (operationGroup) {
      operationGroup.ops.push(cm.curOp);
    } else {
      cm.curOp.ownsGroup = operationGroup = {
        ops: [cm.curOp],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        callbacks[i]();
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            op.cursorActivityHandlers[op.cursorActivityCalled++](op.cm);
      }
    } while (i < callbacks.length);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp, group = op.ownsGroup;
    if (!group) return;

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      for (var i = 0; i < group.ops.length; i++)
        group.ops[i].cm.curOp = null;
      endOperations(group);
    }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_finish(ops[i]);
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) findMaxLine(cm);

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) updateHeightsInViewport(cm);

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      op.preparedSelection = display.input.prepareSelection();
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      cm.display.maxLineChanged = false;
    }

    if (op.preparedSelection)
      cm.display.input.showSelection(op.preparedSelection);
    if (op.updatedDisplay)
      setDocumentHeight(cm, op.barMeasure);
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      updateScrollbars(cm, op.barMeasure);

    if (op.selectionChanged) restartBlink(cm);

    if (cm.state.focused && op.updateInput)
      cm.display.input.reset(op.typing);
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      display.wheelStartX = display.wheelStartY = null;

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
      display.scrollbars.setScrollTop(doc.scrollTop);
      display.scroller.scrollTop = doc.scrollTop;
    }
    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));
      display.scrollbars.setScrollLeft(doc.scrollLeft);
      display.scroller.scrollLeft = doc.scrollLeft;
      alignHorizontally(cm);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) for (var i = 0; i < hidden.length; ++i)
      if (!hidden[i].lines.length) signal(hidden[i], "hide");
    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

    if (display.wrapper.offsetHeight)
      doc.scrollTop = cm.display.scroller.scrollTop;

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      signal(cm, "changes", cm, op.changeObjs);
    if (op.update)
      op.update.finish();
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) return f();
    startOperation(cm);
    try { return f(); }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) return f.apply(cm, arguments);
      startOperation(cm);
      try { return f.apply(cm, arguments); }
      finally { endOperation(cm); }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) return f.apply(this, arguments);
      startOperation(this);
      try { return f.apply(this, arguments); }
      finally { endOperation(this); }
    };
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) return f.apply(this, arguments);
      startOperation(cm);
      try { return f.apply(this, arguments); }
      finally { endOperation(cm); }
    };
  }

  // VIEW TRACKING

  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) from = cm.doc.first;
    if (to == null) to = cm.doc.first + cm.doc.size;
    if (!lendiff) lendiff = 0;

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      display.updateLineNumbers = from;

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        resetView(cm);
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut = viewCuttingPoint(cm, from, from, -1);
      if (cut) {
        display.view = display.view.slice(0, cut.index);
        display.viewTo = cut.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        ext.lineN += lendiff;
      else if (from < ext.lineN + ext.size)
        display.externalMeasured = null;
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      display.externalMeasured = null;

    if (line < display.viewFrom || line >= display.viewTo) return;
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) return;
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) arr.push(type);
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) return null;
    n -= cm.display.viewFrom;
    if (n < 0) return null;
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) return i;
    }
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      return {index: index, lineN: newN};
    for (var i = 0, n = cm.display.viewFrom; i < index; i++)
      n += view[i].size;
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) return null;
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) return null;
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN};
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      else if (display.viewFrom < from)
        display.view = display.view.slice(findViewIndex(cm, from));
      display.viewFrom = from;
      if (display.viewTo < to)
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      else if (display.viewTo > to)
        display.view = display.view.slice(0, findViewIndex(cm, to));
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
    }
    return dirty;
  }

  // EVENT HANDLERS

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    else
      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    };
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) return false;
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1;
    }
    function farAway(touch, other) {
      if (other.left == null) return true;
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20;
    }
    on(d.scroller, "touchstart", function(e) {
      if (!isMouseLikeTouchEvent(e)) {
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function() {
      if (d.activeTouch) d.activeTouch.moved = true;
    });
    on(d.scroller, "touchend", function(e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          range = new Range(pos, pos);
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          range = cm.findWordAt(pos);
        else // Triple tap
          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    function drag_(e) {
      if (!signalDOMEvent(cm, e)) e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});
      on(d.scroller, "dragenter", drag_);
      on(d.scroller, "dragover", drag_);
      on(d.scroller, "drop", operation(cm, onDrop));
    }

    var inp = d.input.getField();
    on(inp, "keyup", function(e) { onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", bind(onFocus, cm));
    on(inp, "blur", bind(onBlur, cm));
  }

  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
      return;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  // MOUSE EVENTS

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        return true;
    }
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") return null;

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null; }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (display.activeTouch && display.input.supportsTouch() || signalDOMEvent(cm, e)) return;
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function(){display.scroller.draggable = true;}, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) return;
    var start = posFromMouse(cm, e);
    window.focus();

    switch (e_button(e)) {
    case 1:
      if (start)
        leftButtonDown(cm, e, start);
      else if (e_target(e) == display.scroller)
        e_preventDefault(e);
      break;
    case 2:
      if (webkit) cm.state.lastMiddleDown = +new Date;
      if (start) extendSelection(cm.doc, start);
      setTimeout(function() {display.input.focus();}, 20);
      e_preventDefault(e);
      break;
    case 3:
      if (captureRightClick) onContextMenu(cm, e);
      else delayBlurEvent(cm);
      break;
    }
  }

  var lastClick, lastDoubleClick;
  function leftButtonDown(cm, e, start) {
    if (ie) setTimeout(bind(ensureFocus, cm), 0);
    else ensureFocus(cm);

    var now = +new Date, type;
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
      type = "triple";
    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
      type = "double";
      lastDoubleClick = {time: now, pos: start};
    } else {
      type = "single";
      lastClick = {time: now, pos: start};
    }

    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) &&
        type == "single" && (contained = sel.contains(start)) > -1 &&
        !sel.ranges[contained].empty())
      leftButtonStartDrag(cm, e, start, modifier);
    else
      leftButtonSelect(cm, e, start, type, modifier);
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, e, start, modifier) {
    var display = cm.display;
    var dragEnd = operation(cm, function(e2) {
      if (webkit) display.scroller.draggable = false;
      cm.state.draggingText = false;
      off(document, "mouseup", dragEnd);
      off(display.scroller, "drop", dragEnd);
      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
        e_preventDefault(e2);
        if (!modifier)
          extendSelection(cm.doc, start);
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9)
          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);
        else
          display.input.focus();
      }
    });
    // Let the drag handler handle this.
    if (webkit) display.scroller.draggable = true;
    cm.state.draggingText = dragEnd;
    // IE's approach to draggable
    if (display.scroller.dragDrop) display.scroller.dragDrop();
    on(document, "mouseup", dragEnd);
    on(display.scroller, "drop", dragEnd);
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, e, start, type, addNew) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(e);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (addNew && !e.shiftKey) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        ourRange = ranges[ourIndex];
      else
        ourRange = new Range(start, start);
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (e.altKey) {
      type = "rect";
      if (!addNew) ourRange = new Range(start, start);
      start = posFromMouse(cm, e, true, true);
      ourIndex = -1;
    } else if (type == "double") {
      var word = cm.findWordAt(start);
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
      else
        ourRange = word;
    } else if (type == "triple") {
      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
      else
        ourRange = line;
    } else {
      ourRange = extendRange(doc, ourRange, start);
    }

    if (!addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0));
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) return;
      lastPos = pos;

      if (type == "rect") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          else if (text.length > leftPos)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
        }
        if (!ranges.length) ranges.push(new Range(start, start));
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var anchor = oldRange.anchor, head = pos;
        if (type != "single") {
          if (type == "double")
            var range = cm.findWordAt(pos);
          else
            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
          if (cmp(range.anchor, anchor) > 0) {
            head = range.head;
            anchor = minPos(oldRange.from(), range.anchor);
          } else {
            head = range.anchor;
            anchor = maxPos(oldRange.to(), range.head);
          }
        }
        var ranges = startSel.ranges.slice(0);
        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, type == "rect");
      if (!cur) return;
      if (cmp(cur, lastPos) != 0) {
        ensureFocus(cm);
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) setTimeout(operation(cm, function() {
          if (counter != curCount) return;
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50);
      }
    }

    function done(e) {
      counter = Infinity;
      e_preventDefault(e);
      display.input.focus();
      off(document, "mousemove", move);
      off(document, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function(e) {
      if (!e_button(e)) done(e);
      else extend(e);
    });
    var up = operation(cm, done);
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent, signalfn) {
    try { var mX = e.clientX, mY = e.clientY; }
    catch(e) { return false; }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
    if (prevent) e_preventDefault(e);

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalfn(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true, signalLater);
  }

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      return;
    e_preventDefault(e);
    if (ie) lastDrop = +new Date;
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm)) return;
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function(file, i) {
        var reader = new FileReader;
        reader.onload = operation(cm, function() {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos, text: splitLines(text.join("\n")), origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function() {cm.display.input.focus();}, 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          if (cm.state.draggingText && !(mac ? e.metaKey : e.ctrlKey))
            var selected = cm.listSelections();
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) for (var i = 0; i < selected.length; ++i)
            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
          cm.replaceSelection(text, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

    e.dataTransfer.setData("Text", cm.getSelection());

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) img.parentNode.removeChild(img);
    }
  }

  // SCROLL EVENTS

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplaySimple(cm, {top: val});
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (gecko) updateDisplaySimple(cm);
    startWorker(cm, 100);
  }
  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    cm.display.scrollbars.setScrollLeft(val);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  var wheelEventDelta = function(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;
    return {x: dx, y: dy};
  };
  CodeMirror.wheelEventPixels = function(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  };

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||
          dy && scroll.scrollHeight > scroll.clientHeight)) return;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // KEY EVENTS

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (isReadOnly(cm)) cm.state.suppressEdits = true;
      if (dropShift) cm.display.shift = false;
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) return result;
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm);
  }

  var stopSeq = new Delayed;
  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) return "handled";
      stopSeq.set(50, function() {
        if (cm.state.keySeq == seq) {
          cm.state.keySeq = null;
          cm.display.input.reset();
        }
      });
      name = seq + " " + name;
    }
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      cm.state.keySeq = name;
    if (result == "handled")
      signalLater(cm, "keyHandled", cm, name, e);

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    if (seq && !result && /\'$/.test(name)) {
      e_preventDefault(e);
      return true;
    }
    return !!result;
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) return false;

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function(b) {return doHandleBinding(cm, b, true);})
          || dispatchKey(cm, name, e, function(b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 return doHandleBinding(cm, b);
             });
    } else {
      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e,
                       function(b) { return doHandleBinding(cm, b, true); });
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    ensureFocus(cm);
    if (signalDOMEvent(cm, e)) return;
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("", null, "cut");
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      showCrossHair(cm);
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) this.doc.sel.shift = false;
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (handleCharBinding(cm, e, ch)) return;
    cm.display.input.onKeyPress(e);
  }

  // FOCUS/BLUR EVENTS

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function() {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        onBlur(cm);
      }
    }, 100);
  }

  function onFocus(cm) {
    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;

    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.delayingBlurEvent) return;

    if (cm.state.focused) {
      signal(cm, "blur", cm);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;
    cm.display.input.onContextMenu(e);
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) return false;
    return gutterEvent(cm, e, "gutterContextMenu", false, signal);
  }

  // UPDATING

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  var changeEnd = CodeMirror.changeEnd = function(change) {
    if (!change.text) return change.to;
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  };

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) return pos;
    if (cmp(pos, change.to) <= 0) return changeEnd(change);

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    else
      return Pos(nw.line + (pos.line - old.line), pos.ch);
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() { this.canceled = true; }
    };
    if (update) obj.update = function(from, to, text, origin) {
      if (from) this.from = clipPos(doc, from);
      if (to) this.to = clipPos(doc, to);
      if (text) this.text = text;
      if (origin !== undefined) this.origin = origin;
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits) return;

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    for (var i = 0; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        break;
    }
    if (i == source.length) return;
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return;
        }
        selAfter = event;
      }
      else break;
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return;
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) return;
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function(range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
                       Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        regLineChange(doc.cm, l, "gutter");
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) selAfter = computeSelAfterChange(doc, change);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
    else updateDoc(doc, change, spans);
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      signalCursorActivity(cm);

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      regChange(cm);
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      regLineChange(cm, from.line, "text");
    else
      regChange(cm, from.line, to.line + 1, lendiff);

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) signalLater(cm, "change", cm, obj);
      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, coords) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) return;

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " +
                           coords.left + "px; width: 2px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) margin = 0;
    for (var limit = 0; limit < 5; limit++) {
      var changed = false, coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
                                         Math.min(coords.top, endCoords.top) - margin,
                                         Math.max(coords.left, endCoords.left),
                                         Math.max(coords.bottom, endCoords.bottom) + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) break;
    }
    return coords;
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0) y1 = 0;
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (y2 - y1 > screen) y2 = y1 + screen;
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) result.scrollTop = newTop;
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = x2 - x1 > screenw;
    if (tooWide) x2 = x1 + screenw;
    if (x1 < 10)
      result.scrollLeft = 0;
    else if (x1 < screenleft)
      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
    else if (x2 > screenw + screenleft - 3)
      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollPos(cm, left, top) {
    if (left != null || top != null) resolveScrollToPos(cm);
    if (left != null)
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
    if (top != null)
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor(), from = cur, to = cur;
    if (!cm.options.lineWrapping) {
      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
      to = Pos(cur.line, cur.ch + 1);
    }
    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
                                    Math.min(from.top, to.top) - range.margin,
                                    Math.max(from.right, to.right),
                                    Math.max(from.bottom, to.bottom) + range.margin);
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
    }
  }

  // API UTILITIES

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) how = "add";
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) how = "prev";
      else state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) line.stateAfter = null;
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i, new Range(pos, pos));
          break;
        }
      }
    }
    line.stateAfter = null;
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);
    return line;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function() {
      for (var i = kill.length - 1; i >= 0; i--)
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      ensureCursorVisible(cm);
    });
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return (possible = false);
      } else ch = next;
      return true;
    }

    if (unit == "char") moveOnce();
    else if (unit == "column") moveOnce(true);
    else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) break;
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) type = "s";
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce();}
          break;
        }

        if (type) sawType = type;
        if (dir > 0 && !moveOnce(!first)) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), origDir, true);
    if (!possible) result.hitSide = true;
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  // EDITOR METHODS

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); this.display.input.focus();},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || maps[i].name == map) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: methodOp(function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: methodOp(function(how) {
      var ranges = this.doc.sel.ranges, end = -1;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (!range.empty()) {
          var from = range.from(), to = range.to();
          var start = Math.max(end, from.line);
          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (var j = start; j < end; ++j)
            indentLine(this, j, how);
          var newRanges = this.doc.sel.ranges;
          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
        } else if (range.head.line > end) {
          indentLine(this, range.head.line, how, true);
          end = range.head.line;
          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
        }
      }
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      return takeToken(this, pos, precise);
    },

    getLineTokens: function(line, precise) {
      return takeToken(this, Pos(line), precise, true);
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      var type;
      if (ch == 0) type = styles[2];
      else for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
        else { type = styles[mid * 2 + 2]; break; }
      }
      var cut = type ? type.indexOf("cm-overlay ") : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },

    getHelper: function(pos, type) {
      return this.getHelpers(pos, type)[0];
    },

    getHelpers: function(pos, type) {
      var found = [];
      if (!helpers.hasOwnProperty(type)) return found;
      var help = helpers[type], mode = this.getModeAt(pos);
      if (typeof mode[type] == "string") {
        if (help[mode[type]]) found.push(help[mode[type]]);
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val) found.push(val);
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (var i = 0; i < help._global.length; i++) {
        var cur = help._global[i];
        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
          found.push(cur.val);
      }
      return found;
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1, precise);
    },

    cursorCoords: function(start, mode) {
      var pos, range = this.doc.sel.primary();
      if (start == null) pos = range.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? range.from() : range.to();
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode) {
      var end = false, last = this.doc.first + this.doc.size - 1;
      if (line < this.doc.first) line = this.doc.first;
      else if (line > last) { line = last; end = true; }
      var lineObj = getLine(this.doc, line);
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
        (end ? this.doc.height - heightAtLine(lineObj) : 0);
    },

    defaultTextHeight: function() { return textHeight(this.display); },
    defaultCharWidth: function() { return charWidth(this.display); },

    setGutterMarker: methodOp(function(line, gutterID, value) {
      return changeLine(this.doc, line, "gutter", function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: methodOp(function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regLineChange(cm, i, "gutter");
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      node.setAttribute("cm-ignore-events", "true");
      this.display.input.setUneditable(node);
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: onKeyUp,

    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        return commands[cmd](this);
    },

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: methodOp(function(dir, unit) {
      var cm = this;
      cm.extendSelectionsBy(function(range) {
        if (cm.display.shift || cm.doc.extend || range.empty())
          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
        else
          return dir < 0 ? range.from() : range.to();
      }, sel_move);
    }),

    deleteH: methodOp(function(dir, unit) {
      var sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        doc.replaceSelection("", null, "+delete");
      else
        deleteNearSelection(this, function(range) {
          var other = findPosH(doc, range.head, dir, unit, false);
          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
        });
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: methodOp(function(dir, unit) {
      var cm = this, doc = this.doc, goals = [];
      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function(range) {
        if (collapse)
          return dir < 0 ? range.from() : range.to();
        var headPos = cursorCoords(cm, range.head, "div");
        if (range.goalColumn != null) headPos.left = range.goalColumn;
        goals.push(headPos.left);
        var pos = findPosV(cm, headPos, dir, unit);
        if (unit == "page" && range == doc.sel.primary())
          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
        return pos;
      }, sel_move);
      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
        doc.sel.ranges[i].goalColumn = goals[i];
    }),

    // Find the word at the given position (as returned by coordsChar).
    findWordAt: function(pos) {
      var doc = this.doc, line = getLine(doc, pos.line).text;
      var start = pos.ch, end = pos.ch;
      if (line) {
        var helper = this.getHelper(pos, "wordChars");
        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
        var startChar = line.charAt(start);
        var check = isWordChar(startChar, helper)
          ? function(ch) { return isWordChar(ch, helper); }
          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
          : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
        while (start > 0 && check(line.charAt(start - 1))) --start;
        while (end < line.length && check(line.charAt(end))) ++end;
      }
      return new Range(Pos(pos.line, start), Pos(pos.line, end));
    },

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite)
        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
      else
        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

      signal(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function() { return this.display.input.getField() == activeElt(); },

    scrollTo: methodOp(function(x, y) {
      if (x != null || y != null) resolveScrollToPos(this);
      if (x != null) this.curOp.scrollLeft = x;
      if (y != null) this.curOp.scrollTop = y;
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};
    },

    scrollIntoView: methodOp(function(range, margin) {
      if (range == null) {
        range = {from: this.doc.sel.primary().head, to: null};
        if (margin == null) margin = this.options.cursorScrollMargin;
      } else if (typeof range == "number") {
        range = {from: Pos(range, 0), to: null};
      } else if (range.from == null) {
        range = {from: range, to: null};
      }
      if (!range.to) range.to = range.from;
      range.margin = margin || 0;

      if (range.from.line != null) {
        resolveScrollToPos(this);
        this.curOp.scrollToPos = range;
      } else {
        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
                                      Math.min(range.from.top, range.to.top) - range.margin,
                                      Math.max(range.from.right, range.to.right),
                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);
        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
      }
    }),

    setSize: methodOp(function(width, height) {
      var cm = this;
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) cm.display.wrapper.style.width = interpret(width);
      if (height != null) cm.display.wrapper.style.height = interpret(height);
      if (cm.options.lineWrapping) clearLineMeasurementCache(this);
      var lineNo = cm.display.viewFrom;
      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)
          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }
        ++lineNo;
      });
      cm.curOp.forceUpdate = true;
      signal(cm, "refresh", this);
    }),

    operation: function(f){return runInOp(this, f);},

    refresh: methodOp(function() {
      var oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
        estimateLineHeights(this);
      signal(this, "refresh", this);
    }),

    swapDoc: methodOp(function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      this.display.input.reset();
      this.scrollTo(doc.scrollLeft, doc.scrollTop);
      this.curOp.forceScroll = true;
      signalLater(this, "swapDoc", this, old);
      return old;
    }),

    getInputField: function(){return this.display.input.getField();},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };
  eventMixin(CodeMirror);

  // OPTION DEFAULTS

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};
  // Functions to run when options are changed.
  var optionHandlers = CodeMirror.optionHandlers = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  // Passed to option handlers when there is no old value.
  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("specialChars", /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
    if (old != CodeMirror.Init) cm.refresh();
  });
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
  option("electricChars", true);
  option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
    throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
  }, true);
  option("rtlMoveVisually", !windows);
  option("wholeLineUpdateBefore", true);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", function(cm, val, old) {
    var next = getKeyMap(val);
    var prev = old != CodeMirror.Init && getKeyMap(old);
    if (prev && prev.detach) prev.detach(cm, next);
    if (next.attach) next.attach(cm, prev || null);
  });
  option("extraKeys", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, function(cm) {updateScrollbars(cm);}, true);
  option("scrollbarStyle", "native", function(cm) {
    initScrollbars(cm);
    updateScrollbars(cm);
    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
  }, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("resetSelectionOnContextMenu", true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {
      onBlur(cm);
      cm.display.input.blur();
      cm.display.disabled = true;
    } else {
      cm.display.disabled = false;
      if (!val) cm.display.input.reset();
    }
  });
  option("disableInput", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);
  option("dragDrop", true);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1, updateSelection, true);
  option("singleCursorHeightPerLine", true, updateSelection, true);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true, resetModeState, true);
  option("addModeClass", false, resetModeState, true);
  option("pollInterval", 100);
  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
  option("historyEventDelay", 1250);
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
  option("maxHighlightLength", 10000, resetModeState, true);
  option("moveInputWithCursor", true, function(cm, val) {
    if (!val) cm.display.input.resetPosition();
  });

  option("tabindex", null, function(cm, val) {
    cm.display.input.getField().tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2)
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") found = {name: found};
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode("application/xml");
    }
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  CodeMirror.getMode = function(options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) modeObj.helperType = spec.helperType;
    if (spec.modeProps) for (var prop in spec.modeProps)
      modeObj[prop] = spec.modeProps[prop];

    return modeObj;
  };

  // Minimal default mode.
  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because nested
  // modes need to do this for their inner modes.

  var copyState = CodeMirror.copyState = function(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  };

  var startState = CodeMirror.startState = function(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  };

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      if (!info || info.mode == mode) break;
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
    singleSelection: function(cm) {
      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine())
            return {from: range.head, to: Pos(range.head.line + 1, 0)};
          else
            return {from: range.head, to: Pos(range.head.line, len)};
        } else {
          return {from: range.from(), to: range.to()};
        }
      });
    },
    deleteLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0),
                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
      });
    },
    delLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0), to: range.from()};
      });
    },
    delWrappedLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({left: 0, top: top}, "div");
        return {from: leftPos, to: range.from()};
      });
    },
    delWrappedLineRight: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
        return {from: range.from(), to: rightPos };
      });
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    undoSelection: function(cm) {cm.undoSelection();},
    redoSelection: function(cm) {cm.redoSelection();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },
                            {origin: "+move", bias: 1});
    },
    goLineStartSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        return lineStartSmart(cm, range.head);
      }, {origin: "+move", bias: 1});
    },
    goLineEnd: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },
                            {origin: "+move", bias: -1});
    },
    goLineRight: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      }, sel_move);
    },
    goLineLeft: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: 0, top: top}, "div");
      }, sel_move);
    },
    goLineLeftSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({left: 0, top: top}, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
        return pos;
      }, sel_move);
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goGroupRight: function(cm) {cm.moveH(1, "group");},
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t");},
    insertSoftTab: function(cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.execCommand("insertTab");
    },
    transposeChars: function(cm) {
      runInOp(cm, function() {
        var ranges = cm.listSelections(), newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                              Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev)
                cm.replaceRange(line.charAt(0) + "\n" + prev.charAt(prev.length - 1),
                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function(cm) {
      runInOp(cm, function() {
        var len = cm.listSelections().length;
        for (var i = 0; i < len; i++) {
          var range = cm.listSelections()[i];
          cm.replaceRange("\n", range.anchor, range.head, "+input");
          cm.indentLine(range.from().line + 1, null, true);
          ensureCursorVisible(cm);
        }
      });
    },
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };


  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    fallthrough: "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;
      else if (/^a(lt)?$/i.test(mod)) alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
      else if (/^s(hift)$/i.test(mod)) shift = true;
      else throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt) name = "Alt-" + name;
    if (ctrl) name = "Ctrl-" + name;
    if (cmd) name = "Cmd-" + name;
    if (shift) name = "Shift-" + name;
    return name;
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  CodeMirror.normalizeKeyMap = function(keymap) {
    var copy = {};
    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
      if (value == "...") { delete keymap[keyname]; continue; }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val, name;
        if (i == keys.length - 1) {
          name = keyname;
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) copy[name] = val;
        else if (prev != val) throw new Error("Inconsistent bindings for " + name);
      }
      delete keymap[keyname];
    }
    for (var prop in copy) keymap[prop] = copy[prop];
    return keymap;
  };

  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) return "nothing";
    if (found === "...") return "multi";
    if (found != null && handle(found)) return "handled";

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
        return lookupKey(key, map.fallthrough, handle, context);
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) return result;
      }
    }
  };

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  var isModifierKey = CodeMirror.isModifierKey = function(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  };

  // Look up the name of a key as indicated by an event object.
  var keyName = CodeMirror.keyName = function(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) return false;
    var base = keyNames[event.keyCode], name = base;
    if (name == null || event.altGraphKey) return false;
    if (event.altKey && base != "Alt") name = "Alt-" + name;
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") name = "Ctrl-" + name;
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") name = "Cmd-" + name;
    if (!noShift && event.shiftKey && base != "Shift") name = "Shift-" + name;
    return name;
  };

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  }

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      options.tabindex = textarea.tabIndex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function(cm) {
      cm.save = save;
      cm.getTextArea = function() { return textarea; };
      cm.toTextArea = function() {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (typeof textarea.form.submit == "function")
            textarea.form.submit = realSubmit;
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = CodeMirror.StringStream = function(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
  };

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == this.lineStart;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function() {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);},
    hideFirstChars: function(n, inner) {
      this.lineStart += n;
      try { return inner(); }
      finally { this.lineStart -= n; }
    }
  };

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  var nextMarkerId = 0;

  var TextMarker = CodeMirror.TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };
  eventMixin(TextMarker);

  // Clear the marker.
  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) signalLater(this, "clear", found.from, found.to);
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
      else if (cm) {
        if (span.to != null) max = lineNo(line);
        if (span.from != null) min = lineNo(line);
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(this.lines[i]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm.doc);
    }
    if (cm) signalLater(cm, "markerCleared", cm, this);
    if (withOp) endOperation(cm);
    if (this.parent) this.parent.clear();
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function(side, lineObj) {
    if (side == null && this.type == "bookmark") side = 1;
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) return from;
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) return to;
      }
    }
    return from && {from: from, to: to};
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function() {
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) return;
    runInOp(cm, function() {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          updateLineHeight(line, line.height + dHeight);
      }
    });
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) copyObj(options, marker, false);
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      return marker;
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) marker.widgetNode.setAttribute("cm-ignore-events", "true");
      if (options.insertLeft) marker.widgetNode.insertLeft = true;
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      sawCollapsedSpans = true;
    }

    if (marker.addToHistory)
      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        updateMaxLine = true;
      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
      if (marker.atomic) reCheckSelection(cm.doc);
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      markers[i].parent = this;
  };
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function(side, lineObj) {
    return this.primary.find(side, lineObj);
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function(doc) {
      if (widget) options.widgetNode = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
                         function(m) { return m.parent; });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], linked = [marker.primary.doc];;
      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    }
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) return null;
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) first = clearEmptySpans(first);
    if (last && last != first) last = clearEmptySpans(last);

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        spans.splice(i--, 1);
    }
    if (!spans.length) return null;
    return spans;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          newParts.push({from: p.from, to: m.from});
        if (dto > 0 || !mk.inclusiveRight && !dto)
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) return lenDiff;
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) return -fromCmp;
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) return toCmp;
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) continue;
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||
          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))
        return true;
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = merged.find(-1, true).line;
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) return lineN;
    return lineNo(vis);
  }
  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) return lineN;
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) return lineN;
    while (merged = collapsedSpanAtEnd(line))
      line = merged.find(1, true).line;
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.marker.widgetNode) continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  // LINE WIDGETS

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {
    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.doc = doc;
    this.node = node;
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      addToScrollPos(cm, null, diff);
  }

  LineWidget.prototype.clear = function() {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) line.widgets = null;
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) runInOp(cm, function() {
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, "widget");
    });
  };
  LineWidget.prototype.changed = function() {
    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    updateLineHeight(line, line.height + diff);
    if (cm) runInOp(cm, function() {
      cm.curOp.forceUpdate = true;
      adjustScrollWhenAboveVisible(cm, line, diff);
    });
  };

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    var cm = widget.doc.cm;
    if (!cm) return 0;
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      if (widget.noHScroll)
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.offsetHeight;
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(doc, handle, "widget", function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) widgets.push(widget);
      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) addToScrollPos(cm, null, widget.height);
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  eventMixin(Line);
  Line.prototype.lineNo = function() { return lineNo(this); };

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  function extractLineClasses(type, output) {
    if (type) for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) break;
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        output[prop] = lineClass[2];
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        output[prop] += " " + lineClass[2];
    }
    return type;
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) return mode.blankLine(state);
    if (!mode.innerMode) return;
    var inner = CodeMirror.innerMode(mode, state);
    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) return style;
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    function getObj(copy) {
      return {start: stream.start, end: stream.pos,
              string: stream.current(),
              type: style || null,
              state: copy ? copyState(doc.mode, state) : state};
    }

    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize), tokens;
    if (asArray) tokens = [];
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, state);
      if (asArray) tokens.push(getObj(true));
    }
    return asArray ? tokens : getObj();
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) processLine(cm, text, state, stream.pos);
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) style = "m-" + (style ? mName + " " + style : mName);
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 50000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444 characters
      var pos = Math.min(stream.pos, curStart + 50000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, state, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
      st.push(end, style);
    }, lineClasses, forceToEnd);

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i+1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, "cm-overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
          }
        }
      }, lineClasses);
    }

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
      line.styles = result.styles;
      if (result.classes) line.styleClasses = result.classes;
      else if (line.styleClasses) line.styleClasses = null;
      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;
    }
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, state, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize);
    stream.start = stream.pos = startAt || 0;
    if (text == "") callBlankLine(mode, state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      readToken(mode, stream, state);
      stream.start = stream.pos;
    }
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) return null;
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: elt("pre", [content]), content: content,
                   col: 0, pos: 0, cm: cm,
                   splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        if (line.styleClasses.textClass)
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit && /\bcm-tab\b/.test(builder.content.lastChild.className))
      builder.content.className = "cm-tab-wrap-hack";

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");

    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
    if (!text) return;
    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    if (!special.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) mustWrap = true;
      builder.pos += text.length;
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt.setAttribute("role", "presentation");
          txt.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else {
          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
          txt.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt);
        builder.pos++;
      }
    }
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      var token = elt("span", [content], fullStyle, css);
      if (title) token.title = title;
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }

  function splitSpaces(old) {
    var out = " ";
    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
    out += " ";
    return out;
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function(builder, text, style, startStyle, endStyle, title, css) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        for (var i = 0; i < order.length; i++) {
          var part = order[i];
          if (part.to > start && part.from <= start) break;
        }
        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        widget = builder.content.appendChild(document.createElement("span"));
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
      return;
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [];
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }
            if (m.className) spanStyle += " " + m.className;
            if (m.css) css = m.css;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
            if (m.title && !title) title = m.title;
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) foundBookmarks.push(m);
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) return;
        }
        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)
          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      for (var i = start, result = []; i < end; ++i)
        result.push(new Line(text[i], spansFor(i), estimateHeight));
      return result;
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added = linesFor(1, text.length - 1);
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added = linesFor(1, text.length - 1);
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, height = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
    },
    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;

    if (typeof text == "string") text = splitLines(text);
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: splitLines(code), origin: "setValue", full: true}, true);
      setSelection(this, simpleSelection(top));
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") line = getLine(this, line);
      return visualLine(line);
    },

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") pos = range.head;
      else if (start == "anchor") pos = range.anchor;
      else if (start == "end" || start == "to" || start === false) pos = range.to();
      else pos = range.from();
      return pos;
    },
    listSelections: function() { return this.sel.ranges; },
    somethingSelected: function() {return this.sel.somethingSelected();},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads, options));
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      extendSelections(this, map(this.sel.ranges, f), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) return;
      for (var i = 0, out = []; i < ranges.length; i++)
        out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head));
      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) return lines;
      else return lines.join(lineSep || "\n");
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) sel = sel.join(lineSep || "\n");
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        dup[i] = code;
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i = changes.length - 1; i >= 0; i--)
        makeChange(this, changes[i]);
      if (newSel) setSelectionReplaceHistory(this, newSel);
      else if (this.cm) ensureCursorVisible(this.cm);
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend;},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
      return {undo: done, redo: undone};
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (classTest(cls).test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var found = cur.match(classTest(cls));
          if (!found) return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function(line) {
        var spans = line.markedSpans;
        if (spans) for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(lineNo == from.line && from.ch > span.to ||
                span.from == null && lineNo != from.line||
                lineNo == to.line && span.from > to.ch) &&
              (!filter || filter(span.marker)))
            found.push(span.marker.parent || span.marker);
        }
        ++lineNo;
      });
      return found;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first;
      this.iter(function(line) {
        var sz = line.text.length + 1;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;}
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  eventMixin(Doc);

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) findMaxLine(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
    for (var chunk = doc; !chunk.lines;) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) for (var n = line; n; n = n.parent) n.height += diff;
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0; i < chunk.children.length; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }


  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) array.pop();
      else break;
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, ore are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        pushSelectionToHistory(doc.sel, hist.done);
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) hist.done.shift();
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) signal(doc, "historyAdded");
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      hist.done[hist.done.length - 1] = sel;
    else
      pushSelectionToHistory(sel, hist.done);

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      clearSelectionEvents(hist.undone);
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      dest.push(sel);
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT UTILITIES

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  };
  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  };
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) b = 1;
      else if (e.button & 2) b = 3;
      else if (e.button & 4) b = 2;
    }
    if (mac && e.ctrlKey && b == 1) b = 3;
    return b;
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var on = CodeMirror.on = function(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent("on" + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  };

  var off = CodeMirror.off = function(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent("on" + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr) return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) { arr.splice(i, 1); break; }
    }
  };

  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
  };

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    function bnd(f) {return function(){f.apply(null, args);};};
    for (var i = 0; i < arr.length; ++i)
      list.push(bnd(arr[i]));
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) return;
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
      set.push(arr[i]);
  }

  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // MISC UTILITIES

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  function Delayed() {this.id = null;}
  Delayed.prototype.set = function(ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        return n + (end - i);
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  };

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) nextTab = string.length;
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        return pos + Math.min(skipped, goal - col);
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) return pos;
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + " ");
    return spaceStrs[n];
  }

  function lst(arr) { return arr[arr.length-1]; }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
  else if (ie) // Suppress mysterious IE10 errors
    selectInput = function(node) { try { node.select(); } catch(_e) {} };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      if (array[i] == elt) return i;
    return -1;
  }
  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
    return out;
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) copyObj(props, inst);
    return inst;
  };

  function copyObj(obj, target, overwrite) {
    if (!target) target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        target[prop] = obj[prop];
    return target;
  }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args);};
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  };
  function isWordChar(ch, helper) {
    if (!helper) return isWordCharBasic(ch);
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) return true;
    return helper.test(ch);
  }

  function isEmpty(obj) {
    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
    return true;
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }

  // DOM UTILITIES

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == "string") e.appendChild(document.createTextNode(content));
    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  var range;
  if (document.createRange) range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r;
  };
  else range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r; }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r;
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  var contains = CodeMirror.contains = function(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      child = child.parentNode;
    if (parent.contains)
      return parent.contains(child);
    do {
      if (child.nodeType == 11) child = child.host;
      if (child == parent) return true;
    } while (child = child.parentNode);
  };

  function activeElt() { return document.activeElement; }
  // Older versions of IE throws unspecified error when touching
  // document.activeElement in some cases (during loading, in iframe)
  if (ie && ie_version < 11) activeElt = function() {
    try { return document.activeElement; }
    catch(e) { return document.body; }
  };

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*"); }
  var rmClass = CodeMirror.rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };
  var addClass = CodeMirror.addClass = function(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) node.className += (current ? " " : "") + cls;
  };
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
    return b;
  }

  // WINDOW-WIDE EVENTS

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.body.getElementsByClassName) return;
    var byClass = document.body.getElementsByClassName("CodeMirror");
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) f(cm);
    }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) return;
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function() {
      if (resizeTimer == null) resizeTimer = setTimeout(function() {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100);
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function() {
      forEachCodeMirror(onBlur);
    });
  }

  // FEATURE DETECTION

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) return false;
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node;
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) return badBidiRects;
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    return badBidiRects = (r1.right - r0.right < 3);
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLines = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) nl = string.length;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string){return string.split(/\r\n?|\n/);};

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = (function() {
    var e = elt("div");
    if ("oncopy" in e) return true;
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) return badZoomedRects;
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  }

  // KEY NAMES

  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
                  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete",
                  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
                  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
                  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"};
  CodeMirror.keyNames = keyNames;
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) return f(from, to, "ltr");
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
        found = true;
      }
    }
    if (!found) f(from, to, "ltr");
  }

  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) return line.text.length;
    return bidiRight(lst(order));
  }

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line = getLine(cm.doc, lineN);
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      lineN = null;
    }
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN == null ? lineNo(line) : lineN, ch);
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS);
    }
    return start;
  }

  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir) return true;
    if (b == linedir) return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    bidiOther = null;
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) return i;
      if ((cur.from == pos || cur.to == pos)) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          if (cur.from != cur.to) bidiOther = found;
          return i;
        } else {
          if (cur.from != cur.to) bidiOther = i;
          return found;
        }
      }
    }
    return found;
  }

  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit) return pos + dir;
    do pos += dir;
    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
    return pos;
  }

  // This is needed in order to move 'visually' through bi-directional
  // text -- i.e., pressing left should make the cursor go left, even
  // when in RTL text. The tricky part is the 'jumps', where RTL and
  // LTR text touch each other. This often requires the cursor offset
  // to move more than one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

    for (;;) {
      if (target > part.from && target < part.to) return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos) return target;
        part = bidi[pos += dir];
        return (dir > 0) == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part) return null;
        if ((dir > 0) == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6ff
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
    function charType(code) {
      if (code <= 0xf7) return lowTypes.charAt(code);
      else if (0x590 <= code && code <= 0x5f4) return "R";
      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
      else if (0x6ee <= code && code <= 0x8ac) return "r";
      else if (0x2000 <= code && code <= 0x200b) return "w";
      else if (code == 0x200c) return "b";
      else return "L";
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str) {
      if (!bidiRE.test(str)) return false;
      var len = str.length, types = [];
      for (var i = 0, type; i < len; ++i)
        types.push(type = charType(str.charCodeAt(i)));

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i = 0, prev = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "m") types[i] = prev;
        else prev = type;
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "1" && cur == "r") types[i] = "n";
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
        var type = types[i];
        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
        else if (type == "," && prev == types[i+1] &&
                 (prev == "1" || prev == "n")) types[i] = prev;
        prev = type;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type == ",") types[i] = "N";
        else if (type == "%") {
          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (cur == "L" && type == "1") types[i] = "L";
        else if (isStrong.test(type)) cur = type;
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i = 0; i < len; ++i) {
        if (isNeutral.test(types[i])) {
          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
          var before = (i ? types[i-1] : outerType) == "L";
          var after = (end < len ? types[end] : outerType) == "L";
          var replace = before || after ? "L" : "R";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i = 0; i < len;) {
        if (countsAsLeft.test(types[i])) {
          var start = i;
          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
          order.push(new BidiSpan(0, start, i));
        } else {
          var pos = i, at = order.length;
          for (++i; i < len && types[i] != "L"; ++i) {}
          for (var j = pos; j < i;) {
            if (countsAsNum.test(types[j])) {
              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
              var nstart = j;
              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j));
              pos = j;
            } else ++j;
          }
          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift(new BidiSpan(0, 0, m[0].length));
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push(new BidiSpan(0, len - m[0].length, len));
      }
      if (order[0].level != lst(order).level)
        order.push(new BidiSpan(order[0].level, len, len));

      return order;
    };
  })();

  // THE END

  CodeMirror.version = "5.1.0";

  return CodeMirror;
});

if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old};
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("haskell", function(_config, modeConfig) {

  function switchState(source, setState, f) {
    setState(f);
    return f(source, setState);
  }

  // These should all be Unicode extended, as per the Haskell 2010 report
  var smallRE = /[a-z_]/;
  var largeRE = /[A-Z]/;
  var digitRE = /\d/;
  var hexitRE = /[0-9A-Fa-f]/;
  var octitRE = /[0-7]/;
  var idRE = /[a-z_A-Z0-9'\xa1-\uffff]/;
  var symbolRE = /[-!#$%&*+.\/<=>?@\\^|~:]/;
  var specialRE = /[(),;[\]`{}]/;
  var whiteCharRE = /[ \t\v\f]/; // newlines are handled in tokenizer

  function normal(source, setState) {
    if (source.eatWhile(whiteCharRE)) {
      return null;
    }

    var ch = source.next();
    if (specialRE.test(ch)) {
      if (ch == '{' && source.eat('-')) {
        var t = "comment";
        if (source.eat('#')) {
          t = "meta";
        }
        return switchState(source, setState, ncomment(t, 1));
      }
      return null;
    }

    if (ch == '\'') {
      if (source.eat('\\')) {
        source.next();  // should handle other escapes here
      }
      else {
        source.next();
      }
      if (source.eat('\'')) {
        return "string";
      }
      return "error";
    }

    if (ch == '"') {
      return switchState(source, setState, stringLiteral);
    }

    if (largeRE.test(ch)) {
      source.eatWhile(idRE);
      if (source.eat('.')) {
        return "qualifier";
      }
      return "variable-2";
    }

    if (smallRE.test(ch)) {
      source.eatWhile(idRE);
      return "variable";
    }

    if (digitRE.test(ch)) {
      if (ch == '0') {
        if (source.eat(/[xX]/)) {
          source.eatWhile(hexitRE); // should require at least 1
          return "integer";
        }
        if (source.eat(/[oO]/)) {
          source.eatWhile(octitRE); // should require at least 1
          return "number";
        }
      }
      source.eatWhile(digitRE);
      var t = "number";
      if (source.match(/^\.\d+/)) {
        t = "number";
      }
      if (source.eat(/[eE]/)) {
        t = "number";
        source.eat(/[-+]/);
        source.eatWhile(digitRE); // should require at least 1
      }
      return t;
    }

    if (ch == "." && source.eat("."))
      return "keyword";

    if (symbolRE.test(ch)) {
      if (ch == '-' && source.eat(/-/)) {
        source.eatWhile(/-/);
        if (!source.eat(symbolRE)) {
          source.skipToEnd();
          return "comment";
        }
      }
      var t = "variable";
      if (ch == ':') {
        t = "variable-2";
      }
      source.eatWhile(symbolRE);
      return t;
    }

    return "error";
  }

  function ncomment(type, nest) {
    if (nest == 0) {
      return normal;
    }
    return function(source, setState) {
      var currNest = nest;
      while (!source.eol()) {
        var ch = source.next();
        if (ch == '{' && source.eat('-')) {
          ++currNest;
        }
        else if (ch == '-' && source.eat('}')) {
          --currNest;
          if (currNest == 0) {
            setState(normal);
            return type;
          }
        }
      }
      setState(ncomment(type, currNest));
      return type;
    };
  }

  function stringLiteral(source, setState) {
    while (!source.eol()) {
      var ch = source.next();
      if (ch == '"') {
        setState(normal);
        return "string";
      }
      if (ch == '\\') {
        if (source.eol() || source.eat(whiteCharRE)) {
          setState(stringGap);
          return "string";
        }
        if (source.eat('&')) {
        }
        else {
          source.next(); // should handle other escapes here
        }
      }
    }
    setState(normal);
    return "error";
  }

  function stringGap(source, setState) {
    if (source.eat('\\')) {
      return switchState(source, setState, stringLiteral);
    }
    source.next();
    setState(normal);
    return "error";
  }


  var wellKnownWords = (function() {
    var wkw = {};
    function setType(t) {
      return function () {
        for (var i = 0; i < arguments.length; i++)
          wkw[arguments[i]] = t;
      };
    }

    setType("keyword")(
      "case", "class", "data", "default", "deriving", "do", "else", "foreign",
      "if", "import", "in", "infix", "infixl", "infixr", "instance", "let",
      "module", "newtype", "of", "then", "type", "where", "_");

    setType("keyword")(
      "\.\.", ":", "::", "=", "\\", "\"", "<-", "->", "@", "~", "=>");

    setType("builtin")(
      "!!", "$!", "$", "&&", "+", "++", "-", ".", "/", "/=", "<", "<=", "=<<",
      "==", ">", ">=", ">>", ">>=", "^", "^^", "||", "*", "**");

    setType("builtin")(
      "Bool", "Bounded", "Char", "Double", "EQ", "Either", "Enum", "Eq",
      "False", "FilePath", "Float", "Floating", "Fractional", "Functor", "GT",
      "IO", "IOError", "Int", "Integer", "Integral", "Just", "LT", "Left",
      "Maybe", "Monad", "Nothing", "Num", "Ord", "Ordering", "Rational", "Read",
      "ReadS", "Real", "RealFloat", "RealFrac", "Right", "Show", "ShowS",
      "String", "True");

    setType("builtin")(
      "abs", "acos", "acosh", "all", "and", "any", "appendFile", "asTypeOf",
      "asin", "asinh", "atan", "atan2", "atanh", "break", "catch", "ceiling",
      "compare", "concat", "concatMap", "const", "cos", "cosh", "curry",
      "cycle", "decodeFloat", "div", "divMod", "drop", "dropWhile", "either",
      "elem", "encodeFloat", "enumFrom", "enumFromThen", "enumFromThenTo",
      "enumFromTo", "error", "even", "exp", "exponent", "fail", "filter",
      "flip", "floatDigits", "floatRadix", "floatRange", "floor", "fmap",
      "foldl", "foldl1", "foldr", "foldr1", "fromEnum", "fromInteger",
      "fromIntegral", "fromRational", "fst", "gcd", "getChar", "getContents",
      "getLine", "head", "id", "init", "interact", "ioError", "isDenormalized",
      "isIEEE", "isInfinite", "isNaN", "isNegativeZero", "iterate", "last",
      "lcm", "length", "lex", "lines", "log", "logBase", "lookup", "map",
      "mapM", "mapM_", "max", "maxBound", "maximum", "maybe", "min", "minBound",
      "minimum", "mod", "negate", "not", "notElem", "null", "odd", "or",
      "otherwise", "pi", "pred", "print", "product", "properFraction",
      "putChar", "putStr", "putStrLn", "quot", "quotRem", "read", "readFile",
      "readIO", "readList", "readLn", "readParen", "reads", "readsPrec",
      "realToFrac", "recip", "rem", "repeat", "replicate", "return", "reverse",
      "round", "scaleFloat", "scanl", "scanl1", "scanr", "scanr1", "seq",
      "sequence", "sequence_", "show", "showChar", "showList", "showParen",
      "showString", "shows", "showsPrec", "significand", "signum", "sin",
      "sinh", "snd", "span", "splitAt", "sqrt", "subtract", "succ", "sum",
      "tail", "take", "takeWhile", "tan", "tanh", "toEnum", "toInteger",
      "toRational", "truncate", "uncurry", "undefined", "unlines", "until",
      "unwords", "unzip", "unzip3", "userError", "words", "writeFile", "zip",
      "zip3", "zipWith", "zipWith3");

    var override = modeConfig.overrideKeywords;
    if (override) for (var word in override) if (override.hasOwnProperty(word))
      wkw[word] = override[word];

    return wkw;
  })();



  return {
    startState: function ()  { return { f: normal }; },
    copyState:  function (s) { return { f: s.f }; },

    token: function(stream, state) {
      var t = state.f(stream, function(s) { state.f = s; });
      var w = stream.current();
      return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;
    },

    blockCommentStart: "{-",
    blockCommentEnd: "-}",
    lineComment: "--"
  };

});

CodeMirror.defineMIME("text/x-haskell", "haskell");

});

if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old};
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode('mllike', function(_config, parserConfig) {
  var words = {
    'let': 'keyword',
    'rec': 'keyword',
    'in': 'keyword',
    'of': 'keyword',
    'and': 'keyword',
    'if': 'keyword',
    'then': 'keyword',
    'else': 'keyword',
    'for': 'keyword',
    'to': 'keyword',
    'while': 'keyword',
    'do': 'keyword',
    'done': 'keyword',
    'fun': 'keyword',
    'function': 'keyword',
    'val': 'keyword',
    'type': 'keyword',
    'mutable': 'keyword',
    'match': 'keyword',
    'with': 'keyword',
    'try': 'keyword',
    'open': 'builtin',
    'ignore': 'builtin',
    'begin': 'keyword',
    'end': 'keyword'
  };

  var extraWords = parserConfig.extraWords || {};
  for (var prop in extraWords) {
    if (extraWords.hasOwnProperty(prop)) {
      words[prop] = parserConfig.extraWords[prop];
    }
  }

  function tokenBase(stream, state) {
    var ch = stream.next();

    if (ch === '"') {
      state.tokenize = tokenString;
      return state.tokenize(stream, state);
    }
    if (ch === '(') {
      if (stream.eat('*')) {
        state.commentLevel++;
        state.tokenize = tokenComment;
        return state.tokenize(stream, state);
      }
    }
    if (ch === '~') {
      stream.eatWhile(/\w/);
      return 'variable-2';
    }
    if (ch === '`') {
      stream.eatWhile(/\w/);
      return 'quote';
    }
    if (ch === '/' && parserConfig.slashComments && stream.eat('/')) {
      stream.skipToEnd();
      return 'comment';
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\d]/);
      if (stream.eat('.')) {
        stream.eatWhile(/[\d]/);
      }
      return 'number';
    }
    if ( /[+\-*&%=<>!?|]/.test(ch)) {
      return 'operator';
    }
    stream.eatWhile(/\w/);
    var cur = stream.current();
    return words.hasOwnProperty(cur) ? words[cur] : 'variable';
  }

  function tokenString(stream, state) {
    var next, end = false, escaped = false;
    while ((next = stream.next()) != null) {
      if (next === '"' && !escaped) {
        end = true;
        break;
      }
      escaped = !escaped && next === '\\';
    }
    if (end && !escaped) {
      state.tokenize = tokenBase;
    }
    return 'string';
  };

  function tokenComment(stream, state) {
    var prev, next;
    while(state.commentLevel > 0 && (next = stream.next()) != null) {
      if (prev === '(' && next === '*') state.commentLevel++;
      if (prev === '*' && next === ')') state.commentLevel--;
      prev = next;
    }
    if (state.commentLevel <= 0) {
      state.tokenize = tokenBase;
    }
    return 'comment';
  }

  return {
    startState: function() {return {tokenize: tokenBase, commentLevel: 0};},
    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      return state.tokenize(stream, state);
    },

    blockCommentStart: "(*",
    blockCommentEnd: "*)",
    lineComment: parserConfig.slashComments ? "//" : null
  };
});

CodeMirror.defineMIME('text/x-ocaml', {
  name: 'mllike',
  extraWords: {
    'succ': 'keyword',
    'trace': 'builtin',
    'exit': 'builtin',
    'print_string': 'builtin',
    'print_endline': 'builtin',
    'true': 'atom',
    'false': 'atom',
    'raise': 'keyword'
  }
});

CodeMirror.defineMIME('text/x-fsharp', {
  name: 'mllike',
  extraWords: {
    'abstract': 'keyword',
    'as': 'keyword',
    'assert': 'keyword',
    'base': 'keyword',
    'class': 'keyword',
    'default': 'keyword',
    'delegate': 'keyword',
    'downcast': 'keyword',
    'downto': 'keyword',
    'elif': 'keyword',
    'exception': 'keyword',
    'extern': 'keyword',
    'finally': 'keyword',
    'global': 'keyword',
    'inherit': 'keyword',
    'inline': 'keyword',
    'interface': 'keyword',
    'internal': 'keyword',
    'lazy': 'keyword',
    'let!': 'keyword',
    'member' : 'keyword',
    'module': 'keyword',
    'namespace': 'keyword',
    'new': 'keyword',
    'null': 'keyword',
    'override': 'keyword',
    'private': 'keyword',
    'public': 'keyword',
    'return': 'keyword',
    'return!': 'keyword',
    'select': 'keyword',
    'static': 'keyword',
    'struct': 'keyword',
    'upcast': 'keyword',
    'use': 'keyword',
    'use!': 'keyword',
    'val': 'keyword',
    'when': 'keyword',
    'yield': 'keyword',
    'yield!': 'keyword',

    'List': 'builtin',
    'Seq': 'builtin',
    'Map': 'builtin',
    'Set': 'builtin',
    'int': 'builtin',
    'string': 'builtin',
    'raise': 'builtin',
    'failwith': 'builtin',
    'not': 'builtin',
    'true': 'builtin',
    'false': 'builtin'
  },
  slashComments: true
});

});

if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old};
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("clike", function(config, parserConfig) {
  var indentUnit = config.indentUnit,
      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
      dontAlignCalls = parserConfig.dontAlignCalls,
      keywords = parserConfig.keywords || {},
      builtin = parserConfig.builtin || {},
      blockKeywords = parserConfig.blockKeywords || {},
      atoms = parserConfig.atoms || {},
      hooks = parserConfig.hooks || {},
      multiLineStrings = parserConfig.multiLineStrings,
      indentStatements = parserConfig.indentStatements !== false;
  var isOperatorChar = /[+\-*&%=<>!?|\/]/;

  var curPunc;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_\xa1-\uffff]/);
    var cur = stream.current();
    if (keywords.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "keyword";
    }
    if (builtin.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "builtin";
    }
    if (atoms.propertyIsEnumerable(cur)) return "atom";
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {end = true; break;}
        escaped = !escaped && next == "\\";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = null;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function Context(indented, column, type, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.align = align;
    this.prev = prev;
  }
  function pushContext(state, col, type) {
    var indent = state.indented;
    if (state.context && state.context.type == "statement")
      indent = state.context.indented;
    return state.context = new Context(indent, col, type, null, state.context);
  }
  function popContext(state) {
    var t = state.context.type;
    if (t == ")" || t == "]" || t == "}")
      state.indented = state.context.indented;
    return state.context = state.context.prev;
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
        indented: 0,
        startOfLine: true
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (stream.eatSpace()) return null;
      curPunc = null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment" || style == "meta") return style;
      if (ctx.align == null) ctx.align = true;

      if ((curPunc == ";" || curPunc == ":" || curPunc == ",") && ctx.type == "statement") popContext(state);
      else if (curPunc == "{") pushContext(state, stream.column(), "}");
      else if (curPunc == "[") pushContext(state, stream.column(), "]");
      else if (curPunc == "(") pushContext(state, stream.column(), ")");
      else if (curPunc == "}") {
        while (ctx.type == "statement") ctx = popContext(state);
        if (ctx.type == "}") ctx = popContext(state);
        while (ctx.type == "statement") ctx = popContext(state);
      }
      else if (curPunc == ctx.type) popContext(state);
      else if (indentStatements &&
               (((ctx.type == "}" || ctx.type == "top") && curPunc != ';') ||
                (ctx.type == "statement" && curPunc == "newstatement")))
        pushContext(state, stream.column(), "statement");
      state.startOfLine = false;
      return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;
      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
      if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
      var closing = firstChar == ctx.type;
      if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit);
      else if (ctx.align && (!dontAlignCalls || ctx.type != ")")) return ctx.column + (closing ? 0 : 1);
      else if (ctx.type == ")" && !closing) return ctx.indented + statementIndentUnit;
      else return ctx.indented + (closing ? 0 : indentUnit);
    },

    electricChars: "{}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    lineComment: "//",
    fold: "brace"
  };
});

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var cKeywords = "auto if break int case long char register continue return default short do sizeof " +
    "double static else struct entry switch extern typedef float union for unsigned " +
    "goto while enum void const signed volatile";

  function cppHook(stream, state) {
    if (!state.startOfLine) return false;
    for (;;) {
      if (stream.skipTo("\\")) {
        stream.next();
        if (stream.eol()) {
          state.tokenize = cppHook;
          break;
        }
      } else {
        stream.skipToEnd();
        state.tokenize = null;
        break;
      }
    }
    return "meta";
  }

  function cpp11StringHook(stream, state) {
    stream.backUp(1);
    // Raw strings.
    if (stream.match(/(R|u8R|uR|UR|LR)/)) {
      var match = stream.match(/"([^\s\\()]{0,16})\(/);
      if (!match) {
        return false;
      }
      state.cpp11RawStringDelim = match[1];
      state.tokenize = tokenRawString;
      return tokenRawString(stream, state);
    }
    // Unicode strings/chars.
    if (stream.match(/(u8|u|U|L)/)) {
      if (stream.match(/["']/, /* eat */ false)) {
        return "string";
      }
      return false;
    }
    // Ignore this hook.
    stream.next();
    return false;
  }

  // C#-style strings where "" escapes a quote.
  function tokenAtString(stream, state) {
    var next;
    while ((next = stream.next()) != null) {
      if (next == '"' && !stream.eat('"')) {
        state.tokenize = null;
        break;
      }
    }
    return "string";
  }

  // C++11 raw string literal is <prefix>"<delim>( anything )<delim>", where
  // <delim> can be a string up to 16 characters long.
  function tokenRawString(stream, state) {
    // Escape characters that have special regex meanings.
    var delim = state.cpp11RawStringDelim.replace(/[^\w\s]/g, '\\$&');
    var match = stream.match(new RegExp(".*?\\)" + delim + '"'));
    if (match)
      state.tokenize = null;
    else
      stream.skipToEnd();
    return "string";
  }

  function def(mimes, mode) {
    if (typeof mimes == "string") mimes = [mimes];
    var words = [];
    function add(obj) {
      if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop))
        words.push(prop);
    }
    add(mode.keywords);
    add(mode.builtin);
    add(mode.atoms);
    if (words.length) {
      mode.helperType = mimes[0];
      CodeMirror.registerHelper("hintWords", mimes[0], words);
    }

    for (var i = 0; i < mimes.length; ++i)
      CodeMirror.defineMIME(mimes[i], mode);
  }

  def(["text/x-csrc", "text/x-c", "text/x-chdr"], {
    name: "clike",
    keywords: words(cKeywords),
    blockKeywords: words("case do else for if switch while struct"),
    atoms: words("null"),
    hooks: {"#": cppHook},
    modeProps: {fold: ["brace", "include"]}
  });

  def(["text/x-c++src", "text/x-c++hdr"], {
    name: "clike",
    keywords: words(cKeywords + " asm dynamic_cast namespace reinterpret_cast try bool explicit new " +
                    "static_cast typeid catch operator template typename class friend private " +
                    "this using const_cast inline public throw virtual delete mutable protected " +
                    "wchar_t alignas alignof constexpr decltype nullptr noexcept thread_local final " +
                    "static_assert override"),
    blockKeywords: words("catch class do else finally for if struct switch try while"),
    atoms: words("true false null"),
    hooks: {
      "#": cppHook,
      "u": cpp11StringHook,
      "U": cpp11StringHook,
      "L": cpp11StringHook,
      "R": cpp11StringHook
    },
    modeProps: {fold: ["brace", "include"]}
  });

  def("text/x-java", {
    name: "clike",
    keywords: words("abstract assert boolean break byte case catch char class const continue default " +
                    "do double else enum extends final finally float for goto if implements import " +
                    "instanceof int interface long native new package private protected public " +
                    "return short static strictfp super switch synchronized this throw throws transient " +
                    "try void volatile while"),
    blockKeywords: words("catch class do else finally for if switch try while"),
    atoms: words("true false null"),
    hooks: {
      "@": function(stream) {
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      }
    },
    modeProps: {fold: ["brace", "import"]}
  });

  def("text/x-csharp", {
    name: "clike",
    keywords: words("abstract as base break case catch checked class const continue" +
                    " default delegate do else enum event explicit extern finally fixed for" +
                    " foreach goto if implicit in interface internal is lock namespace new" +
                    " operator out override params private protected public readonly ref return sealed" +
                    " sizeof stackalloc static struct switch this throw try typeof unchecked" +
                    " unsafe using virtual void volatile while add alias ascending descending dynamic from get" +
                    " global group into join let orderby partial remove select set value var yield"),
    blockKeywords: words("catch class do else finally for foreach if struct switch try while"),
    builtin: words("Boolean Byte Char DateTime DateTimeOffset Decimal Double" +
                    " Guid Int16 Int32 Int64 Object SByte Single String TimeSpan UInt16 UInt32" +
                    " UInt64 bool byte char decimal double short int long object"  +
                    " sbyte float string ushort uint ulong"),
    atoms: words("true false null"),
    hooks: {
      "@": function(stream, state) {
        if (stream.eat('"')) {
          state.tokenize = tokenAtString;
          return tokenAtString(stream, state);
        }
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      }
    }
  });

  function tokenTripleString(stream, state) {
    var escaped = false;
    while (!stream.eol()) {
      if (!escaped && stream.match('"""')) {
        state.tokenize = null;
        break;
      }
      escaped = stream.next() == "\\" && !escaped;
    }
    return "string";
  }

  def("text/x-scala", {
    name: "clike",
    keywords: words(

      /* scala */
      "abstract case catch class def do else extends false final finally for forSome if " +
      "implicit import lazy match new null object override package private protected return " +
      "sealed super this throw trait try trye type val var while with yield _ : = => <- <: " +
      "<% >: # @ " +

      /* package scala */
      "assert assume require print println printf readLine readBoolean readByte readShort " +
      "readChar readInt readLong readFloat readDouble " +

      "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either " +
      "Enumeration Equiv Error Exception Fractional Function IndexedSeq Integral Iterable " +
      "Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering " +
      "Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder " +
      "StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector :: #:: " +

      /* package java.lang */
      "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +
      "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +
      "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +
      "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"
    ),
    multiLineStrings: true,
    blockKeywords: words("catch class do else finally for forSome if match switch try while"),
    atoms: words("true false null"),
    indentStatements: false,
    hooks: {
      "@": function(stream) {
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      },
      '"': function(stream, state) {
        if (!stream.match('""')) return false;
        state.tokenize = tokenTripleString;
        return state.tokenize(stream, state);
      },
      "'": function(stream) {
        stream.eatWhile(/[\w\$_\xa1-\uffff]/);
        return "atom";
      }
    },
    modeProps: {closeBrackets: {triples: '"'}}
  });

  def(["x-shader/x-vertex", "x-shader/x-fragment"], {
    name: "clike",
    keywords: words("float int bool void " +
                    "vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 " +
                    "mat2 mat3 mat4 " +
                    "sampler1D sampler2D sampler3D samplerCube " +
                    "sampler1DShadow sampler2DShadow " +
                    "const attribute uniform varying " +
                    "break continue discard return " +
                    "for while do if else struct " +
                    "in out inout"),
    blockKeywords: words("for while do if else struct"),
    builtin: words("radians degrees sin cos tan asin acos atan " +
                    "pow exp log exp2 sqrt inversesqrt " +
                    "abs sign floor ceil fract mod min max clamp mix step smoothstep " +
                    "length distance dot cross normalize ftransform faceforward " +
                    "reflect refract matrixCompMult " +
                    "lessThan lessThanEqual greaterThan greaterThanEqual " +
                    "equal notEqual any all not " +
                    "texture1D texture1DProj texture1DLod texture1DProjLod " +
                    "texture2D texture2DProj texture2DLod texture2DProjLod " +
                    "texture3D texture3DProj texture3DLod texture3DProjLod " +
                    "textureCube textureCubeLod " +
                    "shadow1D shadow2D shadow1DProj shadow2DProj " +
                    "shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod " +
                    "dFdx dFdy fwidth " +
                    "noise1 noise2 noise3 noise4"),
    atoms: words("true false " +
                "gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex " +
                "gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 " +
                "gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 " +
                "gl_FogCoord gl_PointCoord " +
                "gl_Position gl_PointSize gl_ClipVertex " +
                "gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor " +
                "gl_TexCoord gl_FogFragCoord " +
                "gl_FragCoord gl_FrontFacing " +
                "gl_FragData gl_FragDepth " +
                "gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix " +
                "gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse " +
                "gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse " +
                "gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose " +
                "gl_ProjectionMatrixInverseTranspose " +
                "gl_ModelViewProjectionMatrixInverseTranspose " +
                "gl_TextureMatrixInverseTranspose " +
                "gl_NormalScale gl_DepthRange gl_ClipPlane " +
                "gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel " +
                "gl_FrontLightModelProduct gl_BackLightModelProduct " +
                "gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ " +
                "gl_FogParameters " +
                "gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords " +
                "gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats " +
                "gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits " +
                "gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits " +
                "gl_MaxDrawBuffers"),
    hooks: {"#": cppHook},
    modeProps: {fold: ["brace", "include"]}
  });

  def("text/x-nesc", {
    name: "clike",
    keywords: words(cKeywords + "as atomic async call command component components configuration event generic " +
                    "implementation includes interface module new norace nx_struct nx_union post provides " +
                    "signal task uses abstract extends"),
    blockKeywords: words("case do else for if switch while struct"),
    atoms: words("null"),
    hooks: {"#": cppHook},
    modeProps: {fold: ["brace", "include"]}
  });

  def("text/x-objectivec", {
    name: "clike",
    keywords: words(cKeywords + "inline restrict _Bool _Complex _Imaginery BOOL Class bycopy byref id IMP in " +
                    "inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),
    atoms: words("YES NO NULL NILL ON OFF"),
    hooks: {
      "@": function(stream) {
        stream.eatWhile(/[\w\$]/);
        return "keyword";
      },
      "#": cppHook
    },
    modeProps: {fold: "brace"}
  });

});

if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old};
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
if(typeof(define) == 'function'){__define__old=define;delete define}
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// TODO actually recognize syntax of TypeScript constructs

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;
  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    var jsKeywords = {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C, "debugger": C,
      "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "module": kw("module"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C
    };

    // Extend the 'normal' keywords with the TypeScript language extensions
    if (isTS) {
      var type = {type: "variable", style: "variable-3"};
      var tsKeywords = {
        // object-like things
        "interface": kw("interface"),
        "extends": kw("extends"),
        "constructor": kw("constructor"),

        // scope modifiers
        "public": kw("public"),
        "private": kw("private"),
        "protected": kw("protected"),
        "static": kw("static"),

        // types
        "string": type, "number": type, "bool": type, "any": type
      };

      for (var attr in tsKeywords) {
        jsKeywords[attr] = tsKeywords[attr];
      }
    }

    return jsKeywords;
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" && !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet && next == "]") inSet = false;
      }
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
      return ret("number", "number");
    } else if (ch == "." && stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" && stream.eat(">")) {
      return ret("=>", "operator");
    } else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (state.lastType == "operator" || state.lastType == "keyword c" ||
               state.lastType == "sof" || /^[\[{}\(,;:]$/.test(state.lastType)) {
        readRegexp(stream);
        stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
        return ret("regexp", "string-2");
      } else {
        stream.eatWhile(isOperatorChar);
        return ret("operator", "operator", stream.current());
      }
    } else if (ch == "`") {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    } else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret("operator", "operator", stream.current());
    } else if (wordRE.test(ch)) {
      stream.eatWhile(wordRE);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
                     ret("variable", "variable", word);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret("jsonld-keyword", "meta");
      }
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    return ret("quasi", "string-2", stream.current());
  }

  var brackets = "([{}])";
  // This is a crude lookahead trick to try and notice that we're
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there's no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf("=>", stream.start);
    if (arrow < 0) return;

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos >= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket >= 0 && bracket < 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) break;
      } else if (bracket >= 3 && bracket < 6) {
        ++depth;
      } else if (wordRE.test(ch)) {
        sawSomething = true;
      } else if (/["'\/]/.test(ch)) {
        return;
      } else if (sawSomething && !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething && !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname) return true;
      return false;
    }
    var state = cx.state;
    if (state.context) {
      cx.marked = "def";
      if (inList(state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else {
      if (inList(state.globalVars)) return;
      if (parserConfig.globalVars)
        state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  // Combinators

  var defaultVars = {name: "this", next: {name: "arguments"}};
  function pushcontext() {
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
        indent = outer.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(exp);
    };
    return exp;
  }

  function statement(type, value) {
    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "{") return cont(pushlex("}"), block, poplex);
    if (type == ";") return cont();
    if (type == "if") {
      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex("form"), expression, statement, poplex, maybeelse);
    }
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
    if (type == "variable") return cont(pushlex("stat"), maybelabel);
    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                      block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                     statement, poplex, popcontext);
    if (type == "module") return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex);
    if (type == "class") return cont(pushlex("form"), className, poplex);
    if (type == "export") return cont(pushlex("form"), afterExport, poplex);
    if (type == "import") return cont(pushlex("form"), afterImport, poplex);
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type) {
    return expressionInner(type, false);
  }
  function expressionNoComma(type) {
    return expressionInner(type, true);
  }
  function expressionInner(type, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);
      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef, maybeop);
    if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);
    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
    if (type == "quasi") { return pass(quasi, maybeop); }
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }
  function maybeexpressionNoComma(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expressionNoComma);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == "operator") {
      if (/\+\+|--/.test(value)) return cont(me);
      if (value == "?") return cont(expression, expect(":"), expr);
      return cont(expr);
    }
    if (type == "quasi") { return pass(quasi, me); }
    if (type == ";") return;
    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
  }
  function quasi(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasi);
    return cont(expression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expressionNoComma);
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
      return cont(afterprop);
    } else if (type == "number" || type == "string") {
      cx.marked = jsonldMode ? "property" : (cx.style + " property");
      return cont(afterprop);
    } else if (type == "jsonld-keyword") {
      return cont(afterprop);
    } else if (type == "[") {
      return cont(expression, expect("]"), afterprop);
    }
  }
  function getterSetter(type) {
    if (type != "variable") return pass(afterprop);
    cx.marked = "property";
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == ":") return cont(expressionNoComma);
    if (type == "(") return pass(functiondef);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(what, proceed);
      }
      if (type == end) return cont();
      return cont(expect(end));
    }
    return function(type) {
      if (type == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i < arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type) {
    if (isTS && type == ":") return cont(typedef);
  }
  function typedef(type) {
    if (type == "variable"){cx.marked = "variable-3"; return cont();}
  }
  function vardef() {
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (type == "variable") { register(value); return cont(); }
    if (type == "[") return contCommasep(pattern, "]");
    if (type == "{") return contCommasep(proppattern, "}");
  }
  function proppattern(type, value) {
    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == "variable") cx.marked = "property";
    return cont(expect(":"), pattern, maybeAssign);
  }
  function maybeAssign(_type, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == ",") return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
  }
  function forspec(type) {
    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef, expect(";"), forspec2);
    if (type == ";") return cont(forspec2);
    if (type == "variable") return cont(formaybeinof);
    return pass(expression, expect(";"), forspec2);
  }
  function formaybeinof(_type, value) {
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == ";") return cont(forspec3);
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return pass(expression, expect(";"), forspec3);
  }
  function forspec3(type) {
    if (type != ")") cont(expression);
  }
  function functiondef(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext);
  }
  function funarg(type) {
    if (type == "spread") return cont(funarg);
    return pass(pattern, maybetype);
  }
  function className(type, value) {
    if (type == "variable") {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(type, value) {
    if (value == "extends") return cont(expression, classNameAfter);
    if (type == "{") return cont(pushlex("}"), classBody, poplex);
  }
  function classBody(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      if (value == "static") {
        cx.marked = "keyword";
        return cont(classBody);
      }
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(classGetterSetter, functiondef, classBody);
      return cont(functiondef, classBody);
    }
    if (value == "*") {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (type == ";") return cont(classBody);
    if (type == "}") return cont();
  }
  function classGetterSetter(type) {
    if (type != "variable") return pass();
    cx.marked = "property";
    return cont();
  }
  function afterModule(type, value) {
    if (type == "string") return cont(statement);
    if (type == "variable") { register(value); return cont(maybeFrom); }
  }
  function afterExport(_type, value) {
    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
    return pass(statement);
  }
  function afterImport(type) {
    if (type == "string") return cont();
    return pass(importSpec, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == "{") return contCommasep(importSpec, "}");
    if (type == "variable") register(value);
    return cont();
  }
  function maybeFrom(_type, value) {
    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == "]") return cont();
    return pass(expressionNoComma, maybeArrayComprehension);
  }
  function maybeArrayComprehension(type) {
    if (type == "for") return pass(comprehension, expect("]"));
    if (type == ",") return cont(commasep(maybeexpressionNoComma, "]"));
    return pass(commasep(expressionNoComma, "]"));
  }
  function comprehension(type) {
    if (type == "for") return cont(forspec, comprehension);
    if (type == "if") return cont(expression, comprehension);
  }

  function isContinuedStatement(state, textAfter) {
    return state.lastType == "operator" || state.lastType == "," ||
      isOperatorChar.test(textAfter.charAt(0)) ||
      /[,.]/.test(textAfter.charAt(0));
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: "sof",
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars && {vars: parserConfig.localVars},
        indented: 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse) break;
      }
      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    lineComment: jsonMode ? null : "//",
    fold: "brace",
    closeBrackets: "()[]{}''\"\"``",

    helperType: jsonMode ? "json" : "javascript",
    jsonldMode: jsonldMode,
    jsonMode: jsonMode
  };
});

CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/x-javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});

if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old}
if(typeof(__define__old) == 'function'){define=__define__old;delete __define__old};
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var t;"undefined"!=typeof window?t=window:"undefined"!=typeof global?t=global:"undefined"!=typeof self&&(t=self),t.Promise=e()}}(function(){return function e(t,n,r){function o(s,u){if(!n[s]){if(!t[s]){var c="function"==typeof require&&require;if(!u&&c)return c(s,!0);if(i)return i(s,!0);throw new Error("Cannot find module '"+s+"'")}var a=n[s]={exports:{}};t[s][0].call(a.exports,function(e){var n=t[s][1][e];return o(n?n:e)},a,a.exports,e,t,n,r)}return n[s].exports}for(var i="function"==typeof require&&require,s=0;s<r.length;s++)o(r[s]);return o}({1:[function(e,t){"use strict";function n(){}t.exports=n},{}],2:[function(e,t){"use strict";var n=e("./promise"),r=e("./reject"),o=e("./resolve"),i=e("./INTERNAL"),s=e("./handlers"),u=r(new TypeError("must be an array"));t.exports=function(e){function t(e,t){function n(e){a[t]=e,++l===r&!c&&(c=!0,s.resolve(h,a))}o(e).then(n,function(e){c||(c=!0,s.reject(h,e))})}if("[object Array]"!==Object.prototype.toString.call(e))return u;var r=e.length,c=!1;if(!r)return o([]);for(var a=new Array(r),l=0,f=-1,h=new n(i);++f<r;)t(e[f],f);return h}},{"./INTERNAL":1,"./handlers":3,"./promise":5,"./reject":7,"./resolve":8}],3:[function(e,t,n){"use strict";function r(e){var t=e&&e.then;return e&&"object"==typeof e&&"function"==typeof t?function(){t.apply(e,arguments)}:void 0}var o=e("./tryCatch"),i=e("./resolveThenable"),s=e("./states");n.resolve=function(e,t){var u=o(r,t);if("error"===u.status)return n.reject(e,u.value);var c=u.value;if(c)i.safely(e,c);else{e.state=s.FULFILLED,e.outcome=t;for(var a=-1,l=e.queue.length;++a<l;)e.queue[a].callFulfilled(t)}return e},n.reject=function(e,t){e.state=s.REJECTED,e.outcome=t;for(var n=-1,r=e.queue.length;++n<r;)e.queue[n].callRejected(t);return e}},{"./resolveThenable":9,"./states":10,"./tryCatch":11}],4:[function(e,t,n){t.exports=n=e("./promise"),n.resolve=e("./resolve"),n.reject=e("./reject"),n.all=e("./all")},{"./all":2,"./promise":5,"./reject":7,"./resolve":8}],5:[function(e,t){"use strict";function n(e){if(!(this instanceof n))return new n(e);if("function"!=typeof e)throw new TypeError("reslover must be a function");this.state=s.PENDING,this.queue=[],this.outcome=void 0,e!==o&&i.safely(this,e)}var r=e("./unwrap"),o=e("./INTERNAL"),i=e("./resolveThenable"),s=e("./states"),u=e("./queueItem");t.exports=n,n.prototype["catch"]=function(e){return this.then(null,e)},n.prototype.then=function(e,t){if("function"!=typeof e&&this.state===s.FULFILLED||"function"!=typeof t&&this.state===s.REJECTED)return this;var i=new n(o);if(this.state!==s.PENDING){var c=this.state===s.FULFILLED?e:t;r(i,c,this.outcome)}else this.queue.push(new u(i,e,t));return i}},{"./INTERNAL":1,"./queueItem":6,"./resolveThenable":9,"./states":10,"./unwrap":12}],6:[function(e,t){"use strict";function n(e,t,n){this.promise=e,"function"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),"function"==typeof n&&(this.onRejected=n,this.callRejected=this.otherCallRejected)}var r=e("./handlers"),o=e("./unwrap");t.exports=n,n.prototype.callFulfilled=function(e){r.resolve(this.promise,e)},n.prototype.otherCallFulfilled=function(e){o(this.promise,this.onFulfilled,e)},n.prototype.callRejected=function(e){r.reject(this.promise,e)},n.prototype.otherCallRejected=function(e){o(this.promise,this.onRejected,e)}},{"./handlers":3,"./unwrap":12}],7:[function(e,t){"use strict";function n(e){var t=new r(o);return i.reject(t,e)}var r=e("./promise"),o=e("./INTERNAL"),i=e("./handlers");t.exports=n},{"./INTERNAL":1,"./handlers":3,"./promise":5}],8:[function(e,t){"use strict";function n(e){if(e)return e instanceof r?e:i.resolve(new r(o),e);var t=typeof e;switch(t){case"boolean":return s;case"undefined":return c;case"object":return u;case"number":return a;case"string":return l}}var r=e("./promise"),o=e("./INTERNAL"),i=e("./handlers");t.exports=n;var s=i.resolve(new r(o),!1),u=i.resolve(new r(o),null),c=i.resolve(new r(o),void 0),a=i.resolve(new r(o),0),l=i.resolve(new r(o),"")},{"./INTERNAL":1,"./handlers":3,"./promise":5}],9:[function(e,t,n){"use strict";function r(e,t){function n(t){u||(u=!0,o.reject(e,t))}function r(t){u||(u=!0,o.resolve(e,t))}function s(){t(r,n)}var u=!1,c=i(s);"error"===c.status&&n(c.value)}var o=e("./handlers"),i=e("./tryCatch");n.safely=r},{"./handlers":3,"./tryCatch":11}],10:[function(e,t,n){n.REJECTED=["REJECTED"],n.FULFILLED=["FULFILLED"],n.PENDING=["PENDING"]},{}],11:[function(e,t){"use strict";function n(e,t){var n={};try{n.value=e(t),n.status="success"}catch(r){n.status="error",n.value=r}return n}t.exports=n},{}],12:[function(e,t){"use strict";function n(e,t,n){r(function(){var r;try{r=t(n)}catch(i){return o.reject(e,i)}r===e?o.reject(e,new TypeError("Cannot resolve promise with itself")):o.resolve(e,r)})}var r=e("immediate"),o=e("./handlers");t.exports=n},{"./handlers":3,immediate:13}],13:[function(e,t){"use strict";function n(){o=!0;for(var e,t,n=u.length;n;){for(t=u,u=[],e=-1;++e<n;)t[e]();n=u.length}o=!1}function r(e){1!==u.push(e)||o||i()}for(var o,i,s=[e("./nextTick"),e("./messageChannel"),e("./stateChange"),e("./timeout")],u=[],c=-1,a=s.length;++c<a;)if(s[c].test()){i=s[c].install(n);break}t.exports=r},{"./messageChannel":14,"./nextTick":15,"./stateChange":16,"./timeout":17}],14:[function(e,t,n){(function(e){"use strict";n.test=function(){return e.setImmediate?!1:"undefined"!=typeof e.MessageChannel},n.install=function(t){var n=new e.MessageChannel;return n.port1.onmessage=t,function(){n.port2.postMessage(0)}}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],15:[function(e,t,n){(function(e){"use strict";var t=e.MutationObserver||e.WebKitMutationObserver;n.test=function(){return t},n.install=function(n){var r=0,o=new t(n),i=e.document.createTextNode("");return o.observe(i,{characterData:!0}),function(){i.data=r=++r%2}}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],16:[function(e,t,n){(function(e){"use strict";n.test=function(){return"document"in e&&"onreadystatechange"in e.document.createElement("script")},n.install=function(t){return function(){var n=e.document.createElement("script");return n.onreadystatechange=function(){t(),n.onreadystatechange=null,n.parentNode.removeChild(n),n=null},e.document.documentElement.appendChild(n),t}}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],17:[function(e,t,n){"use strict";n.test=function(){return!0},n.install=function(e){return function(){setTimeout(e,0)}}},{}]},{},[4])(4)});;
//    PouchDB 3.0.5
//    
//    (c) 2012-2014 Dale Harvey and the PouchDB team
//    PouchDB may be freely distributed under the Apache license, version 2.0.
//    For all details and documentation:
//    http://pouchdb.com
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var t;"undefined"!=typeof window?t=window:"undefined"!=typeof global?t=global:"undefined"!=typeof self&&(t=self),t.PouchDB=e()}}(function(){var define,module,exports;return function e(t,n,r){function o(s,a){if(!n[s]){if(!t[s]){var u="function"==typeof require&&require;if(!a&&u)return u(s,!0);if(i)return i(s,!0);throw new Error("Cannot find module '"+s+"'")}var c=n[s]={exports:{}};t[s][0].call(c.exports,function(e){var n=t[s][1][e];return o(n?n:e)},c,c.exports,e,t,n,r)}return n[s].exports}for(var i="function"==typeof require&&require,s=0;s<r.length;s++)o(r[s]);return o}({1:[function(e,t){"use strict";function n(e,t){for(var n=0;n<e.length;n++)if(t(e[n],n)===!0)return e[n];return!1}function r(e){return function(t,n){t||n[0].error?e(t||n[0]):e(null,n[0])}}function o(e){var t={},n=[];return u.traverseRevTree(e,function(e,r,o,i){var s=r+"-"+o;return e&&(t[s]=0),void 0!==i&&n.push({from:i,to:s}),s}),n.reverse(),n.forEach(function(e){t[e.from]=void 0===t[e.from]?1+t[e.to]:Math.min(t[e.from],1+t[e.to])}),t}function i(e,t,n){var r="limit"in t?t.keys.slice(t.skip,t.limit+t.skip):t.skip>0?t.keys.slice(t.skip):t.keys;if(t.descending&&r.reverse(),!r.length)return e._allDocs({limit:0},n);var o={offset:t.skip};return p.all(r.map(function(n){var r=a.extend(!0,{key:n,deleted:"ok"},t);return["limit","skip","keys"].forEach(function(e){delete r[e]}),new p(function(t,i){e._allDocs(r,function(e,r){return e?i(e):(o.total_rows=r.total_rows,void t(r.rows[0]||{key:n,error:"not_found"}))})})})).then(function(e){return o.rows=e,o})}function s(){var e=this;l.call(this),e.autoCompact=function(t){return e.auto_compaction&&"http"!==e.type()?function(n,r){if(n)t(n);else{var o=r.length,i=function(){o--,o||t(null,r)};if(!r.length)return t(null,r);r.forEach(function(t){t.ok&&t.id?e.compactDocument(t.id,1,i):i()})}}:t};var t,n=0,r=["change","delete","create","update"];this.on("newListener",function(o){if(~r.indexOf(o)){if(n)return void n++;n++;var i=0;t=this.changes({conflicts:!0,include_docs:!0,continuous:!0,since:"now",onChange:function(t){t.seq<=i||(i=t.seq,e.emit("change",t),t.doc._deleted?e.emit("delete",t):"1"===t.doc._rev.split("-")[0]?e.emit("create",t):e.emit("update",t))}})}}),this.on("removeListener",function(e){~r.indexOf(e)&&(n--,n||t.cancel())})}var a=e("./utils"),u=e("./merge"),c=e("./deps/errors"),l=e("events").EventEmitter,d=e("./deps/upsert"),f=e("./changes"),p=a.Promise;a.inherits(s,l),t.exports=s,s.prototype.post=a.adapterFun("post",function(e,t,n){return"function"==typeof t&&(n=t,t={}),"object"!=typeof e||Array.isArray(e)?n(c.NOT_AN_OBJECT):void this.bulkDocs({docs:[e]},t,this.autoCompact(r(n)))}),s.prototype.put=a.adapterFun("put",a.getArguments(function(e){var t,n,o,i,s=e.shift(),u="_id"in s;if("object"!=typeof s||Array.isArray(s))return(i=e.pop())(c.NOT_AN_OBJECT);for(s=a.clone(s);;)if(t=e.shift(),n=typeof t,"string"!==n||u?"string"!==n||!u||"_rev"in s?"object"===n?o=t:"function"===n&&(i=t):s._rev=t:(s._id=t,u=!0),!e.length)break;o=o||{};var l=a.invalidIdError(s._id);return l?i(l):a.isLocalId(s._id)&&"function"==typeof this._putLocal?s._deleted?this._removeLocal(s,i):this._putLocal(s,i):void this.bulkDocs({docs:[s]},o,this.autoCompact(r(i)))})),s.prototype.putAttachment=a.adapterFun("putAttachment",function(e,t,n,r,o,i){function s(e){return e._attachments=e._attachments||{},e._attachments[t]={content_type:o,data:r},a.put(e)}var a=this;return"function"==typeof o&&(i=o,o=r,r=n,n=null),"undefined"==typeof o&&(o=r,r=n,n=null),a.get(e).then(function(e){if(e._rev!==n)throw c.REV_CONFLICT;return s(e)},function(t){if(t.error===c.MISSING_DOC.error)return s({_id:e});throw t})}),s.prototype.removeAttachment=a.adapterFun("removeAttachment",function(e,t,n,r){var o=this;o.get(e,function(e,i){return e?void r(e):i._rev!==n?void r(c.REV_CONFLICT):i._attachments?(delete i._attachments[t],0===Object.keys(i._attachments).length&&delete i._attachments,void o.put(i,r)):r()})}),s.prototype.remove=a.adapterFun("remove",function(e,t,n,o){var i;"string"==typeof t?(i={_id:e,_rev:t},"function"==typeof n&&(o=n,n={})):(i=e,"function"==typeof t?(o=t,n={}):(o=n,n=t)),n=a.clone(n||{}),n.was_delete=!0;var s={_id:i._id,_rev:i._rev||n.rev};return s._deleted=!0,a.isLocalId(s._id)&&"function"==typeof this._removeLocal?this._removeLocal(i,o):void this.bulkDocs({docs:[s]},n,r(o))}),s.prototype.revsDiff=a.adapterFun("revsDiff",function(e,t,n){function r(e,t){c.has(e)||c.set(e,{missing:[]}),c.get(e).missing.push(t)}function o(t,n){var o=e[t].slice(0);u.traverseRevTree(n,function(e,n,i,s,a){var u=n+"-"+i,c=o.indexOf(u);-1!==c&&(o.splice(c,1),"available"!==a.status&&r(t,u))}),o.forEach(function(e){r(t,e)})}"function"==typeof t&&(n=t,t={}),t=a.clone(t);var i=Object.keys(e);if(!i.length)return n(null,{});var s=0,c=new a.Map;i.map(function(t){this._getRevisionTree(t,function(r,a){if(r&&404===r.status&&"missing"===r.message)c.set(t,{missing:e[t]});else{if(r)return n(r);o(t,a)}if(++s===i.length){var u={};return c.forEach(function(e,t){u[t]=e}),n(null,u)}})},this)}),s.prototype.compactDocument=a.adapterFun("compactDocument",function(e,t,n){var r=this;this._getRevisionTree(e,function(i,s){if(i)return n(i);var a=o(s),c=[],l=[];Object.keys(a).forEach(function(e){a[e]>t&&c.push(e)}),u.traverseRevTree(s,function(e,t,n,r,o){var i=t+"-"+n;"available"===o.status&&-1!==c.indexOf(i)&&(o.status="missing",l.push(i))}),r._doCompaction(e,s,l,n)})}),s.prototype.compact=a.adapterFun("compact",function(e,t){"function"==typeof e&&(t=e,e={});var n=this;this.changes({complete:function(e,r){if(e)return void t();var o=r.results.length;return o?void r.results.forEach(function(e){n.compactDocument(e.id,0,function(){o--,o||t()})}):void t()}})}),s.prototype.get=a.adapterFun("get",function(e,t,r){function o(){var n=[],o=i.length;return o?void i.forEach(function(i){s.get(e,{rev:i,revs:t.revs,attachments:t.attachments},function(e,t){n.push(e?{missing:i}:{ok:t}),o--,o||r(null,n)})}):r(null,n)}if("function"==typeof t&&(r=t,t={}),"string"!=typeof e)return r(c.INVALID_ID);if(a.isLocalId(e)&&"function"==typeof this._getLocal)return this._getLocal(e,r);var i=[],s=this;if(!t.open_revs)return this._get(e,t,function(e,o){if(t=a.clone(t),e)return r(e);var i=o.doc;if(!i)return r(new Error("no doc!"));var c=o.metadata,l=o.ctx;if(t.conflicts){var d=u.collectConflicts(c);d.length&&(i._conflicts=d)}if(t.revs||t.revs_info){var f=u.rootToLeaf(c.rev_tree),p=n(f,function(e){return-1!==e.ids.map(function(e){return e.id}).indexOf(i._rev.split("-")[1])}),h=p.ids.map(function(e){return e.id}).indexOf(i._rev.split("-")[1])+1,v=p.ids.length-h;if(p.ids.splice(h,v),p.ids.reverse(),t.revs&&(i._revisions={start:p.pos+p.ids.length-1,ids:p.ids.map(function(e){return e.id})}),t.revs_info){var m=p.pos+p.ids.length;i._revs_info=p.ids.map(function(e){return m--,{rev:m+"-"+e.id,status:e.opts.status}})}}if(t.local_seq&&(i._local_seq=o.metadata.seq),t.attachments&&i._attachments){var _=i._attachments,y=Object.keys(_).length;if(0===y)return r(null,i);Object.keys(_).forEach(function(e){this._getAttachment(_[e],{encode:!0,ctx:l},function(t,n){var o=i._attachments[e];o.data=n,delete o.stub,--y||r(null,i)})},s)}else{if(i._attachments)for(var g in i._attachments)i._attachments.hasOwnProperty(g)&&(i._attachments[g].stub=!0);r(null,i)}});if("all"===t.open_revs)this._getRevisionTree(e,function(e,t){e&&(t=[]),i=u.collectLeaves(t).map(function(e){return e.rev}),o()});else{if(!Array.isArray(t.open_revs))return r(c.error(c.UNKNOWN_ERROR,"function_clause"));i=t.open_revs;for(var l=0;l<i.length;l++){var d=i[l];if("string"!=typeof d||!/^\d+-/.test(d))return r(c.error(c.BAD_REQUEST,"Invalid rev format"))}o()}}),s.prototype.getAttachment=a.adapterFun("getAttachment",function(e,t,n,r){var o=this;n instanceof Function&&(r=n,n={}),n=a.clone(n),this._get(e,n,function(e,i){return e?r(e):i.doc._attachments&&i.doc._attachments[t]?(n.ctx=i.ctx,void o._getAttachment(i.doc._attachments[t],n,r)):r(c.MISSING_DOC)})}),s.prototype.allDocs=a.adapterFun("allDocs",function(e,t){if("function"==typeof e&&(t=e,e={}),e=a.clone(e),e.skip="undefined"!=typeof e.skip?e.skip:0,"keys"in e){if(!Array.isArray(e.keys))return t(new TypeError("options.keys must be an array"));var n=["startkey","endkey","key"].filter(function(t){return t in e})[0];if(n)return void t(c.error(c.QUERY_PARSE_ERROR,"Query parameter `"+n+"` is not compatible with multi-get"));if("http"!==this.type())return i(this,e,t)}return this._allDocs(e,t)}),s.prototype.changes=function(e,t){return"function"==typeof e&&(t=e,e={}),new f(this,e,t)},s.prototype.close=a.adapterFun("close",function(e){return this._closed=!0,this._close(e)}),s.prototype.info=a.adapterFun("info",function(e){var t=this;this._info(function(n,r){return n?e(n):(r.db_name=r.db_name||t._db_name,void e(null,r))})}),s.prototype.id=a.adapterFun("id",function(e){return this._id(e)}),s.prototype.type=function(){return"function"==typeof this._type?this._type():this.adapter},s.prototype.bulkDocs=a.adapterFun("bulkDocs",function(e,t,n){if("function"==typeof t&&(n=t,t={}),t=a.clone(t),Array.isArray(e)&&(e={docs:e}),!e||!e.docs||!Array.isArray(e.docs))return n(c.MISSING_BULK_DOCS);for(var r=0;r<e.docs.length;++r)if("object"!=typeof e.docs[r]||Array.isArray(e.docs[r]))return n(c.NOT_AN_OBJECT);return e=a.clone(e),"new_edits"in t||(t.new_edits="new_edits"in e?e.new_edits:!0),this._bulkDocs(e,t,this.autoCompact(n))}),s.prototype.registerDependentDatabase=a.adapterFun("registerDependentDatabase",function(e,t){function n(t){return t.dependentDbs=t.dependentDbs||{},t.dependentDbs[e]?!1:(t.dependentDbs[e]=!0,t)}var r=new this.constructor(e,{adapter:this._adapter});d(this,"_local/_pouch_dependentDbs",n,function(e){return e?t(e):t(null,{db:r})})})},{"./changes":6,"./deps/errors":11,"./deps/upsert":13,"./merge":18,"./utils":23,events:27}],2:[function(e,t){(function(n){"use strict";function r(e){for(var t=r.options,n=t.parser[t.strictMode?"strict":"loose"].exec(e),o={},i=14;i--;)o[t.key[i]]=n[i]||"";return o[t.q.name]={},o[t.key[12]].replace(t.q.parser,function(e,n,r){n&&(o[t.q.name][n]=r)}),o}function o(e){return/^_(design|local)/.test(e)?e:encodeURIComponent(e)}function i(e){return e._attachments&&Object.keys(e._attachments)?d.Promise.all(Object.keys(e._attachments).map(function(t){var r=e._attachments[t];if(r.data&&"string"!=typeof r.data){if(void 0===typeof n||n.browser)return new d.Promise(function(e){var t=new FileReader;t.onloadend=function(t){r.data=d.btoa(d.arrayBufferToBinaryString(t.target.result)),e()},t.readAsArrayBuffer(r.data)});r.data=r.data.toString("base64")}})):d.Promise.resolve()}function s(e,t){if(/http(s?):/.test(e)){var n=r(e);n.remote=!0,(n.user||n.password)&&(n.auth={username:n.user,password:n.password});var o=n.path.replace(/(^\/|\/$)/g,"").split("/");if(n.db=o.pop(),n.path=o.join("/"),t=t||{},t=d.clone(t),n.headers=t.headers||{},t.auth||n.auth){var i=t.auth||n.auth,s=d.btoa(i.username+":"+i.password);n.headers.Authorization="Basic "+s}return t.headers&&(n.headers=t.headers),n}return{host:"",path:"/",db:e,auth:!1}}function a(e,t){return u(e,e.db+"/"+t)}function u(e,t){if(e.remote){var n=e.path?"/":"";return e.protocol+"://"+e.host+":"+e.port+"/"+e.path+n+t}return"/"+t}function c(e,t){function n(e,t){return d.ajax(d.extend({},h,e),t)}var r=this;r.getHost=e.getHost?e.getHost:s;var c=r.getHost(e.name,e),p=a(c,"");r.getUrl=function(){return p},r.getHeaders=function(){return d.clone(c.headers)};var h=e.ajax||{};e=d.clone(e);var v=function(){n({headers:c.headers,method:"PUT",url:p},function(e){e&&401===e.status?n({headers:c.headers,method:"HEAD",url:p},function(e){e?t(e):t(null,r)}):e&&412!==e.status?t(e):t(null,r)})};e.skipSetup||n({headers:c.headers,method:"GET",url:p},function(e){e?404===e.status?v():t(e):t(null,r)}),r.type=function(){return"http"},r.id=d.adapterFun("id",function(e){n({headers:c.headers,method:"GET",url:u(c,"")},function(t,n){var r=n&&n.uuid?n.uuid+c.db:a(c,"");e(null,r)})}),r.request=d.adapterFun("request",function(e,t){e.headers=c.headers,e.url=a(c,e.url),n(e,t)}),r.compact=d.adapterFun("compact",function(e,t){"function"==typeof e&&(t=e,e={}),e=d.clone(e),n({headers:c.headers,url:a(c,"_compact"),method:"POST"},function(){function n(){r.info(function(r,o){o.compact_running?setTimeout(n,e.interval||200):t()})}"function"==typeof t&&n()})}),r._info=function(e){n({headers:c.headers,method:"GET",url:a(c,"")},function(t,n){t?e(t):(n.host=a(c,""),e(null,n))})},r.get=d.adapterFun("get",function(e,t,r){"function"==typeof t&&(r=t,t={}),t=d.clone(t),void 0===t.auto_encode&&(t.auto_encode=!0);var i=[];t.revs&&i.push("revs=true"),t.revs_info&&i.push("revs_info=true"),t.local_seq&&i.push("local_seq=true"),t.open_revs&&("all"!==t.open_revs&&(t.open_revs=JSON.stringify(t.open_revs)),i.push("open_revs="+t.open_revs)),t.attachments&&i.push("attachments=true"),t.rev&&i.push("rev="+t.rev),t.conflicts&&i.push("conflicts="+t.conflicts),i=i.join("&"),i=""===i?"":"?"+i,t.auto_encode&&(e=o(e));var s={headers:c.headers,method:"GET",url:a(c,e+i)},u=e.split("/");(u.length>1&&"_design"!==u[0]&&"_local"!==u[0]||u.length>2&&"_design"===u[0]&&"_local"!==u[0])&&(s.binary=!0),n(s,function(e,t,n){return e?r(e):void r(null,t,n)})}),r.remove=d.adapterFun("remove",function(e,t,r,i){var s;"string"==typeof t?(s={_id:e,_rev:t},"function"==typeof r&&(i=r,r={})):(s=e,"function"==typeof t?(i=t,r={}):(i=r,r=t));var u=s._rev||r.rev;n({headers:c.headers,method:"DELETE",url:a(c,o(s._id))+"?rev="+u},i)}),r.getAttachment=d.adapterFun("getAttachment",function(e,t,n,i){"function"==typeof n&&(i=n,n={}),n=d.clone(n),void 0===n.auto_encode&&(n.auto_encode=!0),n.auto_encode&&(e=o(e)),n.auto_encode=!1,r.get(e+"/"+t,n,i)}),r.removeAttachment=d.adapterFun("removeAttachment",function(e,t,r,i){n({headers:c.headers,method:"DELETE",url:a(c,o(e)+"/"+t)+"?rev="+r},i)}),r.putAttachment=d.adapterFun("putAttachment",function(e,t,r,i,s,u){"function"==typeof s&&(u=s,s=i,i=r,r=null),"undefined"==typeof s&&(s=i,i=r,r=null);var l=o(e)+"/"+t,f=a(c,l);r&&(f+="?rev="+r);var p={headers:d.clone(c.headers),method:"PUT",url:f,processData:!1,body:i,timeout:6e4};p.headers["Content-Type"]=s,n(p,u)}),r.put=d.adapterFun("put",d.getArguments(function(e){var t,r,s,u=e.shift(),l="_id"in u,p=e.pop();return"object"!=typeof u||Array.isArray(u)?p(f.NOT_AN_OBJECT):(u=d.clone(u),void i(u).then(function(){for(;;)if(t=e.shift(),r=typeof t,"string"!==r||l?"string"!==r||!l||"_rev"in u?"object"===r&&(s=d.clone(t)):u._rev=t:(u._id=t,l=!0),!e.length)break;s=s||{};var i=d.invalidIdError(u._id);if(i)throw i;var f=[];s&&"undefined"!=typeof s.new_edits&&f.push("new_edits="+s.new_edits),f=f.join("&"),""!==f&&(f="?"+f),n({headers:c.headers,method:"PUT",url:a(c,o(u._id))+f,body:u},function(e,t){return e?p(e):(t.ok=!0,void p(null,t))})})["catch"](p))})),r.post=d.adapterFun("post",function(e,t,n){return"function"==typeof t&&(n=t,t={}),t=d.clone(t),"object"!=typeof e?n(f.NOT_AN_OBJECT):("_id"in e||(e._id=d.uuid()),void r.put(e,t,function(e,t){return e?n(e):(t.ok=!0,void n(null,t))}))}),r._bulkDocs=function(e,t,r){"undefined"!=typeof t.new_edits&&(e.new_edits=t.new_edits),d.Promise.all(e.docs.map(i)).then(function(){n({headers:c.headers,method:"POST",url:a(c,"_bulk_docs"),body:e},function(e,t){return e?r(e):(t.forEach(function(e){e.ok=!0}),void r(null,t))})})["catch"](r)},r.allDocs=d.adapterFun("allDocs",function(e,t){"function"==typeof e&&(t=e,e={}),e=d.clone(e);var r,o=[],i="GET";if(e.conflicts&&o.push("conflicts=true"),e.descending&&o.push("descending=true"),e.include_docs&&o.push("include_docs=true"),e.key&&o.push("key="+encodeURIComponent(JSON.stringify(e.key))),e.startkey&&o.push("startkey="+encodeURIComponent(JSON.stringify(e.startkey))),e.endkey&&o.push("endkey="+encodeURIComponent(JSON.stringify(e.endkey))),"undefined"!=typeof e.inclusive_end&&o.push("inclusive_end="+!!e.inclusive_end),"undefined"!=typeof e.limit&&o.push("limit="+e.limit),"undefined"!=typeof e.skip&&o.push("skip="+e.skip),o=o.join("&"),""!==o&&(o="?"+o),"undefined"!=typeof e.keys){var s=2e3,u="keys="+encodeURIComponent(JSON.stringify(e.keys));u.length+o.length+1<=s?o+=(-1!==o.indexOf("?")?"&":"?")+u:(i="POST",r=JSON.stringify({keys:e.keys}))}n({headers:c.headers,method:i,url:a(c,"_all_docs"+o),body:r},t)}),r._changes=function(e){var t="batch_size"in e?e.batch_size:l;e=d.clone(e),e.timeout=e.timeout||3e4;var r={timeout:e.timeout-5e3},o="undefined"!=typeof e.limit?e.limit:!1;0===o&&(o=1);var i;i="returnDocs"in e?e.returnDocs:!0;var s=o;if(e.style&&(r.style=e.style),(e.include_docs||e.filter&&"function"==typeof e.filter)&&(r.include_docs=!0),e.continuous&&(r.feed="longpoll"),e.conflicts&&(r.conflicts=!0),e.descending&&(r.descending=!0),e.filter&&"string"==typeof e.filter&&(r.filter=e.filter,"_view"===e.filter&&e.view&&"string"==typeof e.view&&(r.view=e.view)),e.query_params&&"object"==typeof e.query_params)for(var u in e.query_params)e.query_params.hasOwnProperty(u)&&(r[u]=e.query_params[u]);var p,h,v=function(i,u){if(!e.aborted){r.since=i,e.descending?o&&(r.limit=s):r.limit=!o||s>t?t:s;var l="?"+Object.keys(r).map(function(e){return e+"="+r[e]}).join("&"),d={headers:c.headers,method:"GET",url:a(c,"_changes"+l),timeout:e.timeout};h=i,e.aborted||(p=n(d,u))}},m=10,_=0,y={results:[]},g=function(n,r){if(!e.aborted){var a=0;if(r&&r.results){a=r.results.length,y.last_seq=r.last_seq;var u={};u.query=e.query_params,r.results=r.results.filter(function(t){s--;var n=d.filterChange(e)(t);return n&&(i&&y.results.push(t),d.call(e.onChange,t)),n})}else if(n)return e.aborted=!0,void d.call(e.complete,n);r&&r.last_seq&&(h=r.last_seq);var c=o&&0>=s||r&&t>a||e.descending;if((!e.continuous||o&&0>=s)&&c)d.call(e.complete,null,y);else{n?_+=1:_=0;var l=1<<_,p=m*l,b=e.maximumWait||3e4;if(p>b)return void d.call(e.complete,n||f.UNKNOWN_ERROR);setTimeout(function(){v(h,g)},p)}}};return v(e.since||0,g),{cancel:function(){e.aborted=!0,p&&p.abort()}}},r.revsDiff=d.adapterFun("revsDiff",function(e,t,r){"function"==typeof t&&(r=t,t={}),n({headers:c.headers,method:"POST",url:a(c,"_revs_diff"),body:JSON.stringify(e)},r)}),r._close=function(e){e()},r.destroy=d.adapterFun("destroy",function(e){n({url:a(c,""),method:"DELETE",headers:c.headers},function(t,n){t?(r.emit("error",t),e(t)):(r.emit("destroyed"),e(null,n))})})}var l=25,d=e("../utils"),f=e("../deps/errors");r.options={strictMode:!1,key:["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],q:{name:"queryKey",parser:/(?:^|&)([^&=]*)=?([^&]*)/g},parser:{strict:/^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,loose:/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/}},c.destroy=d.toPromise(function(e,t,n){var r=s(e,t);t=t||{},"function"==typeof t&&(n=t,t={}),t=d.clone(t),t.headers=r.headers,t.method="DELETE",t.url=a(r,"");var o=t.ajax||{};t=d.extend({},t,o),d.ajax(t,n)}),c.valid=function(){return!0},t.exports=c}).call(this,e("/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))},{"../deps/errors":11,"../utils":23,"/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":28}],3:[function(e,t){(function(n,r){"use strict";function o(e,t,n){try{e.apply(t,n)}catch(r){window.PouchDB&&window.PouchDB.emit("error",r)}}function i(){if(!y.running&&y.queue.length){y.running=!0;var e=y.queue.shift();e.action(function(t,r){o(e.callback,this,[t,r]),y.running=!1,n.nextTick(i)})}}function s(e){return function(t){var n=t.target&&t.target.error&&t.target.error.name||t.target;e(v.error(v.IDB_ERROR,n,t.type))}}function a(){var e="_pouch__checkModernIdb_"+(r.navigator&&r.navigator.appVersion),t=p.hasLocalStorage()&&r.localStorage[e];if(t)return JSON.parse(t);var n="_pouch__checkModernIdb",o=null===r.indexedDB.open(n,1).onupgradeneeded;return r.indexedDB.deleteDatabase&&r.indexedDB.deleteDatabase(n),p.hasLocalStorage()&&(r.localStorage[e]=JSON.stringify(o)),o}function u(e,t,n){var r={data:m.stringify(e)};return r.winningRev=t,r.deletedOrLocal=n?"1":"0",r.id=e.id,r}function c(e){if(!e)return null;if(!e.data)return e;var t=m.parse(e.data);return t.winningRev=e.winningRev,t.deletedOrLocal="1"===e.deletedOrLocal,t}function l(e,t){var n=this;y.queue.push({action:function(t){d(n,e,t)},callback:t}),i()}function d(e,t,o){function i(e){e.createObjectStore(b,{keyPath:"id"}).createIndex("seq","seq",{unique:!0}),e.createObjectStore(w,{autoIncrement:!0}).createIndex("_doc_id_rev","_doc_id_rev",{unique:!0}),e.createObjectStore(E,{keyPath:"digest"}),e.createObjectStore(S,{keyPath:"id",autoIncrement:!1}),e.createObjectStore(x)}function a(e,t){var n=e.currentTarget.transaction,r=n.objectStore(b);r.createIndex("deletedOrLocal","deletedOrLocal",{unique:!1}),r.openCursor().onsuccess=function(e){var o=e.target.result;if(o){var i=o.value,s=p.isDeleted(i);i.deletedOrLocal=s?"1":"0",r.put(i),o["continue"]()}else t(n)}}function d(e){e.createObjectStore(k,{keyPath:"_id"}).createIndex("_doc_id_rev","_doc_id_rev",{unique:!0})}function f(e,t){t=t||e.currentTarget.transaction;var n=t.objectStore(k),o=t.objectStore(b),i=t.objectStore(w),s=o.openCursor();s.onsuccess=function(e){var t=e.target.result;if(t){var s=t.value,a=s.id,u=p.isLocalId(a),c=h.winningRev(s);if(u){var l=a+"::"+c,d=a+"::",f=a+"::~",v=i.index("_doc_id_rev"),m=r.IDBKeyRange.bound(d,f,!1,!1),_=v.openCursor(m);_.onsuccess=function(e){if(_=e.target.result){var r=_.value;r._doc_id_rev===l&&n.put(r),i["delete"](_.primaryKey),_["continue"]()}else o["delete"](t.primaryKey),t["continue"]()}}else t["continue"]()}}}function m(e,t,n){var o="startkey"in t?t.startkey:!1,i="endkey"in t?t.endkey:!1,s="key"in t?t.key:!1,a=t.skip||0,u="number"==typeof t.limit?t.limit:-1,l=t.inclusive_end!==!1,d="descending"in t&&t.descending?"prev":null,f=!1;d&&o&&i&&(f=i,i=!1);var m=null;try{o&&i?m=r.IDBKeyRange.bound(o,i,!1,!l):o?m=d?r.IDBKeyRange.upperBound(o):r.IDBKeyRange.lowerBound(o):i?m=d?r.IDBKeyRange.lowerBound(i,!l):r.IDBKeyRange.upperBound(i,!l):s&&(m=r.IDBKeyRange.only(s))}catch(_){return"DataError"===_.name&&0===_.code?n(null,{total_rows:e,offset:t.skip,rows:[]}):n(v.error(v.IDB_ERROR,_.name,_.message))}var y=L.transaction([b,w],"readonly");y.oncomplete=function(){n(null,{total_rows:e,offset:t.skip,rows:S})};var g=y.objectStore(b),E=d?g.openCursor(m,d):g.openCursor(m),S=[];E.onsuccess=function(e){function n(e,n){var o={id:e.id,key:e.id,value:{rev:i}};if(t.include_docs){o.doc=n,o.doc._rev=i,o.doc._doc_id_rev&&delete o.doc._doc_id_rev,t.conflicts&&(o.doc._conflicts=h.collectConflicts(e));for(var s in o.doc._attachments)o.doc._attachments.hasOwnProperty(s)&&(o.doc._attachments[s].stub=!0)}var c=p.isDeleted(e,i);if("ok"===t.deleted)c&&(o.value.deleted=!0,o.doc=null),S.push(o);else if(!c&&a--<=0){if(f){if(l&&o.key<f)return;if(!l&&o.key<=f)return}if(S.push(o),0===--u)return}r["continue"]()}if(e.target.result){var r=e.target.result,o=c(r.value),i=o.winningRev||h.winningRev(o);if(t.include_docs){var s=y.objectStore(w).index("_doc_id_rev"),d=o.id+"::"+i;s.get(d).onsuccess=function(e){n(c(r.value),e.target.result)}}else n(o)}}}function y(e){if(-1!==R)return e(null,R);var t,n=L.transaction([b],"readonly"),o=n.objectStore(b).index("deletedOrLocal");o.count(r.IDBKeyRange.only("0")).onsuccess=function(e){t=e.target.result},n.onerror=s(e),n.oncomplete=function(){R=t,e(null,R)}}var g=3,b="document-store",w="by-sequence",E="attach-store",S="meta-store",k="local-store",x="detect-blob-support",q=t.name,T=null,A=null,O=!1,L=null,R=-1;e.type=function(){return"idb"},e._id=p.toPromise(function(e){e(null,A)}),e._bulkDocs=function(t,n,r){function o(e){var t=e.target.result;t.updateSeq=(t.updateSeq||0)+M,j.objectStore(S).put(t)}function i(){++P===C.length&&(j.objectStore(S).get(S).onsuccess=o)}function a(){if(C.length){var t=new p.Map;C.forEach(function(n,r){if(n._id&&p.isLocalId(n._id))return void e[n._deleted?"_removeLocal":"_putLocal"](n,{ctx:j},function(e){F[r]=e?e:{},i()});var o=n.metadata.id;t.has(o)?t.get(o).push([n,r]):t.set(o,[[n,r]])}),t.forEach(function(e,t){function n(){i(),++o<e.length&&r()}function r(){var r=e[o],i=r[0],s=r[1];B.has(t)?g(B.get(t),i,s,n):x(i,s,n)}var o=0;r()})}}function d(e){function t(){++n===C.length&&e()}if(!C.length)return e();var n=0;C.forEach(function(e){if(e._id&&p.isLocalId(e._id))return t();var n=e.metadata.id,r=j.objectStore(b).get(n);r.onsuccess=function(e){var r=c(e.target.result);r&&B.set(n,r),t()}})}function f(){var e=F.map(function(e){if(e._bulk_seq)delete e._bulk_seq;else if(!Object.keys(e).length)return{ok:!0};if(e.error)return e;var t=e.metadata,n=h.winningRev(t);return{ok:!0,id:t.id,rev:n}});l.Changes.notify(q),R=-1,r(null,e)}function m(e,t){if(e.stub)return t();if("string"==typeof e.data){var n;try{n=atob(e.data)}catch(o){var i=v.error(v.BAD_ARG,"Attachments need to be base64 encoded");return r(i)}if(T){var s=e.content_type;n=p.fixBinary(n),e.data=p.createBlob([n],{type:s})}return void p.MD5(n).then(function(n){e.digest="md5-"+n,t()})}var a=new FileReader;a.onloadend=function(){var n=p.arrayBufferToBinaryString(this.result||"");T||(e.data=btoa(n)),p.MD5(n).then(function(n){e.digest="md5-"+n,t()})},a.readAsArrayBuffer(e.data)}function _(e){function t(){n++,C.length===n&&e()}if(!C.length)return e();var n=0;C.forEach(function(e){function n(){o++,o===r.length&&t()}var r=e.data&&e.data._attachments?Object.keys(e.data._attachments):[];if(!r.length)return t();var o=0;for(var i in e.data._attachments)e.data._attachments.hasOwnProperty(i)&&m(e.data._attachments[i],n)})}function y(e,t,n,r,o){function i(e){c||(e?(c=e,r(c)):l===d.length&&a())}function s(e){l++,i(e)}function a(){function i(i){var s=e.metadata;s.seq=i.target.result,delete s.rev;var a=u(s,t,n),c=j.objectStore(b).put(a);c.onsuccess=function(){delete s.deletedOrLocal,delete s.winningRev,F[o]=e,B.set(e.metadata.id,e.metadata),p.call(r)}}M++,e.data._doc_id_rev=e.data._id+"::"+e.data._rev;var s=j.objectStore(w),a=s.index("_doc_id_rev"),c=s.put(e.data);c.onsuccess=i,c.onerror=function(t){t.preventDefault(),t.stopPropagation();var n=a.getKey(e.data._doc_id_rev);n.onsuccess=function(t){var n=s.put(e.data,t.target.result);M--,n.onsuccess=i}}}var c=null,l=0;e.data._id=e.metadata.id,e.data._rev=e.metadata.rev,n&&(e.data._deleted=!0);var d=e.data._attachments?Object.keys(e.data._attachments):[];for(var f in e.data._attachments)if(e.data._attachments[f].stub)l++,i();else{var h=e.data._attachments[f].data;delete e.data._attachments[f].data;var v=e.data._attachments[f].digest;O(e,v,h,s)}d.length||a()}function g(e,t,n,r){var o=h.merge(e.rev_tree,t.metadata.rev_tree[0],1e3),i=p.isDeleted(e),s=p.isDeleted(t.metadata),a=i&&s&&I||!i&&I&&"new_leaf"!==o.conflicts;if(a)return F[n]=A(v.REV_CONFLICT,t._bulk_seq),r();t.metadata.rev_tree=o.tree;var u=h.winningRev(t.metadata);s=p.isDeleted(t.metadata,u),y(t,u,s,r,n)}function x(e,t,r){var o=h.winningRev(e.metadata),i=p.isDeleted(e.metadata,o);return"was_delete"in n&&i?(F[t]=v.MISSING_DOC,r()):void y(e,o,i,r,t)}function A(e,t){return e._bulk_seq=t,e}function O(e,t,n,r){var o=j.objectStore(E);o.get(t).onsuccess=function(i){var s=i.target.result&&i.target.result.refs||{},a=[e.metadata.id,e.metadata.rev].join("@"),u={digest:t,body:n,refs:s};u.refs[a]=!0,o.put(u).onsuccess=function(){p.call(r)}}}var I=n.new_edits,D=t.docs,C=D.map(function(e,t){if(e._id&&p.isLocalId(e._id))return e;var n=p.parseDoc(e,I);return n._bulk_seq=t,n}),N=C.filter(function(e){return e.error});if(N.length)return r(N[0]);var j,F=new Array(C.length),B=new p.Map,M=0,P=0;_(function(){var e=[b,w,E,S,k];j=L.transaction(e,"readwrite"),j.onerror=s(r),j.ontimeout=s(r),j.oncomplete=f,d(a)})},e._get=function(e,t,n){function r(){n(s,{doc:o,metadata:i,ctx:a})}var o,i,s,a;t=p.clone(t),a=t.ctx?t.ctx:L.transaction([b,w,E],"readonly"),a.objectStore(b).get(e).onsuccess=function(e){if(i=c(e.target.result),!i)return s=v.MISSING_DOC,r();if(p.isDeleted(i)&&!t.rev)return s=v.error(v.MISSING_DOC,"deleted"),r();var n=a.objectStore(w),u=t.rev||i.winningRev||h.winningRev(i),l=i.id+"::"+u;n.index("_doc_id_rev").get(l).onsuccess=function(e){return o=e.target.result,o&&o._doc_id_rev&&delete o._doc_id_rev,o?void r():(s=v.MISSING_DOC,r())}}},e._getAttachment=function(e,t,n){var r,o;t=p.clone(t),o=t.ctx?t.ctx:L.transaction([b,w,E],"readonly");var i=e.digest,s=e.content_type;o.objectStore(E).get(i).onsuccess=function(e){var o=e.target.result.body;if(t.encode)if(T){var i=new FileReader;i.onloadend=function(){var e=p.arrayBufferToBinaryString(this.result||"");r=btoa(e),n(null,r)},i.readAsArrayBuffer(o)}else r=o,n(null,r);else T?r=o||p.createBlob([""],{type:s}):(o=p.fixBinary(atob(o)),r=p.createBlob([o],{type:s})),n(null,r)}},e._allDocs=function(e,t){y(function(n,r){return n?t(n):0===e.limit?t(null,{total_rows:r,offset:e.skip,rows:[]}):void m(r,e,t)})},e._info=function(e){y(function(t,n){if(t)return e(t);if(null===L){var r=new Error("db isn't open");return r.id="idbNull",e(r)}var o=0,i=L.transaction([S],"readonly");i.objectStore(S).get(S).onsuccess=function(e){o=e.target.result&&e.target.result.updateSeq||0},i.oncomplete=function(){e(null,{doc_count:n,update_seq:o})}})},e._changes=function(t){function n(){v=L.transaction([b,w],"readonly"),v.oncomplete=i;var e;e=a?v.objectStore(w).openCursor(r.IDBKeyRange.lowerBound(t.since,!0),a):v.objectStore(w).openCursor(r.IDBKeyRange.lowerBound(t.since,!0)),e.onsuccess=o,e.onerror=onerror}function o(e){var n=e.target.result;if(n){var r=n.value;if(t.doc_ids&&-1===t.doc_ids.indexOf(r._id))return n["continue"]();var o=v.objectStore(b);o.get(r._id).onsuccess=function(e){var o=c(e.target.result);u<o.seq&&(u=o.seq);var i=o.winningRev||h.winningRev(o);if(r._rev!==i)return n["continue"]();delete r._doc_id_rev;var s=t.processChange(r,o,t);s.seq=n.key,y(s)&&(_++,f&&m.push(s),t.onChange(s)),_!==d&&n["continue"]()}}}function i(){t.continuous||t.complete(null,{results:m,last_seq:u})}if(t=p.clone(t),t.continuous){var s=q+":"+p.uuid();return l.Changes.addListener(q,s,e,t),l.Changes.notify(q),{cancel:function(){l.Changes.removeListener(q,s)}}}var a=t.descending?"prev":null,u=0;t.since=t.since&&!a?t.since:0;var d="limit"in t?t.limit:-1;0===d&&(d=1);var f;f="returnDocs"in t?t.returnDocs:!0;var v,m=[],_=0,y=p.filterChange(t);n()},e._close=function(e){return null===L?e(v.NOT_OPEN):(L.close(),delete _[q],L=null,void e())},e._getRevisionTree=function(e,t){var n=L.transaction([b],"readonly"),r=n.objectStore(b).get(e);r.onsuccess=function(e){var n=c(e.target.result);n?t(null,n.rev_tree):t(v.MISSING_DOC)}},e._doCompaction=function(e,t,n,r){var o=L.transaction([b,w],"readwrite"),i=o.objectStore(b);i.get(e).onsuccess=function(r){var i=c(r.target.result);i.rev_tree=t;var s=n.length;n.forEach(function(t){var n=o.objectStore(w).index("_doc_id_rev"),r=e+"::"+t;n.getKey(r).onsuccess=function(e){var t=e.target.result;if(t&&(o.objectStore(w)["delete"](t),s--,!s)){var n=i.winningRev||h.winningRev(i),r=i.deletedOrLocal;o.objectStore(b).put(u(i,n,r))}}})},o.oncomplete=function(){p.call(r)}},e._getLocal=function(e,t){var n=L.transaction([k],"readonly"),r=n.objectStore(k).get(e);r.onerror=s(t),r.onsuccess=function(e){var n=e.target.result;n?(delete n._doc_id_rev,t(null,n)):t(v.MISSING_DOC)}},e._putLocal=function(e,t,n){"function"==typeof t&&(n=t,t={}),delete e._revisions;var r=e._rev,o=e._id;e._rev=r?"0-"+(parseInt(r.split("-")[1],10)+1):"0-1",e._doc_id_rev=o+"::"+e._rev;var i,a=t.ctx;a||(a=L.transaction([k],"readwrite"),a.onerror=s(n),a.oncomplete=function(){i&&n(null,i)});var u,c=a.objectStore(k);if(r){var l=c.index("_doc_id_rev"),d=o+"::"+r;u=l.get(d),u.onsuccess=function(r){if(r.target.result){var o=c.put(e);o.onsuccess=function(){i={ok:!0,id:e._id,rev:e._rev},t.ctx&&n(null,i)}}else n(v.REV_CONFLICT)}}else u=c.get(o),u.onsuccess=function(r){if(r.target.result)n(v.REV_CONFLICT);
else{var o=c.put(e);o.onsuccess=function(){i={ok:!0,id:e._id,rev:e._rev},t.ctx&&n(null,i)}}}},e._removeLocal=function(e,t){var n,r=L.transaction([k],"readwrite");r.oncomplete=function(){n&&t(null,n)};var o=e._id+"::"+e._rev,i=r.objectStore(k),a=i.index("_doc_id_rev"),u=a.get(o);u.onerror=s(t),u.onsuccess=function(e){var r=e.target.result;if(r){var s=a.getKey(o);s.onsuccess=function(e){var t=e.target.result;i["delete"](t),n={ok:!0,id:r._id,rev:"0-0"}}}else t(v.MISSING_DOC)}};var I=_[q];if(I)return L=I.idb,T=I.blobSupport,A=I.instanceId,O=I.idStored,void n.nextTick(function(){o(null,e)});var D=r.indexedDB.open(q,g);"openReqList"in l||(l.openReqList={}),l.openReqList[q]=D,D.onupgradeneeded=function(e){var t=e.target.result;e.oldVersion<1&&i(t),e.oldVersion<3&&(d(t),e.oldVersion<2?a(e,function(t){f(e,t)}):f(e))},D.onsuccess=function(t){L=t.target.result,L.onversionchange=function(){L.close(),delete _[q]},L.onabort=function(){L.close(),delete _[q]};var n=L.transaction([S,x],"readwrite"),r=n.objectStore(S).get(S);r.onsuccess=function(t){var r=function(){null!==T&&O&&(_[q]={idb:L,blobSupport:T,instanceId:A,idStored:O,loaded:!0},o(null,e))},i=t.target.result||{id:S};q+"_id"in i?(A=i[q+"_id"],O=!0,r()):(A=p.uuid(),i[q+"_id"]=A,n.objectStore(S).put(i).onsuccess=function(){O=!0,r()});try{var s=p.createBlob([""],{type:"image/png"});n.objectStore(x).put(s,"key"),n.oncomplete=function(){n=L.transaction([S,x],"readwrite");var e=n.objectStore(x).get("key");e.onsuccess=function(e){var t=e.target.result,n=URL.createObjectURL(t);p.ajax({url:n,cache:!0,binary:!0},function(e,t){T=e&&405===e.status?!0:!(!t||"image/png"!==t.type),r()})}}}catch(a){T=!1,r()}}},D.onerror=s(o)}function f(e,t,n){"openReqList"in l||(l.openReqList={}),l.Changes.removeAllListeners(e),l.openReqList[e]&&l.openReqList[e].result&&l.openReqList[e].result.close();var o=r.indexedDB.deleteDatabase(e);o.onsuccess=function(){l.openReqList[e]&&(l.openReqList[e]=null),p.hasLocalStorage()&&e in r.localStorage&&delete r.localStorage[e],delete _[e],n(null,{ok:!0})},o.onerror=s(n)}var p=e("../utils"),h=e("../merge"),v=e("../deps/errors"),m=e("vuvuzela"),_={},y={running:!1,queue:[]};l.valid=function(){return r.indexedDB&&a()},l.destroy=p.toPromise(function(e,t,n){y.queue.push({action:function(n){f(e,t,n)},callback:n}),i()}),l.Changes=new p.Changes,t.exports=l}).call(this,e("/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../deps/errors":11,"../merge":18,"../utils":23,"/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":28,vuvuzela:57}],4:[function(e,t){t.exports=["idb","websql"]},{}],5:[function(e,t){(function(n){"use strict";function r(e){return"'"+e+"'"}function o(e,t,n,r,o){return"SELECT "+e+" FROM "+("string"==typeof t?t:t.join(" JOIN "))+(n?" ON "+n:"")+(r?" WHERE "+("string"==typeof r?r:r.join(" AND ")):"")+(o?" ORDER BY "+o:"")}function i(e){return function(t){var n=t&&t.constructor.toString().match(/function ([^\(]+)/),r=n&&n[1]||t.type,o=t.target||t.message;e(h.error(h.WSQ_ERROR,o,r))}}function s(e){return decodeURIComponent(window.escape(e))}function a(e,t){for(var n="",r="UTF-8"===t?2:4,o=0,i=e.length;i>o;o+=r){var a=e.substring(o,o+r);4===r&&(a=a.substring(2,4)+a.substring(0,2)),n+=String.fromCharCode(parseInt(a,16))}return n="UTF-8"===t?s(n):n}function u(e){return delete e._id,delete e._rev,JSON.stringify(e)}function c(e,t,n){return e=JSON.parse(e),e._id=t,e._rev=n,e}function l(e){if("size"in e)return 1e6*e.size;var t=/Android/.test(window.navigator.userAgent);return t?5e6:1}function d(e,t){function r(){f.hasLocalStorage()&&(n.localStorage["_pouch__websqldb_"+M]=!0),t(null,F)}function s(e,t){e.executeSql(T),e.executeSql("ALTER TABLE "+w+" ADD COLUMN deleted TINYINT(1) DEFAULT 0",[],function(){e.executeSql(x),e.executeSql("ALTER TABLE "+b+" ADD COLUMN local TINYINT(1) DEFAULT 0",[],function(){e.executeSql("CREATE INDEX IF NOT EXISTS 'doc-store-local-idx' ON "+b+" (local, id)");var n="SELECT "+b+".winningseq AS seq, "+b+".json AS metadata FROM "+w+" JOIN "+b+" ON "+w+".seq = "+b+".winningseq";e.executeSql(n,[],function(e,n){for(var r=[],o=[],i=0;i<n.rows.length;i++){var s=n.rows.item(i),a=s.seq,u=JSON.parse(s.metadata);f.isDeleted(u)&&r.push(a),f.isLocalId(u.id)&&o.push(u.id)}e.executeSql("UPDATE "+b+"SET local = 1 WHERE id IN ("+o.map(function(){return"?"}).join(",")+")",o,function(){e.executeSql("UPDATE "+w+" SET deleted = 1 WHERE seq IN ("+r.map(function(){return"?"}).join(",")+")",r,t)})})})})}function m(e,t){var n="CREATE TABLE IF NOT EXISTS "+S+" (id UNIQUE, rev, json)";e.executeSql(n,[],function(){var n="SELECT "+b+".id AS id, "+w+".json AS data FROM "+w+" JOIN "+b+" ON "+w+".seq = "+b+".winningseq WHERE local = 1";e.executeSql(n,[],function(e,n){function r(){if(!o.length)return t();var n=o.shift(),i=JSON.parse(n.data)._rev;e.executeSql("INSERT INTO "+S+" (id, rev, json) VALUES (?,?,?)",[n.id,i,n.data],function(e){e.executeSql("DELETE FROM "+b+" WHERE id=?",[n.id],function(e){e.executeSql("DELETE FROM "+w+" WHERE seq=?",[n.seq],function(){r()})})})}for(var o=[],i=0;i<n.rows.length;i++)o.push(n.rows.item(i));r()})})}function L(e,t){function n(n,r){function o(){if(!n.length)return t();var i=n.shift(),s=a(i.hex,r),u=s.lastIndexOf("::"),c=s.substring(0,u),l=s.substring(u+2),d="UPDATE "+w+" SET doc_id=?, rev=? WHERE doc_id_rev=?";e.executeSql(d,[c,l,s],function(){o()})}o()}var r="ALTER TABLE "+w+" ADD COLUMN doc_id";e.executeSql(r,[],function(e){var t="ALTER TABLE "+w+" ADD COLUMN rev";e.executeSql(t,[],function(e){e.executeSql(q,[],function(e){var t="SELECT hex(doc_id_rev) as hex FROM "+w;e.executeSql(t,[],function(e,t){for(var r=[],o=0;o<t.rows.length;o++)r.push(t.rows.item(o));e.executeSql("SELECT dbid, hex(dbid) AS hexId FROM "+k,[],function(e,t){var o=t.rows.item(0).dbid,i=t.rows.item(0).hexId,s=i.length===2*o.length?"UTF-8":"UTF-16";n(r,s)})})})})})}function R(e){for(;U.length>0;){var t=U.pop();t(null,B)}I(e)}function I(e){e.executeSql("SELECT dbid, hex(dbid) AS hexId FROM "+k,[],function(e,t){var n=t.rows.item(0).dbid,r=t.rows.item(0).hexId;j=r.length===2*n.length?"UTF-8":"UTF-16"})}function D(e,t){if(0===t){var n="CREATE TABLE IF NOT EXISTS "+k+" (update_seq INTEGER, dbid, db_version INTEGER)",r="CREATE TABLE IF NOT EXISTS "+E+" (digest, json, body BLOB)",o="CREATE TABLE IF NOT EXISTS "+b+" (id unique, json, winningseq)",i="CREATE TABLE IF NOT EXISTS "+w+" (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, json, deleted TINYINT(1), doc_id, rev)",a="CREATE TABLE IF NOT EXISTS "+S+" (id UNIQUE, rev, json)";e.executeSql(r),e.executeSql(a),e.executeSql(o,[],function(){e.executeSql(T),e.executeSql(i,[],function(){e.executeSql(x),e.executeSql(q),e.executeSql(n,[],function(){var t="INSERT INTO "+k+" (update_seq, db_version, dbid) VALUES (?, ?, ?)";B=f.uuid();var n=[0,g,B];e.executeSql(t,n,function(e){R(e)})})})})}else{var u=function(){var n=g>t;n&&e.executeSql("UPDATE "+k+" SET db_version = "+g);var r="SELECT dbid FROM "+k;e.executeSql(r,[],function(e,t){B=t.rows.item(0).dbid,R(e)})};switch(t){case 1:s(e,function(){m(e,function(){L(e,u)})});break;case 2:m(e,function(){L(e,u)});break;case 3:L(e,u);break;default:u()}}}function C(){J.transaction(function(e){e.executeSql("SELECT sql FROM sqlite_master WHERE tbl_name = "+k,[],function(e,t){t.rows.length?/db_version/.test(t.rows.item(0).sql)?e.executeSql("SELECT db_version FROM "+k,[],function(e,t){var n=t.rows.item(0).db_version;D(e,n)}):e.executeSql("ALTER TABLE "+k+" ADD COLUMN db_version INTEGER",[],function(){D(e,1)}):D(e,0)})},i(t),r)}function N(e,t){if(-1!==G)return t(G);var n=o("COUNT("+b+".id) AS 'num'",[b,w],A,w+".deleted=0");e.executeSql(n,[],function(e,n){G=n.rows.item(0).num,t(G)})}var j,F=this,B=null,M=e.name,P=l(e),U=[],G=-1,J=_(M,y,M,P);return J?("function"!=typeof J.readTransaction&&(J.readTransaction=J.transaction),f.isCordova()&&"undefined"!=typeof n?n.addEventListener(M+"_pouch",function V(){n.removeEventListener(M+"_pouch",V,!1),C()},!1):C(),F.type=function(){return"websql"},F._id=f.toPromise(function(e){e(null,B)}),F._info=function(e){J.readTransaction(function(t){N(t,function(n){var r="SELECT update_seq FROM "+k;t.executeSql(r,[],function(t,r){var o=r.rows.item(0).update_seq;e(null,{doc_count:n,update_seq:o})})})},i(e))},F._bulkDocs=function(e,t,n){function r(){var e=R.map(function(e){if(e._bulk_seq)delete e._bulk_seq;else if(!Object.keys(e).length)return{ok:!0};if(e.error)return e;var t=e.metadata,n=p.winningRev(t);return{ok:!0,id:t.id,rev:n}});d.Changes.notify(M);var t="SELECT update_seq FROM "+k;L.executeSql(t,[],function(t,r){var o=r.rows.item(0).update_seq+I,i="UPDATE "+k+" SET update_seq=?";t.executeSql(i,[o],function(){n(null,e)})})}function s(e,t){if(e.stub)return t();if("string"==typeof e.data){try{e.data=atob(e.data)}catch(r){var o=h.error(h.BAD_ARG,"Attachments need to be base64 encoded");return n(o)}var i=f.fixBinary(e.data);e.data=f.createBlob([i],{type:e.content_type})}var s=new FileReader;s.onloadend=function(){var n=f.arrayBufferToBinaryString(this.result);e.data=n,f.MD5(n).then(function(n){e.digest="md5-"+n,t()})},s.readAsArrayBuffer(e.data)}function a(e){function t(){n++,A.length===n&&e()}if(!A.length)return e();var n=0;A.forEach(function(e){function n(){o++,o===r.length&&t()}var r=e.data&&e.data._attachments?Object.keys(e.data._attachments):[],o=0;if(!r.length)return t();for(var i in e.data._attachments)e.data._attachments.hasOwnProperty(i)&&s(e.data._attachments[i],n)})}function c(e,t,n,r,i,s){function a(){I++;var t=e.data,r=n?1:0,i=t._id,s=t._rev,a=u(t),c="INSERT INTO "+w+" (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);",l=[i,s,a,r];L.executeSql(c,l,function(e,t){d(e,t.insertId)},function(){var e=o("seq",w,null,"doc_id=? AND rev=?");return L.executeSql(e,[i,s],function(e,t){var n=t.rows.item(0).seq,o="UPDATE "+w+" SET json=?, deleted=? WHERE doc_id=? AND rev=?;",u=[a,r,i,s];e.executeSql(o,u,function(e){I--,d(e,n)})}),!1})}function c(e){f||(e?(f=e,r(f)):p===h.length&&a())}function l(e){p++,c(e)}function d(n,o){e.metadata.seq=o,delete e.metadata.rev;var a=i?"UPDATE "+b+" SET json=?, winningseq=(SELECT seq FROM "+w+" WHERE doc_id="+b+".id AND rev=?) WHERE id=?":"INSERT INTO "+b+" (id, winningseq, json) VALUES (?, ?, ?);",u=v.stringify(e.metadata),c=e.metadata.id,l=i?[u,t,c]:[c,o,u];n.executeSql(a,l,function(){R[s]=e,D.set(c,e.metadata),r()})}var f=null,p=0;e.data._id=e.metadata.id,e.data._rev=e.metadata.rev,n&&(e.data._deleted=!0);var h=e.data._attachments?Object.keys(e.data._attachments):[];for(var m in e.data._attachments)if(e.data._attachments[m].stub)p++,c();else{var _=e.data._attachments[m].data;delete e.data._attachments[m].data;var y=e.data._attachments[m].digest;x(e,y,_,l)}h.length||a()}function l(e,t,n,r){var o=p.merge(e.rev_tree,t.metadata.rev_tree[0],1e3),i=f.isDeleted(t.metadata),s=f.isDeleted(e),a=s&&i&&q||!s&&q&&"new_leaf"!==o.conflicts;if(a)return R[n]=S(h.REV_CONFLICT,t._bulk_seq),r();t.metadata.rev_tree=o.tree;var u=p.winningRev(t.metadata);i=f.isDeleted(t.metadata,u),c(t,u,i,r,!0,n)}function m(e,n,r){var o=p.winningRev(e.metadata),i=f.isDeleted(e.metadata,o);return"was_delete"in t&&i?(R[n]=h.MISSING_DOC,r()):void c(e,o,i,r,!1,n)}function _(){++C===A.length&&r()}function y(){if(!A.length)return r();var e=new f.Map;A.forEach(function(t,n){if(t._id&&f.isLocalId(t._id))return void F[t._deleted?"_removeLocal":"_putLocal"](t,{ctx:L},function(e){R[n]=e?e:{},_()});var r=t.metadata.id;e.has(r)?e.get(r).push([t,n]):e.set(r,[[t,n]])}),e.forEach(function(e,t){function n(){_(),++o<e.length&&r()}function r(){var r=e[o],i=r[0],s=r[1];D.has(t)?l(D.get(t),i,s,n):m(i,s,n)}var o=0;r()})}function g(e){function t(){++n===A.length&&e()}if(!A.length)return e();var n=0;A.forEach(function(e){if(e._id&&f.isLocalId(e._id))return t();var n=e.metadata.id;L.executeSql("SELECT json FROM "+b+" WHERE id = ?",[n],function(e,r){if(r.rows.length){var o=v.parse(r.rows.item(0).json);D.set(n,o)}t()})})}function S(e,t){return e._bulk_seq=t,e}function x(e,t,n,r){var o=[e.metadata.id,e.metadata.rev].join("@"),i={digest:t},s="SELECT digest, json FROM "+E+" WHERE digest=?";L.executeSql(s,[t],function(e,a){a.rows.length?(i.refs=JSON.parse(a.rows.item(0).json).refs,s="UPDATE "+E+" SET json=?, body=? WHERE digest=?",e.executeSql(s,[JSON.stringify(i),n,t],function(){r()})):(i.refs={},i.refs[o]=!0,s="INSERT INTO "+E+"(digest, json, body) VALUES (?, ?, ?)",e.executeSql(s,[t,JSON.stringify(i),n],function(){r()}))})}var q=t.new_edits,T=e.docs,A=T.map(function(e,t){if(e._id&&f.isLocalId(e._id))return e;var n=f.parseDoc(e,q);return n._bulk_seq=t,n}),O=A.filter(function(e){return e.error});if(O.length)return n(O[0]);var L,R=new Array(A.length),I=0,D=new f.Map,C=0;a(function(){J.transaction(function(e){L=e,g(y)},i(n),function(){G=-1})})},F._get=function(e,t,n){function r(){n(a,{doc:i,metadata:s,ctx:d})}t=f.clone(t);var i,s,a;if(!t.ctx)return void J.readTransaction(function(r){t.ctx=r,F._get(e,t,n)});var u,l,d=t.ctx;t.rev?(u=o(O,[b,w],b+".id="+w+".doc_id",[w+".doc_id=?",w+".rev=?"]),l=[e,t.rev]):(u=o(O,[b,w],A,b+".id=?"),l=[e]),d.executeSql(u,l,function(e,n){if(!n.rows.length)return a=h.MISSING_DOC,r();var o=n.rows.item(0);return s=v.parse(o.metadata),o.deleted&&!t.rev?(a=h.error(h.MISSING_DOC,"deleted"),r()):(i=c(o.data,s.id,o.rev),void r())})},F._allDocs=function(e,t){var n,r=[],s="startkey"in e?e.startkey:!1,a="endkey"in e?e.endkey:!1,u="key"in e?e.key:!1,l="descending"in e?e.descending:!1,d="limit"in e?e.limit:-1,f="skip"in e?e.skip:0,h=e.inclusive_end!==!1,m=[],_=[];if(u!==!1)_.push(b+".id = ?"),m.push(u);else if(s!==!1||a!==!1){if(s!==!1&&(_.push(b+".id "+(l?"<=":">=")+" ?"),m.push(s)),a!==!1){var y=l?">":"<";h&&(y+="="),_.push(b+".id "+y+" ?"),m.push(a)}u!==!1&&(_.push(b+".id = ?"),m.push(u))}"ok"!==e.deleted&&_.push(w+".deleted = 0"),J.readTransaction(function(t){N(t,function(i){if(n=i,0!==d){var s=o(O,[b,w],A,_,b+".id "+(l?"DESC":"ASC"));s+=" LIMIT "+d+" OFFSET "+f,t.executeSql(s,m,function(t,n){for(var o=0,i=n.rows.length;i>o;o++){var s=n.rows.item(o),a=v.parse(s.metadata),u=c(s.data,a.id,s.rev),l=u._rev,d={id:a.id,key:a.id,value:{rev:l}};if(e.include_docs){d.doc=u,d.doc._rev=l,e.conflicts&&(d.doc._conflicts=p.collectConflicts(a));for(var f in d.doc._attachments)d.doc._attachments.hasOwnProperty(f)&&(d.doc._attachments[f].stub=!0)}if(s.deleted){if("ok"!==e.deleted)continue;d.value.deleted=!0,d.doc=null}r.push(d)}})}})},i(t),function(){t(null,{total_rows:n,offset:e.skip,rows:r})})},F._changes=function(e){function t(){var t=[b+".winningseq > "+e.since],n=[];e.doc_ids&&(t.push(b+".id IN ("+e.doc_ids.map(function(){return"?"}).join(",")+")"),n=e.doc_ids);var l=o(O,[b,w],A,t,b+".winningseq "+(r?"DESC":"ASC")),d=f.filterChange(e);e.view||e.filter||(l+=" LIMIT "+i),J.readTransaction(function(t){t.executeSql(l,n,function(t,n){for(var r=0,o=0,l=n.rows.length;l>o;o++){var f=n.rows.item(o),p=v.parse(f.metadata);r<f.seq&&(r=f.seq);var h=c(f.data,p.id,f.rev),m=e.processChange(h,p,e);if(m.seq=f.seq,d(m)&&(u++,s&&a.push(m),e.onChange(m)),u===i)break}e.continuous||e.complete(null,{results:a,last_seq:r})})})}if(e=f.clone(e),e.continuous){var n=M+":"+f.uuid();return d.Changes.addListener(M,n,F,e),d.Changes.notify(M),{cancel:function(){d.Changes.removeListener(M,n)}}}var r=e.descending;e.since=e.since&&!r?e.since:0;var i="limit"in e?e.limit:-1;0===i&&(i=1);var s;s="returnDocs"in e?e.returnDocs:!0;var a=[],u=0;t()},F._close=function(e){e()},F._getAttachment=function(e,t,n){var r,o=t.ctx,i=e.digest,s=e.content_type,u="SELECT hex(body) as body FROM "+E+" WHERE digest=?";o.executeSql(u,[i],function(e,o){var i=a(o.rows.item(0).body,j);t.encode?r=btoa(i):(i=f.fixBinary(i),r=f.createBlob([i],{type:s})),n(null,r)})},F._getRevisionTree=function(e,t){J.readTransaction(function(n){var r="SELECT json AS metadata FROM "+b+" WHERE id = ?";n.executeSql(r,[e],function(e,n){if(n.rows.length){var r=v.parse(n.rows.item(0).metadata);t(null,r.rev_tree)}else t(h.MISSING_DOC)})})},F._doCompaction=function(e,t,n,r){return n.length?void J.transaction(function(o){var i="SELECT json AS metadata FROM "+b+" WHERE id = ?";o.executeSql(i,[e],function(o,i){if(!i.rows.length)return f.call(r);var s=v.parse(i.rows.item(0).metadata);s.rev_tree=t;var a=0;n.forEach(function(t){var i="DELETE FROM "+w+" WHERE doc_id=? AND rev=?";o.executeSql(i,[e,t],function(t){if(++a===n.length){var o="UPDATE "+b+" SET json = ? WHERE id = ?";t.executeSql(o,[v.stringify(s),e],function(){r()})}})})})}):r()},F._getLocal=function(e,t){J.readTransaction(function(n){var r="SELECT json, rev FROM "+S+" WHERE id=?";n.executeSql(r,[e],function(n,r){if(r.rows.length){var o=r.rows.item(0),i=c(o.json,e,o.rev);t(null,i)}else t(h.MISSING_DOC)})})},F._putLocal=function(e,t,n){function r(e){var r,i;s?(r="UPDATE "+S+" SET rev=?, json=? WHERE id=? AND rev=?",i=[o,l,a,s]):(r="INSERT INTO "+S+" (id, rev, json) VALUES (?,?,?)",i=[a,o,l]),e.executeSql(r,i,function(e,r){r.rowsAffected?(c={ok:!0,id:a,rev:o},t.ctx&&n(null,c)):n(h.REV_CONFLICT)},function(){return n(h.REV_CONFLICT),!1})}"function"==typeof t&&(n=t,t={}),delete e._revisions;var o,s=e._rev,a=e._id;o=e._rev=s?"0-"+(parseInt(s.split("-")[1],10)+1):"0-1";var c,l=u(e);t.ctx?r(t.ctx):J.transaction(function(e){r(e)},i(n),function(){c&&n(null,c)})},void(F._removeLocal=function(e,t){var n;J.transaction(function(r){var o="DELETE FROM "+S+" WHERE id=? AND rev=?",i=[e._id,e._rev];r.executeSql(o,i,function(r,o){return o.rowsAffected?void(n={ok:!0,id:e._id,rev:"0-0"}):t(h.REV_CONFLICT)})},i(t),function(){t(null,n)})})):t(h.UNKNOWN_ERROR)}var f=e("../utils"),p=e("../merge"),h=e("../deps/errors"),v=e("vuvuzela"),m={},_=f.getArguments(function(e){if("undefined"!=typeof n){if(n.navigator&&n.navigator.sqlitePlugin&&n.navigator.sqlitePlugin.openDatabase)return navigator.sqlitePlugin.openDatabase.apply(navigator.sqlitePlugin,e);if(n.sqlitePlugin&&n.sqlitePlugin.openDatabase)return n.sqlitePlugin.openDatabase.apply(n.sqlitePlugin,e);var t=m[e[0]];return t||(t=m[e[0]]=n.openDatabase.apply(n,e)),t}}),y=1,g=4,b=r("document-store"),w=r("by-sequence"),E=r("attach-store"),S=r("local-store"),k=r("metadata-store"),x="CREATE INDEX IF NOT EXISTS 'by-seq-deleted-idx' ON "+w+" (seq, deleted)",q="CREATE UNIQUE INDEX IF NOT EXISTS 'by-seq-doc-id-rev' ON "+w+" (doc_id, rev)",T="CREATE INDEX IF NOT EXISTS 'doc-winningseq-idx' ON "+b+" (winningseq)",A=w+".seq = "+b+".winningseq",O=w+".seq AS seq, "+w+".deleted AS deleted, "+w+".json AS data, "+w+".rev AS rev, "+b+".json AS metadata";d.valid=function(){if("undefined"!=typeof n){if(n.navigator&&n.navigator.sqlitePlugin&&n.navigator.sqlitePlugin.openDatabase)return!0;if(n.sqlitePlugin&&n.sqlitePlugin.openDatabase)return!0;if(n.openDatabase)return!0}return!1},d.destroy=f.toPromise(function(e,t,r){d.Changes.removeAllListeners(e);var o=l(t),s=_(e,y,e,o);s.transaction(function(e){var t=[b,w,E,k,S];t.forEach(function(t){e.executeSql("DROP TABLE IF EXISTS "+t,[])})},i(r),function(){f.hasLocalStorage()&&(delete n.localStorage["_pouch__websqldb_"+e],delete n.localStorage[e]),r(null,{ok:!0})})}),d.Changes=new f.Changes,t.exports=d}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../deps/errors":11,"../merge":18,"../utils":23,vuvuzela:57}],6:[function(e,t){"use strict";function n(e,t,n){function r(){i.cancel()}a.call(this);var i=this;this.db=e,t=t?o.clone(t):{};var s=n||t.complete||function(){},u=t.complete=o.once(function(t,n){t?i.emit("error",t):i.emit("complete",n),i.removeAllListeners(),e.removeListener("destroyed",r)});s&&(i.on("complete",function(e){s(null,e)}),i.on("error",function(e){s(e)}));var c=t.onChange;c&&i.on("change",c),e.once("destroyed",r),t.onChange=function(e){t.isCancelled||(i.emit("change",e),i.startSeq&&i.startSeq<=e.seq&&(i.emit("uptodate"),i.startSeq=!1),e.deleted?i.emit("delete",e):1===e.changes.length&&"1-"===e.changes[0].rev.slice(0,2)?i.emit("create",e):i.emit("update",e))};var l=new o.Promise(function(e,n){t.complete=function(t,r){t?n(t):e(r)}});i.once("cancel",function(){c&&i.removeListener("change",c),t.complete(null,{status:"cancelled"})}),this.then=l.then.bind(l),this["catch"]=l["catch"].bind(l),this.then(function(e){u(null,e)},u),e.taskqueue.isReady?i.doChanges(t):e.taskqueue.addTask(function(){i.isCancelled?i.emit("cancel"):i.doChanges(t)})}function r(e,t,n){var r=[{rev:e._rev}];"all_docs"===n.style&&(r=i.collectLeaves(t.rev_tree).map(function(e){return{rev:e.rev}}));var s={id:t.id,changes:r,doc:e};return o.isDeleted(t,e._rev)&&(s.deleted=!0),n.conflicts&&(s.doc._conflicts=i.collectConflicts(t),s.doc._conflicts.length||delete s.doc._conflicts),s}var o=e("./utils"),i=e("./merge"),s=e("./deps/errors"),a=e("events").EventEmitter,u=e("./evalFilter"),c=e("./evalView");t.exports=n,o.inherits(n,a),n.prototype.cancel=function(){this.isCancelled=!0,this.db.taskqueue.isReady&&this.emit("cancel")},n.prototype.doChanges=function(e){var t=this,n=e.complete;if(e=o.clone(e),"live"in e&&!("continuous"in e)&&(e.continuous=e.live),e.processChange=r,"latest"===e.since&&(e.since="now"),e.since||(e.since=0),"now"===e.since)return void this.db.info().then(function(r){return t.isCancelled?void n(null,{status:"cancelled"}):(e.since=r.update_seq-1,void t.doChanges(e))},n);if(e.continuous&&"now"!==e.since&&this.db.info().then(function(e){t.startSeq=e.update_seq-1},function(e){if("idbNull"!==e.id)throw e}),"http"!==this.db.type()&&e.filter&&"string"==typeof e.filter)return this.filterChanges(e);"descending"in e||(e.descending=!1),e.limit=0===e.limit?1:e.limit,e.complete=n;var i=this.db._changes(e);if(i&&"function"==typeof i.cancel){var s=t.cancel;t.cancel=o.getArguments(function(e){i.cancel(),s.apply(this,e)})}},n.prototype.filterChanges=function(e){var t=this,n=e.complete;if("_view"===e.filter){if(!e.view||"string"!=typeof e.view){var r=new Error("`view` filter parameter is not provided.");return r.status=s.BAD_REQUEST.status,r.name=s.BAD_REQUEST.name,r.error=!0,void n(r)}var o=e.view.split("/");this.db.get("_design/"+o[0],function(r,i){if(t.isCancelled)return void n(null,{status:"cancelled"});if(r)return void n(r);if(i&&i.views&&i.views[o[1]]){var a=c(i.views[o[1]].map);return e.filter=a,void t.doChanges(e)}var u=i.views?"missing json key: "+o[1]:"missing json key: views";r||(r=new Error(u),r.status=s.MISSING_DOC.status,r.name=s.MISSING_DOC.name,r.error=!0),n(r)})}else{var i=e.filter.split("/");this.db.get("_design/"+i[0],function(r,o){if(t.isCancelled)return void n(null,{status:"cancelled"});if(r)return void n(r);if(o&&o.filters&&o.filters[i[1]]){var a=u(o.filters[i[1]]);return e.filter=a,void t.doChanges(e)}var c=o&&o.filters?"missing json key: "+i[1]:"missing json key: filters";return r||(r=new Error(c),r.status=s.MISSING_DOC.status,r.name=s.MISSING_DOC.name,r.error=!0),void n(r)})}}},{"./deps/errors":11,"./evalFilter":15,"./evalView":16,"./merge":18,"./utils":23,events:27}],7:[function(e,t){(function(n){"use strict";function r(e){e&&n.debug&&console.error(e)}function o(e,t,n){if(!(this instanceof o))return new o(e,t,n);var c=this;("function"==typeof t||"undefined"==typeof t)&&(n=t,t={}),e&&"object"==typeof e&&(t=e,e=void 0),"undefined"==typeof n&&(n=r),t=t||{};var l=n;c.auto_compaction=t.auto_compaction,c.prefix=o.prefix,i.call(c),c.taskqueue=new a;var d=new u(function(r,i){n=function(e,t){return e?i(e):(delete t.then,void r(t))},t=s.clone(t);var a,u,l=t.name||e;return function(){try{if("string"!=typeof l)throw u=new Error("Missing/invalid DB name"),u.code=400,u;if(a=o.parseAdapter(l,t),t.originalName=l,t.name=a.name,t.prefix&&"http"!==a.adapter&&"https"!==a.adapter&&(t.name=t.prefix+t.name),t.adapter=t.adapter||a.adapter,c._adapter=t.adapter,c._db_name=l,!o.adapters[t.adapter])throw u=new Error("Adapter is missing"),u.code=404,u;if(!o.adapters[t.adapter].valid())throw u=new Error("Invalid Adapter"),u.code=404,u}catch(e){c.taskqueue.fail(e),c.changes=s.toPromise(function(t){t.complete&&t.complete(e)})}}(),u?i(u):(c.adapter=t.adapter,c.replicate={},c.replicate.from=function(e,t,n){return c.constructor.replicate(e,c,t,n)},c.replicate.to=function(e,t,n){return c.constructor.replicate(c,e,t,n)},c.sync=function(e,t,n){return c.constructor.sync(c,e,t,n)},c.replicate.sync=c.sync,c.destroy=s.adapterFun("destroy",function(e){var t=this;t.info(function(n,r){return n?e(n):void t.constructor.destroy(r.db_name,e)})}),o.adapters[t.adapter].call(c,t,function(e){function r(e){"destroyed"===e&&(c.emit("destroyed"),o.removeListener(l,r))}return e?void(n&&(c.taskqueue.fail(e),n(e))):(o.on(l,r),c.emit("created",c),o.emit("created",t.originalName),c.taskqueue.ready(c),void n(null,c))}),t.skipSetup&&c.taskqueue.ready(c),void(s.isCordova()&&cordova.fireWindowEvent(t.name+"_pouch",{})))});d.then(function(e){l(null,e)},l),c.then=d.then.bind(d),c["catch"]=d["catch"].bind(d)}var i=e("./adapter"),s=e("./utils"),a=e("./taskqueue"),u=s.Promise;s.inherits(o,i),t.exports=o}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./adapter":1,"./taskqueue":22,"./utils":23}],8:[function(e,t){"use strict";function n(e,t){function n(t,n,r){if(e.binary||e.json||!e.processData||"string"==typeof t){if(!e.binary&&e.json&&"string"==typeof t)try{t=JSON.parse(t)}catch(o){return r(o)}}else t=JSON.stringify(t);Array.isArray(t)&&(t=t.map(function(e){var t;return e.ok?e:e.error&&"conflict"===e.error?(t=i.REV_CONFLICT,t.id=e.id,t):e.error&&"forbidden"===e.error?(t=i.FORBIDDEN,t.id=e.id,t.reason=e.reason,t):e.missing?(t=i.MISSING_DOC,t.missing=e.missing,t):e})),r(null,t,n)}function a(e,t){var n,r,o,s;try{n=JSON.parse(e.responseText);for(s in i)if(i.hasOwnProperty(s)&&i[s].name===n.error){o=i[s];break}o||(o=i.UNKNOWN_ERROR,e.status&&(o.status=e.status),e.statusText&&(e.name=e.statusText)),r=i.error(o,n.reason)}catch(a){for(var s in i)if(i.hasOwnProperty(s)&&i[s].status===e.status){o=i[s];break}o||(o=i.UNKNOWN_ERROR,e.status&&(o.status=e.status),e.statusText&&(e.name=e.statusText)),r=i.error(o)}e.withCredentials&&0===e.status&&(r.status=405,r.statusText="Method Not Allowed"),t(r)}var u=!1,c=s.getArguments(function(e){u||(t.apply(this,e),u=!0)});"function"==typeof e&&(c=e,e={}),e=s.clone(e);var l={method:"GET",headers:{},json:!0,processData:!0,timeout:1e4,cache:!1};if(e=s.extend(!0,l,e),"GET"===e.method&&!e.cache){var d=-1!==e.url.indexOf("?");e.url+=(d?"&":"?")+"_nonce="+s.uuid(16)}var f,p;p=e.xhr?new e.xhr:new XMLHttpRequest,p.open(e.method,e.url),p.withCredentials=!0,e.json&&(e.headers.Accept="application/json",e.headers["Content-Type"]=e.headers["Content-Type"]||"application/json",e.body&&e.processData&&"string"!=typeof e.body&&(e.body=JSON.stringify(e.body))),e.binary&&(p.responseType="arraybuffer");var h=function(e,t,n){var r="";if(n){var o=new Date;o.setTime(o.getTime()+24*n*60*60*1e3),r="; expires="+o.toGMTString()}document.cookie=e+"="+t+r+"; path=/"};for(var v in e.headers)if("Cookie"===v){var m=e.headers[v].split("=");h(m[0],m[1],10)}else p.setRequestHeader(v,e.headers[v]);"body"in e||(e.body=null);var _=function(){u||(p.abort(),a(p,c))};if(p.onreadystatechange=function(){if(4===p.readyState&&!u)if(clearTimeout(f),p.status>=200&&p.status<300){var t;t=e.binary?o([p.response||""],{type:p.getResponseHeader("Content-Type")}):p.responseText,n(t,p,c)}else a(p,c)},e.timeout>0&&(f=setTimeout(_,e.timeout),p.onprogress=function(){clearTimeout(f),f=setTimeout(_,e.timeout)},"undefined"==typeof r&&(r=-1!==Object.keys(p).indexOf("upload")),r&&(p.upload.onprogress=p.onprogress)),e.body&&e.body instanceof Blob){var y=new FileReader;y.onloadend=function(){for(var e="",t=new Uint8Array(this.result),n=t.byteLength,r=0;n>r;r++)e+=String.fromCharCode(t[r]);e=s.fixBinary(e),p.send(e)},y.readAsArrayBuffer(e.body)}else p.send(e.body);return{abort:_}}var r,o=e("./blob.js"),i=e("./errors"),s=e("../utils");t.exports=n},{"../utils":23,"./blob.js":9,"./errors":11}],9:[function(e,t){(function(e){"use strict";function n(t,n){t=t||[],n=n||{};try{return new Blob(t,n)}catch(r){if("TypeError"!==r.name)throw r;for(var o=e.BlobBuilder||e.MSBlobBuilder||e.MozBlobBuilder||e.WebKitBlobBuilder,i=new o,s=0;s<t.length;s+=1)i.append(t[s]);return i.getBlob(n.type)}}t.exports=n}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],10:[function(e,t,n){"use strict";function r(){this.store={}}function o(){this.store=new r}n.Map=r,n.Set=o,r.prototype.mangle=function(e){if("string"!=typeof e)throw new TypeError("key must be a string but Got "+e);return"$"+e},r.prototype.unmangle=function(e){return e.substring(1)},r.prototype.get=function(e){var t=this.mangle(e);return t in this.store?this.store[t]:void 0},r.prototype.set=function(e,t){var n=this.mangle(e);return this.store[n]=t,!0},r.prototype.has=function(e){var t=this.mangle(e);return t in this.store},r.prototype["delete"]=function(e){var t=this.mangle(e);return t in this.store?(delete this.store[t],!0):!1},r.prototype.forEach=function(e){var t=this,n=Object.keys(t.store);n.forEach(function(n){var r=t.store[n];n=t.unmangle(n),e(r,n)})},o.prototype.add=function(e){return this.store.set(e,!0)},o.prototype.has=function(e){return this.store.has(e)},o.prototype["delete"]=function(e){return this.store["delete"](e)}},{}],11:[function(e,t,n){"use strict";function r(e){this.status=e.status,this.name=e.error,this.message=e.reason,this.error=!0}r.prototype__proto__=Error.prototype,r.prototype.toString=function(){return JSON.stringify({status:this.status,name:this.name,message:this.message})},n.UNAUTHORIZED=new r({status:401,error:"unauthorized",reason:"Name or password is incorrect."}),n.MISSING_BULK_DOCS=new r({status:400,error:"bad_request",reason:"Missing JSON list of 'docs'"}),n.MISSING_DOC=new r({status:404,error:"not_found",reason:"missing"}),n.REV_CONFLICT=new r({status:409,error:"conflict",reason:"Document update conflict"}),n.INVALID_ID=new r({status:400,error:"invalid_id",reason:"_id field must contain a string"}),n.MISSING_ID=new r({status:412,error:"missing_id",reason:"_id is required for puts"}),n.RESERVED_ID=new r({status:400,error:"bad_request",reason:"Only reserved document ids may start with underscore."}),n.NOT_OPEN=new r({status:412,error:"precondition_failed",reason:"Database not open"}),n.UNKNOWN_ERROR=new r({status:500,error:"unknown_error",reason:"Database encountered an unknown error"}),n.BAD_ARG=new r({status:500,error:"badarg",reason:"Some query argument is invalid"}),n.INVALID_REQUEST=new r({status:400,error:"invalid_request",reason:"Request was invalid"}),n.QUERY_PARSE_ERROR=new r({status:400,error:"query_parse_error",reason:"Some query parameter is invalid"}),n.DOC_VALIDATION=new r({status:500,error:"doc_validation",reason:"Bad special document member"}),n.BAD_REQUEST=new r({status:400,error:"bad_request",reason:"Something wrong with the request"}),n.NOT_AN_OBJECT=new r({status:400,error:"bad_request",reason:"Document must be a JSON object"}),n.DB_MISSING=new r({status:404,error:"not_found",reason:"Database not found"}),n.IDB_ERROR=new r({status:500,error:"indexed_db_went_bad",reason:"unknown"}),n.WSQ_ERROR=new r({status:500,error:"web_sql_went_bad",reason:"unknown"}),n.LDB_ERROR=new r({status:500,error:"levelDB_went_went_bad",reason:"unknown"}),n.FORBIDDEN=new r({status:403,error:"forbidden",reason:"Forbidden by design doc validate_doc_update function"}),n.error=function(e,t,n){function r(){this.message=t,n&&(this.name=n)}return r.prototype=e,new r(t)}},{}],12:[function(e,t){(function(n,r){"use strict";function o(e,t,n){if("function"==typeof e.slice)return t?n?e.slice(t,n):e.slice(t):e.slice();t=Math.floor(t||0),n=Math.floor(n||0);var r=e.byteLength;if(t=0>t?Math.max(t+r,0):Math.min(r,t),n=0>n?Math.max(n+r,0):Math.min(r,n),0>=n-t)return new ArrayBuffer(0);var o=new ArrayBuffer(n-t),i=new Uint8Array(o),s=new Uint8Array(e,t,n-t);return i.set(s),o}function i(e){var t=[255&e,e>>>8&255,e>>>16&255,e>>>24&255];return t.map(function(e){return String.fromCharCode(e)}).join("")}function s(e){for(var t="",n=0;n<e.length;n++)t+=i(e[n]);
return r.btoa(t)}var a=e("crypto"),u=e("spark-md5"),c=r.setImmediate||r.setTimeout;t.exports=function(e,t){function r(e,t,n,r){d?e.appendBinary(t.substring(n,r)):e.append(o(t,n,r))}function i(){var n=v*p,o=n+p;if(n+p>=e.size&&(o=e.size),v++,h>v)r(m,e,n,o),c(i);else{r(m,e,n,o);var a=m.end(!0),u=s(a);t(null,u),m.destroy()}}if(!n.browser){var l=a.createHash("md5").update(e).digest("base64");return void t(null,l)}var d="string"==typeof e,f=d?e.length:e.byteLength,p=Math.min(524288,f),h=Math.ceil(f/p),v=0,m=d?new u:new u.ArrayBuffer;i()}}).call(this,e("/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":28,crypto:26,"spark-md5":56}],13:[function(e,t){"use strict";function n(e,t,n){return new o(function(o,i){return t&&"object"==typeof t&&(t=t._id),"string"!=typeof t?i(new Error("doc id is required")):void e.get(t,function(s,a){if(s)return 404!==s.status?i(s):o(r(e,n({_id:t}),n));var u=n(a);return u?void o(r(e,u,n)):o(a)})})}function r(e,t,r){return e.put(t)["catch"](function(o){if(409!==o.status)throw o;return n(e,t,r)})}var o=e("../utils").Promise;t.exports=function(e,t,r,o){return"function"!=typeof o?n(e,t,r):void n(e,t,r).then(function(e){o(null,e)},o)}},{"../utils":23}],14:[function(e,t){"use strict";function n(e){return 0|Math.random()*e}function r(e,t){t=t||o.length;var r="",i=-1;if(e){for(;++i<e;)r+=o[n(t)];return r}for(;++i<36;)switch(i){case 8:case 13:case 18:case 23:r+="-";break;case 19:r+=o[3&n(16)|8];break;default:r+=o[n(16)]}return r}var o="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");t.exports=r},{}],15:[function(_dereq_,module,exports){"use strict";function evalFilter(input){return eval(["(function () { return ",input," })()"].join(""))}module.exports=evalFilter},{}],16:[function(_dereq_,module,exports){"use strict";function evalView(input){return eval(["(function () {","  return function (doc) {","    var emitted = false;","    var emit = function (a, b) {","      emitted = true;","    };","    var view = "+input+";","    view(doc);","    if (emitted) {","      return true;","    }","  }","})()"].join("\n"))}module.exports=evalView},{}],17:[function(e,t){(function(n){"use strict";var r=e("./setup");t.exports=r,r.ajax=e("./deps/ajax"),r.extend=e("pouchdb-extend"),r.utils=e("./utils"),r.Errors=e("./deps/errors"),r.replicate=e("./replicate").replicate,r.sync=e("./sync"),r.version=e("./version");var o=e("./adapters/http");if(r.adapter("http",o),r.adapter("https",o),r.adapter("idb",e("./adapters/idb")),r.adapter("websql",e("./adapters/websql")),r.plugin(e("pouchdb-mapreduce")),!n.browser){var i=e("./adapters/leveldb");r.adapter("ldb",i),r.adapter("leveldb",i)}}).call(this,e("/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))},{"./adapters/http":2,"./adapters/idb":3,"./adapters/leveldb":26,"./adapters/websql":5,"./deps/ajax":8,"./deps/errors":11,"./replicate":19,"./setup":20,"./sync":21,"./utils":23,"./version":24,"/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":28,"pouchdb-extend":47,"pouchdb-mapreduce":50}],18:[function(e,t){"use strict";function n(e){for(var t,n=e.shift(),r=[n.id,n.opts,[]],o=r;e.length;)n=e.shift(),t=[n.id,n.opts,[]],o[2].push(t),o=t;return r}function r(e,t){for(var n=[{tree1:e,tree2:t}],r=!1;n.length>0;){var o=n.pop(),i=o.tree1,s=o.tree2;(i[1].status||s[1].status)&&(i[1].status="available"===i[1].status||"available"===s[1].status?"available":"missing");for(var a=0;a<s[2].length;a++)if(i[2][0]){for(var u=!1,c=0;c<i[2].length;c++)i[2][c][0]===s[2][a][0]&&(n.push({tree1:i[2][c],tree2:s[2][a]}),u=!0);u||(r="new_branch",i[2].push(s[2][a]),i[2].sort())}else r="new_leaf",i[2][0]=s[2][a]}return{conflicts:r,tree:e}}function o(e,t,n){var o,i=[],s=!1,a=!1;return e.length?(e.forEach(function(e){if(e.pos===t.pos&&e.ids[0]===t.ids[0])o=r(e.ids,t.ids),i.push({pos:e.pos,ids:o.tree}),s=s||o.conflicts,a=!0;else if(n!==!0){var u=e.pos<t.pos?e:t,c=e.pos<t.pos?t:e,l=c.pos-u.pos,d=[],f=[];for(f.push({ids:u.ids,diff:l,parent:null,parentIdx:null});f.length>0;){var p=f.pop();0!==p.diff?p.ids&&p.ids[2].forEach(function(e,t){f.push({ids:e,diff:p.diff-1,parent:p.ids,parentIdx:t})}):p.ids[0]===c.ids[0]&&d.push(p)}var h=d[0];h?(o=r(h.ids,c.ids),h.parent[2][h.parentIdx]=o.tree,i.push({pos:u.pos,ids:u.ids}),s=s||o.conflicts,a=!0):i.push(e)}else i.push(e)}),a||i.push(t),i.sort(function(e,t){return e.pos-t.pos}),{tree:i,conflicts:s||"internal_node"}):{tree:[t],conflicts:"new_leaf"}}function i(e,t){var r=a.rootToLeaf(e).map(function(e){var r=e.ids.slice(-t);return{pos:e.pos+(e.ids.length-r.length),ids:n(r)}});return r.reduce(function(e,t){return o(e,t,!0).tree},[r.shift()])}var s=e("pouchdb-extend"),a={};a.merge=function(e,t,n){e=s(!0,[],e),t=s(!0,{},t);var r=o(e,t);return{tree:i(r.tree,n),conflicts:r.conflicts}},a.winningRev=function(e){var t=[];return a.traverseRevTree(e.rev_tree,function(e,n,r,o,i){e&&t.push({pos:n,id:r,deleted:!!i.deleted})}),t.sort(function(e,t){return e.deleted!==t.deleted?e.deleted>t.deleted?1:-1:e.pos!==t.pos?t.pos-e.pos:e.id<t.id?1:-1}),t[0].pos+"-"+t[0].id},a.traverseRevTree=function(e,t){for(var n,r=e.slice();n=r.pop();)for(var o=n.pos,i=n.ids,s=i[2],a=t(0===s.length,o,i[0],n.ctx,i[1]),u=0,c=s.length;c>u;u++)r.push({pos:o+1,ids:s[u],ctx:a})},a.collectLeaves=function(e){var t=[];return a.traverseRevTree(e,function(e,n,r,o,i){e&&t.unshift({rev:n+"-"+r,pos:n,opts:i})}),t.sort(function(e,t){return t.pos-e.pos}),t.map(function(e){delete e.pos}),t},a.collectConflicts=function(e){var t=a.winningRev(e),n=a.collectLeaves(e.rev_tree),r=[];return n.forEach(function(e){e.rev===t||e.opts.deleted||r.push(e.rev)}),r},a.rootToLeaf=function(e){var t=[];return a.traverseRevTree(e,function(e,n,r,o,i){if(o=o?o.slice(0):[],o.push({id:r,opts:i}),e){var s=n+1-o.length;t.unshift({pos:s,ids:o})}return o}),t},t.exports=a},{"pouchdb-extend":47}],19:[function(e,t,n){"use strict";function r(){d.call(this),this.cancelled=!1;var e=this,t=new l.Promise(function(t,n){e.once("complete",t),e.once("error",n)});e.then=function(e,n){return t.then(e,n)},e["catch"]=function(e){return t["catch"](e)},e["catch"](function(){})}function o(e,t,n){var r=n.filter?n.filter.toString():"";return e.id().then(function(e){return t.id().then(function(t){var o=e+t+r+JSON.stringify(n.query_params)+n.doc_ids;return l.MD5(o).then(function(e){return e=e.replace(/\//g,".").replace(/\+/g,"_"),"_local/"+e})})})}function i(e,t,n,r){return e.get(t)["catch"](function(e){if(404===e.status)return{_id:t};throw e}).then(function(t){return r.cancelled?void 0:(t.last_seq=n,e.put(t))})}function s(e,t,n,r){this.src=e,this.target=t,this.id=n,this.returnValue=r}function a(e,t,n,r,o){function i(){if(0!==k.docs.length){var e=k.docs;return n.bulkDocs({docs:e},{new_edits:!1}).then(function(e){if(o.cancelled)throw y(),new Error("cancelled");var t=[];if(e.forEach(function(e){e.ok||(B.doc_write_failures++,t.push(new Error(e.reason||e.message||"Unknown reason")))}),t.length>0){var n=new Error("bulkDocs error");throw n.other_errors=t,_("target.bulkDocs failed to write docs",n),new Error("bulkWrite partial failure")}},function(t){throw B.doc_write_failures+=e.length,t})}}function a(){for(var e=k.diffs,n=Object.keys(e)[0],r=e[n].missing,i=[],s=0;s<r.length;s+=f)i.push(r.slice(s,Math.min(r.length,s+f)));return l.Promise.all(i.map(function(r){return t.get(n,{revs:!0,open_revs:r,attachments:!0}).then(function(t){t.forEach(function(t){return o.cancelled?y():void(t.ok&&(B.docs_read++,k.pendingRevs++,k.docs.push(t.ok),delete e[t.ok._id]))})})}))}function u(){return Object.keys(k.diffs).length>0?a().then(u):l.Promise.resolve()}function c(){var e=Object.keys(k.diffs).filter(function(e){var t=k.diffs[e].missing;return 1===t.length&&"1-"===t[0].slice(0,2)});return t.allDocs({keys:e,include_docs:!0}).then(function(e){if(o.cancelled)throw y(),new Error("cancelled");e.rows.forEach(function(e){!e.doc||e.deleted||"1-"!==e.value.rev.slice(0,2)||e.doc._attachments&&0!==Object.keys(e.doc._attachments).length||(B.docs_read++,k.pendingRevs++,k.docs.push(e.doc),delete k.diffs[e.id])})})}function d(){return c().then(u)}function p(){return T=!0,F.writeCheckpoint(k.seq).then(function(){if(T=!1,o.cancelled)throw y(),new Error("cancelled");B.last_seq=L=k.seq,B.docs_written+=k.docs.length,o.emit("change",l.clone(B)),k=void 0,E()})["catch"](function(e){throw T=!1,_("writeCheckpoint completed with error",e),e})}function h(){var e={};return k.changes.forEach(function(t){e[t.id]=t.changes.map(function(e){return e.rev})}),n.revsDiff(e).then(function(e){if(o.cancelled)throw y(),new Error("cancelled");k.diffs=e,k.pendingRevs=0})}function v(){if(!o.cancelled&&!k){if(0===x.length)return void m(!0);k=x.shift(),h().then(d).then(i).then(p).then(v)["catch"](function(e){_("batch processing terminated with error",e)})}}function m(e){return 0===q.changes.length?void(0!==x.length||k||((R&&M.live||A)&&o.emit("uptodate",l.clone(B)),A&&y())):void((e||A||q.changes.length>=I)&&(x.push(q),q={seq:0,changes:[],docs:[]},v()))}function _(e,t){O||(B.ok=!1,B.status="aborted",B.errors.push(t),x=[],q={seq:0,changes:[],docs:[]},y())}function y(){if(!(O||o.cancelled&&(B.status="cancelled",T))){if(B.status=B.status||"complete",B.end_time=new Date,B.last_seq=L,O=o.cancelled=!0,B.errors.length>0){var e=B.errors.pop();B.errors.length>0&&(e.other_errors=B.errors),e.result=B,o.emit("error",e)}else o.emit("complete",B);o.removeAllListeners()}}function g(e){return o.cancelled?y():(N++,0!==q.changes.length||0!==x.length||k||o.emit("outofdate",l.clone(B)),q.seq=e.seq,q.changes.push(e),void m(0===x.length))}function b(e){return C=!1,o.cancelled?y():(N>0?(M.since=e.last_seq,E()):R?(M.live=!0,E()):A=!0,void m(!0))}function w(e){return C=!1,o.cancelled?y():void _("changes rejected",e)}function E(){function e(){r.cancel()}function n(){o.removeListener("cancel",e)}if(!C&&!A&&x.length<D){C=!0,N=0,o.once("cancel",e);var r=t.changes(M).on("change",g);r.then(n,n),r.then(b)["catch"](w)}}function S(){F.getCheckpoint().then(function(e){L=e,M={since:L,limit:I,batch_size:I,style:"all_docs",doc_ids:j,returnDocs:!1},r.filter&&(M.filter=r.filter),r.query_params&&(M.query_params=r.query_params),E()})["catch"](function(e){_("getCheckpoint rejected with ",e)})}var k,x=[],q={seq:0,changes:[],docs:[]},T=!1,A=!1,O=!1,L=0,R=r.continuous||r.live||!1,I=r.batch_size||100,D=r.batches_limit||10,C=!1,N=0,j=r.doc_ids,F=new s(t,n,e,o),B={ok:!0,start_time:new Date,docs_read:0,docs_written:0,doc_write_failures:0,errors:[]},M={};o.ready(t,n),o.once("cancel",y),"function"==typeof r.onChange&&o.on("change",r.onChange),"function"==typeof r.complete&&(o.once("error",r.complete),o.once("complete",function(e){r.complete(null,e)})),"undefined"==typeof r.since?S():(T=!0,F.writeCheckpoint(r.since).then(function(){return T=!1,o.cancelled?void y():(L=r.since,void S())})["catch"](function(e){throw T=!1,_("writeCheckpoint completed with error",e),e}))}function u(e,t){var n=t.PouchConstructor;return"string"==typeof e?new n(e):e.then?e:l.Promise.resolve(e)}function c(e,t,n,i){"function"==typeof n&&(i=n,n={}),"undefined"==typeof n&&(n={}),n.complete||(n.complete=i||function(){}),n=l.clone(n),n.continuous=n.continuous||n.live,n.PouchConstructor=n.PouchConstructor||this;var s=new r(n);return u(e,n).then(function(e){return u(t,n).then(function(t){return o(e,t,n).then(function(r){a(r,e,t,n,s)})})})["catch"](function(e){s.emit("error",e),n.complete(e)}),s}var l=e("./utils"),d=e("events").EventEmitter,f=50;l.inherits(r,d),r.prototype.cancel=function(){this.cancelled=!0,this.emit("cancel")},r.prototype.ready=function(e,t){function n(){o.cancel()}function r(){e.removeListener("destroyed",n),t.removeListener("destroyed",n)}var o=this;e.once("destroyed",n),t.once("destroyed",n),this.then(r,r)},s.prototype.writeCheckpoint=function(e){var t=this;return this.updateTarget(e).then(function(){return t.updateSource(e)})},s.prototype.updateTarget=function(e){return i(this.target,this.id,e,this.returnValue)},s.prototype.updateSource=function(e){var t=this;return this.readOnlySource?l.Promise.resolve(!0):i(this.src,this.id,e,this.returnValue)["catch"](function(e){var n="number"==typeof e.status&&4===Math.floor(e.status/100);if(n)return t.readOnlySource=!0,!0;throw e})},s.prototype.getCheckpoint=function(){var e=this;return e.target.get(e.id).then(function(t){return e.src.get(e.id).then(function(e){return t.last_seq===e.last_seq?e.last_seq:0},function(n){if(404===n.status&&t.last_seq)return e.src.put({_id:e.id,last_seq:0}).then(function(){return 0},function(n){return 401===n.status?(e.readOnlySource=!0,t.last_seq):0});throw n})})["catch"](function(e){if(404!==e.status)throw e;return 0})},n.toPouch=u,n.replicate=c},{"./utils":23,events:27}],20:[function(e,t){(function(n){"use strict";var r=e("./constructor"),o=e("./utils"),i=o.Promise,s=e("events").EventEmitter;r.adapters={},r.preferredAdapters=e("./adapters/preferredAdapters.js"),r.prefix="_pouch_";var a=new s,u=["on","addListener","emit","listeners","once","removeAllListeners","removeListener","setMaxListeners"];u.forEach(function(e){r[e]=a[e].bind(a)}),r.setMaxListeners(0),r.parseAdapter=function(e,t){var i,s,a=e.match(/([a-z\-]*):\/\/(.*)/);if(a){if(e=/http(s?)/.test(a[1])?a[1]+"://"+a[2]:a[2],i=a[1],!r.adapters[i].valid())throw"Invalid adapter";return{name:e,adapter:a[1]}}var u="idb"in r.adapters&&"websql"in r.adapters&&o.hasLocalStorage()&&n.localStorage["_pouch__websqldb_"+r.prefix+e];if("undefined"!=typeof t&&t.db)s="leveldb";else for(var c=0;c<r.preferredAdapters.length;++c)if(s=r.preferredAdapters[c],s in r.adapters){if(u&&"idb"===s)continue;break}if(i=r.adapters[s],s&&i){var l="use_prefix"in i?i.use_prefix:!0;return{name:l?r.prefix+e:e,adapter:s}}throw"No valid adapter found"},r.destroy=o.toPromise(function(e,t,n){function s(){c.destroy(f,t,function(t,o){t?n(t):(r.emit("destroyed",e),r.emit(e,"destroyed"),n(null,o||{ok:!0}))})}("function"==typeof t||"undefined"==typeof t)&&(n=t,t={}),e&&"object"==typeof e&&(t=e,e=void 0);var a=r.parseAdapter(t.name||e,t),u=a.name,c=r.adapters[a.adapter],l="use_prefix"in c?c.use_prefix:!0,d=l?u.replace(new RegExp("^"+r.prefix),""):u,f=("http"===a.adapter||"https"===a.adapter?"":t.prefix||"")+u,p=o.extend(!0,{},t,{adapter:a.adapter});new r(d,p,function(e,u){return e?n(e):void u.get("_local/_pouch_dependentDbs",function(e,u){if(e)return 404!==e.status?n(e):s();var c=u.dependentDbs,d=Object.keys(c).map(function(e){var n=l?e.replace(new RegExp("^"+r.prefix),""):e,i=o.extend(!0,t,{adapter:a.adapter});return r.destroy(n,i)});i.all(d).then(s,function(e){n(e)})})})}),r.allDbs=o.toPromise(function(e){var t=new Error("allDbs method removed");t.stats="400",e(t)}),r.adapter=function(e,t){t.valid()&&(r.adapters[e]=t)},r.plugin=function(e){Object.keys(e).forEach(function(t){r.prototype[t]=e[t]})},r.defaults=function(e){function t(t,n,i){("function"==typeof n||"undefined"==typeof n)&&(i=n,n={}),t&&"object"==typeof t&&(n=t,t=void 0),n=o.extend(!0,{},e,n),r.call(this,t,n,i)}return o.inherits(t,r),t.destroy=o.toPromise(function(t,n,i){return("function"==typeof n||"undefined"==typeof n)&&(i=n,n={}),t&&"object"==typeof t&&(n=t,t=void 0),n=o.extend(!0,{},e,n),r.destroy(t,n,i)}),u.forEach(function(e){t[e]=a[e].bind(a)}),t.setMaxListeners(0),t.preferredAdapters=r.preferredAdapters.slice(),Object.keys(r).forEach(function(e){e in t||(t[e]=r[e])}),t},t.exports=r}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./adapters/preferredAdapters.js":4,"./constructor":7,"./utils":23,events:27}],21:[function(e,t){"use strict";function n(e,t,n,s){return"function"==typeof n&&(s=n,n={}),"undefined"==typeof n&&(n={}),n=o.clone(n),n.PouchConstructor=n.PouchConstructor||this,e=i.toPouch(e,n),t=i.toPouch(t,n),new r(e,t,n,s)}function r(e,t,n,r){function i(e){p||(p=!0,l.emit("cancel",e))}function a(e){l.emit("change",{direction:"pull",change:e})}function u(e){l.emit("change",{direction:"push",change:e})}function c(e){return function(t,n){var r="change"===t&&(n===a||n===u),o="cancel"===t&&n===i,s=t in h&&n===h[t];(r||o||s)&&(t in v||(v[t]={}),v[t][e]=!0,2===Object.keys(v[t]).length&&l.removeAllListeners(t))}}var l=this;this.canceled=!1;var d,f;"onChange"in n&&(d=n.onChange,delete n.onChange),"function"!=typeof r||n.complete?"complete"in n&&(f=n.complete,delete n.complete):f=r,this.push=s(e,t,n),this.pull=s(t,e,n);var p=!1,h={},v={};this.on("newListener",function(e){"change"===e?(l.pull.on("change",a),l.push.on("change",u)):"cancel"===e?(l.pull.on("cancel",i),l.push.on("cancel",i)):"error"===e||"removeListener"===e||"complete"===e||e in h||(h[e]=function(t){l.emit(e,t)},l.pull.on(e,h[e]),l.push.on(e,h[e]))}),this.on("removeListener",function(e){"change"===e?(l.pull.removeListener("change",a),l.push.removeListener("change",u)):"cancel"===e?(l.pull.removeListener("cancel",i),l.push.removeListener("cancel",i)):e in h&&"function"==typeof h[e]&&(l.pull.removeListener(e,h[e]),l.push.removeListener(e,h[e]),delete h[e])}),this.pull.on("removeListener",c("pull")),this.push.on("removeListener",c("push"));var m=o.Promise.all([this.push,this.pull]).then(function(e){var t={push:e[0],pull:e[1]};return l.emit("complete",t),f&&f(null,t),l.removeAllListeners(),t},function(e){throw l.cancel(),l.emit("error",e),f&&f(e),l.removeAllListeners(),e});this.then=function(e,t){return m.then(e,t)},this["catch"]=function(e){return m["catch"](e)}}var o=e("./utils"),i=e("./replicate"),s=i.replicate,a=e("events").EventEmitter;o.inherits(r,a),t.exports=n,r.prototype.cancel=function(){this.canceled||(this.canceled=!0,this.push.cancel(),this.pull.cancel())}},{"./replicate":19,"./utils":23,events:27}],22:[function(e,t){"use strict";function n(){this.isReady=!1,this.failed=!1,this.queue=[]}t.exports=n,n.prototype.execute=function(){var e,t;if(this.failed)for(;e=this.queue.shift();)"function"!=typeof e?(t=e.parameters[e.parameters.length-1],"function"==typeof t?t(this.failed):"changes"===e.name&&"function"==typeof t.complete&&t.complete(this.failed)):e(this.failed);else if(this.isReady)for(;e=this.queue.shift();)"function"==typeof e?e():e.task=this.db[e.name].apply(this.db,e.parameters)},n.prototype.fail=function(e){this.failed=e,this.execute()},n.prototype.ready=function(e){return this.failed?!1:0===arguments.length?this.isReady:(this.isReady=e?!0:!1,this.db=e,void this.execute())},n.prototype.addTask=function(e,t){if("function"!=typeof e){var n={name:e,parameters:t};return this.queue.push(n),this.failed&&this.execute(),n}this.queue.push(e),this.failed&&this.execute()}},{}],23:[function(e,t,n){(function(t,r){function o(e){var t={};return e.forEach(function(e){t[e]=!0}),t}function i(){return"undefined"!=typeof chrome&&"undefined"!=typeof chrome.storage&&"undefined"!=typeof chrome.storage.local}function s(){if(!(this instanceof s))return new s;var e=this;l.call(this),this.isChrome=i(),this.listeners={},this.hasLocal=!1,this.isChrome||(this.hasLocal=n.hasLocalStorage()),this.isChrome?chrome.storage.onChanged.addListener(function(t){null!=t.db_name&&e.emit(t.dbName.newValue)}):this.hasLocal&&(r.addEventListener?r.addEventListener("storage",function(t){e.emit(t.key)}):r.attachEvent("storage",function(t){e.emit(t.key)}))}var a=e("./merge");n.extend=e("pouchdb-extend"),n.ajax=e("./deps/ajax"),n.createBlob=e("./deps/blob"),n.uuid=e("./deps/uuid"),n.getArguments=e("argsarray");var u=e("./deps/buffer"),c=e("./deps/errors"),l=e("events").EventEmitter,d=e("./deps/collections");n.Map=d.Map,n.Set=d.Set,n.Promise="function"==typeof r.Promise?r.Promise:e("bluebird");var f=n.Promise,p=o(["_id","_rev","_attachments","_deleted","_revisions","_revs_info","_conflicts","_deleted_conflicts","_local_seq","_rev_tree","_replication_id","_replication_state","_replication_state_time","_replication_state_reason","_replication_stats"]);n.clone=function(e){return n.extend(!0,{},e)},n.inherits=e("inherits"),n.invalidIdError=function(e){var t;if(e?"string"!=typeof e?(t=new TypeError(c.INVALID_ID.message),t.status=400):/^_/.test(e)&&!/^_(design|local)/.test(e)&&(t=new TypeError(c.RESERVED_ID.message),t.status=400):(t=new TypeError(c.MISSING_ID.message),t.status=412),t)throw t},n.call=n.getArguments(function(e){if(e.length){var t=e.shift();"function"==typeof t&&t.apply(this,e)}}),n.isLocalId=function(e){return/^_local/.test(e)},n.isDeleted=function(e,t){t||(t=a.winningRev(e));var n=t.indexOf("-");-1!==n&&(t=t.substring(n+1));var r=!1;return a.traverseRevTree(e.rev_tree,function(e,n,o,i,s){o===t&&(r=!!s.deleted)}),r},n.filterChange=function(e){return function(t){var n={},r=e.filter&&"function"==typeof e.filter;if(n.query=e.query_params,e.filter&&r&&!e.filter.call(this,t.doc,n))return!1;if(e.doc_ids&&-1===e.doc_ids.indexOf(t.id))return!1;if(e.include_docs)for(var o in t.doc._attachments)t.doc._attachments.hasOwnProperty(o)&&(t.doc._attachments[o].stub=!0);else delete t.doc;return!0}},n.parseDoc=function(e,t){var r,o,i,s,a={status:"available"};if(e._deleted&&(a.deleted=!0),t)if(e._id||(e._id=n.uuid()),o=n.uuid(32,16).toLowerCase(),e._rev){if(i=/^(\d+)-(.+)$/.exec(e._rev),!i){var u=new TypeError("invalid value for property '_rev'");u.status=400}e._rev_tree=[{pos:parseInt(i[1],10),ids:[i[2],{status:"missing"},[[o,a,[]]]]}],r=parseInt(i[1],10)+1}else e._rev_tree=[{pos:1,ids:[o,a,[]]}],r=1;else if(e._revisions&&(e._rev_tree=[{pos:e._revisions.start-e._revisions.ids.length+1,ids:e._revisions.ids.reduce(function(e,t){return null===e?[t,a,[]]:[t,{status:"missing"},[e]]},null)}],r=e._revisions.start,o=e._revisions.ids[0]),!e._rev_tree){if(i=/^(\d+)-(.+)$/.exec(e._rev),!i)throw s=new TypeError(c.BAD_ARG.message),s.status=c.BAD_ARG.status,s;r=parseInt(i[1],10),o=i[2],e._rev_tree=[{pos:parseInt(i[1],10),ids:[i[2],a,[]]}]}n.invalidIdError(e._id),e._rev=[r,o].join("-");var l={metadata:{},data:{}};for(var d in e)if(e.hasOwnProperty(d)){var f="_"===d[0];if(f&&!p[d])throw s=new Error(c.DOC_VALIDATION.message+": "+d),s.status=c.DOC_VALIDATION.status,s;f&&"_attachments"!==d?l.metadata[d.slice(1)]=e[d]:l.data[d]=e[d]}return l},n.isCordova=function(){return"undefined"!=typeof cordova||"undefined"!=typeof PhoneGap||"undefined"!=typeof phonegap},n.hasLocalStorage=function(){if(i())return!1;try{return r.localStorage}catch(e){return!1}},n.Changes=s,n.inherits(s,l),s.prototype.addListener=function(e,t,r,o){function i(){r.changes({include_docs:o.include_docs,conflicts:o.conflicts,continuous:!1,descending:!1,filter:o.filter,view:o.view,since:o.since,query_params:o.query_params,onChange:function(e){e.seq>o.since&&!o.cancelled&&(o.since=e.seq,n.call(o.onChange,e))}})}this.listeners[t]||(this.listeners[t]=i,this.on(e,i))},s.prototype.removeListener=function(e,t){t in this.listeners&&l.prototype.removeListener.call(this,e,this.listeners[t])},s.prototype.notifyLocalWindows=function(e){this.isChrome?chrome.storage.local.set({dbName:e}):this.hasLocal&&(localStorage[e]="a"===localStorage[e]?"b":"a")},s.prototype.notify=function(e){this.emit(e),this.notifyLocalWindows(e)},n.atob=t.browser&&"atob"in r?function(e){return atob(e)}:function(e){var t=new u(e,"base64");if(t.toString("base64")!==e)throw"Cannot base64 encode full string";return t.toString("binary")},n.btoa=t.browser&&"btoa"in r?function(e){return btoa(e)}:function(e){return new u(e,"binary").toString("base64")},n.fixBinary=function(e){if(!t.browser)return e;for(var n=e.length,r=new ArrayBuffer(n),o=new Uint8Array(r),i=0;n>i;i++)o[i]=e.charCodeAt(i);return r},n.once=function(e){var t=!1;return n.getArguments(function(n){if(t)throw"function"==typeof console.trace&&console.trace(),new Error("once called  more than once");t=!0,e.apply(this,n)})},n.toPromise=function(e){return n.getArguments(function(r){var o,i=this,s="function"==typeof r[r.length-1]?r.pop():!1;s&&(o=function(e,n){t.nextTick(function(){s(e,n)})});var a=new f(function(t,o){var s;try{var a=n.once(function(e,n){e?o(e):t(n)});r.push(a),s=e.apply(i,r),s&&"function"==typeof s.then&&t(s)}catch(u){o(u)}});return o&&a.then(function(e){o(null,e)},o),a.cancel=function(){return this},a})},n.adapterFun=function(e,t){return n.toPromise(n.getArguments(function(r){if(this._closed)return f.reject(new Error("database is closed"));var o=this;return this.taskqueue.isReady?t.apply(this,r):new n.Promise(function(t,n){o.taskqueue.addTask(function(i){i?n(i):t(o[e].apply(o,r))})})}))},n.arrayBufferToBinaryString=function(e){for(var t="",n=new Uint8Array(e),r=n.byteLength,o=0;r>o;o++)t+=String.fromCharCode(n[o]);return t},n.cancellableFun=function(e,t,r){r=r?n.clone(!0,{},r):{};var o=new l,i=r.complete||function(){},s=r.complete=n.once(function(e,t){e?i(e):(o.emit("end",t),i(null,t)),o.removeAllListeners()}),a=r.onChange||function(){},u=0;t.on("destroyed",function(){o.removeAllListeners()}),r.onChange=function(e){a(e),e.seq<=u||(u=e.seq,o.emit("change",e),e.deleted?o.emit("delete",e):1===e.changes.length&&"1-"===e.changes[0].rev.slice(0,1)?o.emit("create",e):o.emit("update",e))};var c=new f(function(e,t){r.complete=function(n,r){n?t(n):e(r)}});return c.then(function(e){s(null,e)},s),c.cancel=function(){c.isCancelled=!0,t.taskqueue.isReady&&r.complete(null,{status:"cancelled"})},t.taskqueue.isReady?e(t,r,c):t.taskqueue.addTask(function(){c.isCancelled?r.complete(null,{status:"cancelled"}):e(t,r,c)}),c.on=o.on.bind(o),c.once=o.once.bind(o),c.addListener=o.addListener.bind(o),c.removeListener=o.removeListener.bind(o),c.removeAllListeners=o.removeAllListeners.bind(o),c.setMaxListeners=o.setMaxListeners.bind(o),c.listeners=o.listeners.bind(o),c.emit=o.emit.bind(o),c},n.MD5=n.toPromise(e("./deps/md5"))}).call(this,e("/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./deps/ajax":8,"./deps/blob":9,"./deps/buffer":26,"./deps/collections":10,"./deps/errors":11,"./deps/md5":12,"./deps/uuid":14,"./merge":18,"/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":28,argsarray:25,bluebird:33,events:27,inherits:29,"pouchdb-extend":47}],24:[function(e,t){t.exports="3.0.5"},{}],25:[function(e,t){"use strict";function n(e){return function(){var t=arguments.length;if(t){for(var n=[],r=-1;++r<t;)n[r]=arguments[r];return e.call(this,n)}return e.call(this,[])}}t.exports=n},{}],26:[function(){},{}],27:[function(e,t){function n(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function r(e){return"function"==typeof e}function o(e){return"number"==typeof e}function i(e){return"object"==typeof e&&null!==e}function s(e){return void 0===e}t.exports=n,n.EventEmitter=n,n.prototype._events=void 0,n.prototype._maxListeners=void 0,n.defaultMaxListeners=10,n.prototype.setMaxListeners=function(e){if(!o(e)||0>e||isNaN(e))throw TypeError("n must be a positive number");return this._maxListeners=e,this},n.prototype.emit=function(e){var t,n,o,a,u,c;if(this._events||(this._events={}),"error"===e&&(!this._events.error||i(this._events.error)&&!this._events.error.length)){if(t=arguments[1],t instanceof Error)throw t;throw TypeError('Uncaught, unspecified "error" event.')}if(n=this._events[e],s(n))return!1;if(r(n))switch(arguments.length){case 1:n.call(this);break;case 2:n.call(this,arguments[1]);break;case 3:n.call(this,arguments[1],arguments[2]);break;default:for(o=arguments.length,a=new Array(o-1),u=1;o>u;u++)a[u-1]=arguments[u];n.apply(this,a)}else if(i(n)){for(o=arguments.length,a=new Array(o-1),u=1;o>u;u++)a[u-1]=arguments[u];for(c=n.slice(),o=c.length,u=0;o>u;u++)c[u].apply(this,a)}return!0},n.prototype.addListener=function(e,t){var o;if(!r(t))throw TypeError("listener must be a function");if(this._events||(this._events={}),this._events.newListener&&this.emit("newListener",e,r(t.listener)?t.listener:t),this._events[e]?i(this._events[e])?this._events[e].push(t):this._events[e]=[this._events[e],t]:this._events[e]=t,i(this._events[e])&&!this._events[e].warned){var o;o=s(this._maxListeners)?n.defaultMaxListeners:this._maxListeners,o&&o>0&&this._events[e].length>o&&(this._events[e].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[e].length),"function"==typeof console.trace&&console.trace())}return this},n.prototype.on=n.prototype.addListener,n.prototype.once=function(e,t){function n(){this.removeListener(e,n),o||(o=!0,t.apply(this,arguments))}if(!r(t))throw TypeError("listener must be a function");var o=!1;return n.listener=t,this.on(e,n),this},n.prototype.removeListener=function(e,t){var n,o,s,a;if(!r(t))throw TypeError("listener must be a function");if(!this._events||!this._events[e])return this;if(n=this._events[e],s=n.length,o=-1,n===t||r(n.listener)&&n.listener===t)delete this._events[e],this._events.removeListener&&this.emit("removeListener",e,t);else if(i(n)){for(a=s;a-->0;)if(n[a]===t||n[a].listener&&n[a].listener===t){o=a;break}if(0>o)return this;1===n.length?(n.length=0,delete this._events[e]):n.splice(o,1),this._events.removeListener&&this.emit("removeListener",e,t)}return this},n.prototype.removeAllListeners=function(e){var t,n;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[e]&&delete this._events[e],this;if(0===arguments.length){for(t in this._events)"removeListener"!==t&&this.removeAllListeners(t);return this.removeAllListeners("removeListener"),this._events={},this}if(n=this._events[e],r(n))this.removeListener(e,n);else for(;n.length;)this.removeListener(e,n[n.length-1]);return delete this._events[e],this},n.prototype.listeners=function(e){var t;return t=this._events&&this._events[e]?r(this._events[e])?[this._events[e]]:this._events[e].slice():[]},n.listenerCount=function(e,t){var n;return n=e._events&&e._events[t]?r(e._events[t])?1:e._events[t].length:0}},{}],28:[function(e,t){var n=t.exports={};n.nextTick=function(){var e="undefined"!=typeof window&&window.setImmediate,t="undefined"!=typeof window&&window.postMessage&&window.addEventListener;if(e)return function(e){return window.setImmediate(e)};if(t){var n=[];return window.addEventListener("message",function(e){var t=e.source;if((t===window||null===t)&&"process-tick"===e.data&&(e.stopPropagation(),n.length>0)){var r=n.shift();r()}},!0),function(e){n.push(e),window.postMessage("process-tick","*")}}return function(e){setTimeout(e,0)}}(),n.title="browser",n.browser=!0,n.env={},n.argv=[],n.binding=function(){throw new Error("process.binding is not supported")},n.cwd=function(){return"/"},n.chdir=function(){throw new Error("process.chdir is not supported")}},{}],29:[function(e,t){t.exports="function"==typeof Object.create?function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:function(e,t){e.super_=t;var n=function(){};n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e}},{}],30:[function(e,t){"use strict";function n(){}t.exports=n},{}],31:[function(e,t){"use strict";var n=e("./promise"),r=e("./reject"),o=e("./resolve"),i=e("./INTERNAL"),s=e("./handlers"),a=r(new TypeError("must be an array"));t.exports=function(e){function t(e,t){function n(e){c[t]=e,++l===r&!u&&(u=!0,s.resolve(f,c))}o(e).then(n,function(e){u||(u=!0,s.reject(f,e))})}if("[object Array]"!==Object.prototype.toString.call(e))return a;var r=e.length,u=!1;if(!r)return o([]);for(var c=new Array(r),l=0,d=-1,f=new n(i);++d<r;)t(e[d],d);return f}},{"./INTERNAL":30,"./handlers":32,"./promise":34,"./reject":36,"./resolve":37}],32:[function(e,t,n){"use strict";function r(e){var t=e&&e.then;return e&&"object"==typeof e&&"function"==typeof t?function(){t.apply(e,arguments)}:void 0}var o=e("./tryCatch"),i=e("./resolveThenable"),s=e("./states");
n.resolve=function(e,t){var a=o(r,t);if("error"===a.status)return n.reject(e,a.value);var u=a.value;if(u)i.safely(e,u);else{e.state=s.FULFILLED,e.outcome=t;for(var c=-1,l=e.queue.length;++c<l;)e.queue[c].callFulfilled(t)}return e},n.reject=function(e,t){e.state=s.REJECTED,e.outcome=t;for(var n=-1,r=e.queue.length;++n<r;)e.queue[n].callRejected(t);return e}},{"./resolveThenable":38,"./states":39,"./tryCatch":40}],33:[function(e,t,n){t.exports=n=e("./promise"),n.resolve=e("./resolve"),n.reject=e("./reject"),n.all=e("./all")},{"./all":31,"./promise":34,"./reject":36,"./resolve":37}],34:[function(e,t){"use strict";function n(e){if(!(this instanceof n))return new n(e);if("function"!=typeof e)throw new TypeError("reslover must be a function");this.state=s.PENDING,this.queue=[],this.outcome=void 0,e!==o&&i.safely(this,e)}var r=e("./unwrap"),o=e("./INTERNAL"),i=e("./resolveThenable"),s=e("./states"),a=e("./queueItem");t.exports=n,n.prototype["catch"]=function(e){return this.then(null,e)},n.prototype.then=function(e,t){if("function"!=typeof e&&this.state===s.FULFILLED||"function"!=typeof t&&this.state===s.REJECTED)return this;var i=new n(o);if(this.state!==s.PENDING){var u=this.state===s.FULFILLED?e:t;r(i,u,this.outcome)}else this.queue.push(new a(i,e,t));return i}},{"./INTERNAL":30,"./queueItem":35,"./resolveThenable":38,"./states":39,"./unwrap":41}],35:[function(e,t){"use strict";function n(e,t,n){this.promise=e,"function"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),"function"==typeof n&&(this.onRejected=n,this.callRejected=this.otherCallRejected)}var r=e("./handlers"),o=e("./unwrap");t.exports=n,n.prototype.callFulfilled=function(e){r.resolve(this.promise,e)},n.prototype.otherCallFulfilled=function(e){o(this.promise,this.onFulfilled,e)},n.prototype.callRejected=function(e){r.reject(this.promise,e)},n.prototype.otherCallRejected=function(e){o(this.promise,this.onRejected,e)}},{"./handlers":32,"./unwrap":41}],36:[function(e,t){"use strict";function n(e){var t=new r(o);return i.reject(t,e)}var r=e("./promise"),o=e("./INTERNAL"),i=e("./handlers");t.exports=n},{"./INTERNAL":30,"./handlers":32,"./promise":34}],37:[function(e,t){"use strict";function n(e){if(e)return e instanceof r?e:i.resolve(new r(o),e);var t=typeof e;switch(t){case"boolean":return s;case"undefined":return u;case"object":return a;case"number":return c;case"string":return l}}var r=e("./promise"),o=e("./INTERNAL"),i=e("./handlers");t.exports=n;var s=i.resolve(new r(o),!1),a=i.resolve(new r(o),null),u=i.resolve(new r(o),void 0),c=i.resolve(new r(o),0),l=i.resolve(new r(o),"")},{"./INTERNAL":30,"./handlers":32,"./promise":34}],38:[function(e,t,n){"use strict";function r(e,t){function n(t){a||(a=!0,o.reject(e,t))}function r(t){a||(a=!0,o.resolve(e,t))}function s(){t(r,n)}var a=!1,u=i(s);"error"===u.status&&n(u.value)}var o=e("./handlers"),i=e("./tryCatch");n.safely=r},{"./handlers":32,"./tryCatch":40}],39:[function(e,t,n){n.REJECTED=["REJECTED"],n.FULFILLED=["FULFILLED"],n.PENDING=["PENDING"]},{}],40:[function(e,t){"use strict";function n(e,t){var n={};try{n.value=e(t),n.status="success"}catch(r){n.status="error",n.value=r}return n}t.exports=n},{}],41:[function(e,t){"use strict";function n(e,t,n){r(function(){var r;try{r=t(n)}catch(i){return o.reject(e,i)}r===e?o.reject(e,new TypeError("Cannot resolve promise with itself")):o.resolve(e,r)})}var r=e("immediate"),o=e("./handlers");t.exports=n},{"./handlers":32,immediate:42}],42:[function(e,t){"use strict";function n(){o=!0;for(var e,t,n=a.length;n;){for(t=a,a=[],e=-1;++e<n;)t[e]();n=a.length}o=!1}function r(e){1!==a.push(e)||o||i()}for(var o,i,s=[e("./nextTick"),e("./mutation.js"),e("./messageChannel"),e("./stateChange"),e("./timeout")],a=[],u=-1,c=s.length;++u<c;)if(s[u]&&s[u].test&&s[u].test()){i=s[u].install(n);break}t.exports=r},{"./messageChannel":43,"./mutation.js":44,"./nextTick":26,"./stateChange":45,"./timeout":46}],43:[function(e,t,n){(function(e){"use strict";n.test=function(){return e.setImmediate?!1:"undefined"!=typeof e.MessageChannel},n.install=function(t){var n=new e.MessageChannel;return n.port1.onmessage=t,function(){n.port2.postMessage(0)}}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],44:[function(e,t,n){(function(e){"use strict";var t=e.MutationObserver||e.WebKitMutationObserver;n.test=function(){return t},n.install=function(n){var r=0,o=new t(n),i=e.document.createTextNode("");return o.observe(i,{characterData:!0}),function(){i.data=r=++r%2}}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],45:[function(e,t,n){(function(e){"use strict";n.test=function(){return"document"in e&&"onreadystatechange"in e.document.createElement("script")},n.install=function(t){return function(){var n=e.document.createElement("script");return n.onreadystatechange=function(){t(),n.onreadystatechange=null,n.parentNode.removeChild(n),n=null},e.document.documentElement.appendChild(n),t}}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],46:[function(e,t,n){"use strict";n.test=function(){return!0},n.install=function(e){return function(){setTimeout(e,0)}}},{}],47:[function(e,t){"use strict";function n(e){return null===e?String(e):"object"==typeof e||"function"==typeof e?u[f.call(e)]||"object":typeof e}function r(e){return null!==e&&e===e.window}function o(e){if(!e||"object"!==n(e)||e.nodeType||r(e))return!1;try{if(e.constructor&&!p.call(e,"constructor")&&!p.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(t){return!1}var o;for(o in e);return void 0===o||p.call(e,o)}function i(e){return"function"===n(e)}function s(){for(var e=[],t=-1,n=arguments.length,r=new Array(n);++t<n;)r[t]=arguments[t];var o={};e.push({args:r,result:{container:o,key:"key"}});for(var i;i=e.pop();)a(e,i.args,i.result);return o.key}function a(e,t,n){var r,s,a,u,c,l,d,f=t[0]||{},p=1,v=t.length,m=!1,_=/\d+/;for("boolean"==typeof f&&(m=f,f=t[1]||{},p=2),"object"==typeof f||i(f)||(f={}),v===p&&(f=this,--p);v>p;p++)if(null!=(r=t[p])){d=h(r);for(s in r)if(!(s in Object.prototype)){if(d&&!_.test(s))continue;if(a=f[s],u=r[s],f===u)continue;m&&u&&(o(u)||(c=h(u)))?(c?(c=!1,l=a&&h(a)?a:[]):l=a&&o(a)?a:{},e.push({args:[m,l,u],result:{container:f,key:s}})):void 0!==u&&(h(r)&&i(u)||(f[s]=u))}}n.container[n.key]=f}for(var u={},c=["Boolean","Number","String","Function","Array","Date","RegExp","Object","Error"],l=0;l<c.length;l++){var d=c[l];u["[object "+d+"]"]=d.toLowerCase()}var f=u.toString,p=u.hasOwnProperty,h=Array.isArray||function(e){return"array"===n(e)};t.exports=s},{}],48:[function(e,t){"use strict";var n=e("./upsert"),r=e("./utils"),o=r.Promise;t.exports=function(e){var t=e.db,i=e.viewName,s=e.map,a=e.reduce,u=e.temporary,c=s.toString()+(a&&a.toString())+"undefined";if(!u&&t._cachedViews){var l=t._cachedViews[c];if(l)return o.resolve(l)}return t.info().then(function(e){function o(e){e.views=e.views||{};var t=i;-1===t.indexOf("/")&&(t=i+"/"+i);var n=e.views[t]=e.views[t]||{};if(!n[l])return n[l]=!0,e}var l=e.db_name+"-mrview-"+(u?"temp":r.MD5(c));return n(t,"_local/mrviews",o).then(function(){return t.registerDependentDatabase(l).then(function(e){var n=e.db;n.auto_compaction=!0;var r={name:l,db:n,sourceDB:t,adapter:t.adapter,mapFun:s,reduceFun:a};return r.db.get("_local/lastSeq")["catch"](function(e){if(404!==e.status)throw e}).then(function(e){return r.seq=e?e.seq:0,u||(t._cachedViews=t._cachedViews||{},t._cachedViews[c]=r,r.db.on("destroyed",function(){delete t._cachedViews[c]})),r})})})})}},{"./upsert":54,"./utils":55}],49:[function(_dereq_,module,exports){"use strict";module.exports=function(func,emit,sum,log,isArray,toJSON){return eval("'use strict'; ("+func.replace(/;\s*$/,"")+");")}},{}],50:[function(e,t,n){(function(t){"use strict";function r(e){return-1===e.indexOf("/")?[e,e]:e.split("/")}function o(e,t,n){try{return{output:t.apply(null,n)}}catch(r){return e.emit("error",r),{error:r}}}function i(e,t){var n=S(e.key,t.key);return 0!==n?n:S(e.value,t.value)}function s(e,t,n){return n=n||0,"number"==typeof t?e.slice(n,t+n):n>0?e.slice(n):e}function a(e){var t=new Error("builtin "+e+" function requires map values to be numbers or number arrays");return t.name="invalid_value",t.status=500,t}function u(e){for(var t=0,n=0,r=e.length;r>n;n++){var o=e[n];if("number"!=typeof o){if(!Array.isArray(o))throw a("_sum");t="number"==typeof t?[t]:t;for(var i=0,s=o.length;s>i;i++){var u=o[i];if("number"!=typeof u)throw a("_sum");"undefined"==typeof t[i]?t.push(u):t[i]+=u}}else"number"==typeof t?t+=o:t[0]+=o}return t}function c(e,t,n,r){var o=t[e];"undefined"!=typeof o&&(r&&(o=encodeURIComponent(JSON.stringify(o))),n.push(e+"="+o))}function l(e,t){var n=e.descending?"endkey":"startkey",r=e.descending?"startkey":"endkey";if("undefined"!=typeof e[n]&&"undefined"!=typeof e[r]&&S(e[n],e[r])>0)throw new y("No rows can match your key range, reverse your start_key and end_key or set {descending : true}");if(t.reduce&&e.reduce!==!1){if(e.include_docs)throw new y("{include_docs:true} is invalid for reduce");if(e.keys&&e.keys.length>1&&!e.group&&!e.group_level)throw new y("Multi-key fetches for reduce views must use {group: true}")}if(e.group_level){if("number"!=typeof e.group_level)throw new y('Invalid value for integer: "'+e.group_level+'"');if(e.group_level<0)throw new y('Invalid value for positive integer: "'+e.group_level+'"')}}function d(e,t,n){var o,i=[],s="GET";if(c("reduce",n,i),c("include_docs",n,i),c("limit",n,i),c("descending",n,i),c("group",n,i),c("group_level",n,i),c("skip",n,i),c("stale",n,i),c("startkey",n,i,!0),c("endkey",n,i,!0),c("inclusive_end",n,i),c("key",n,i,!0),i=i.join("&"),i=""===i?"":"?"+i,"undefined"!=typeof n.keys){var a=2e3,u="keys="+encodeURIComponent(JSON.stringify(n.keys));u.length+i.length+1<=a?i+=("?"===i[0]?"&":"?")+u:(s="POST","string"==typeof t?o=JSON.stringify({keys:n.keys}):t.keys=n.keys)}if("string"==typeof t){var l=r(t);return e.request({method:s,url:"_design/"+l[0]+"/_view/"+l[1]+i,body:o})}return o=o||{},Object.keys(t).forEach(function(e){o[e]=Array.isArray(t[e])?t[e]:t[e].toString()}),e.request({method:"POST",url:"_temp_view"+i,body:o})}function f(e){return function(t){if(404===t.status)return e;throw t}}function p(e,t,n){var r="_local/doc_"+e;return t.db.get(r)["catch"](f({_id:r,keys:[]})).then(function(r){return O.resolve().then(function(){return r.keys.length?t.db.allDocs({keys:r.keys,include_docs:!0}):{rows:[]}}).then(function(t){var o=t.rows.map(function(e){return e.doc}).filter(function(e){return e}),i=n[e],s={};o.forEach(function(e){if(s[e._id]=!0,e._deleted=!i[e._id],!e._deleted){var t=i[e._id];"value"in t&&(e.value=t.value)}});var a=Object.keys(i);return a.forEach(function(e){if(!s[e]){var t={_id:e},n=i[e];"value"in n&&(t.value=n.value),o.push(t)}}),r.keys=A.uniq(a.concat(r.keys)),o.splice(0,0,r),o})})}function h(e,t,n){var r="_local/lastSeq";return e.db.get(r)["catch"](f({_id:r,seq:0})).then(function(r){var o=Object.keys(t);return O.all(o.map(function(n){return p(n,e,t)})).then(function(t){var o=[];return t.forEach(function(e){o=o.concat(e)}),r.seq=n,o.push(r),e.db.bulkDocs({docs:o})})})}function v(e,t,n){0===n.group_level&&delete n.group_level;var r,i=n.group||n.group_level;r=D[e.reduceFun]?D[e.reduceFun]:T(e.reduceFun.toString(),null,u,b,Array.isArray,JSON.parse);var a=[],c=n.group_level;t.forEach(function(e){var t=a[a.length-1],n=i?e.key:null;return i&&Array.isArray(n)&&"number"==typeof c&&(n=n.length>c?n.slice(0,c):n),t&&0===S(t.key[0][0],n)?(t.key.push([n,e.id]),void t.value.push(e.value)):void a.push({key:[[n,e.id]],value:[e.value]})});for(var l=0,d=a.length;d>l;l++){var f=a[l],p=o(e.sourceDB,r,[f.key,f.value,!1]);f.value=p.error?null:p.output,f.key=f.key[0][0]}return{rows:s(a,n.limit,n.skip)}}function m(e){return e.request({method:"POST",url:"_view_cleanup"})}function _(e,n,o){if("http"===e.type())return d(e,n,o);if("string"!=typeof n){l(o,n);var i={db:e,viewName:"temp_view/temp_view",map:n.map,reduce:n.reduce,temporary:!0};return R.add(function(){return q(i).then(function(e){function t(){return e.db.destroy()}return A.fin(C(e).then(function(){return N(e,o)}),t)})}),R.finish()}var s=n,a=r(s),u=a[0],c=a[1];return e.get("_design/"+u).then(function(n){var r=n.views&&n.views[c];if(!r||"string"!=typeof r.map)throw new g("ddoc "+u+" has no view named "+c);l(o,r);var i={db:e,viewName:s,map:r.map,reduce:r.reduce};return q(i).then(function(e){return"ok"===o.stale||"update_after"===o.stale?("update_after"===o.stale&&t.nextTick(function(){C(e)}),N(e,o)):C(e).then(function(){return N(e,o)})})})}function y(e){this.status=400,this.name="query_parse_error",this.message=e,this.error=!0;try{Error.captureStackTrace(this,y)}catch(t){}}function g(e){this.status=404,this.name="not_found",this.message=e,this.error=!0;try{Error.captureStackTrace(this,g)}catch(t){}}var b,w=e("pouchdb-collate"),E=e("./taskqueue"),S=w.collate,k=w.toIndexableString,x=w.normalizeKey,q=e("./create-view"),T=e("./evalfunc");b="undefined"!=typeof console&&"function"==typeof console.log?Function.prototype.bind.call(console.log,console):function(){};var A=e("./utils"),O=A.Promise,L=new E,R=new E,I=50,D={_sum:function(e,t){return u(t)},_count:function(e,t){return t.length},_stats:function(e,t){function n(e){for(var t=0,n=0,r=e.length;r>n;n++){var o=e[n];t+=o*o}return t}return{sum:u(t),min:Math.min.apply(null,t),max:Math.max.apply(null,t),count:t.length,sumsqr:n(t)}}},C=A.sequentialize(L,function(e){function t(e,t){var n={id:s._id,key:x(e)};"undefined"!=typeof t&&null!==t&&(n.value=x(t)),r.push(n)}function n(t,n){return function(){return h(e,t,n)}}var r,s,a;if("function"==typeof e.mapFun&&2===e.mapFun.length){var c=e.mapFun;a=function(e){return c(e,t)}}else a=T(e.mapFun.toString(),t,u,b,Array.isArray,JSON.parse);var l=e.seq||0,d=new E;return new O(function(t,u){function c(){d.finish().then(function(){e.seq=l,t()})}function f(){function t(e){u(e)}e.sourceDB.changes({conflicts:!0,include_docs:!0,since:l,limit:I}).on("complete",function(t){var u=t.results;if(!u.length)return c();for(var p={},h=0,v=u.length;v>h;h++){var m=u[h];if("_"!==m.doc._id[0]){r=[],s=m.doc,s._deleted||o(e.sourceDB,a,[s]),r.sort(i);for(var _,y={},g=0,b=r.length;b>g;g++){var w=r[g],E=[w.key,w.id];w.key===_&&E.push(g);var S=k(E);y[S]=w,_=w.key}p[m.doc._id]=y}l=m.seq}return d.add(n(p,l)),u.length<I?c():f()}).on("error",t)}f()})}),N=A.sequentialize(L,function(e,t){function n(t){return t.include_docs=!0,e.db.allDocs(t).then(function(e){return o=e.total_rows,e.rows.map(function(e){if("value"in e.doc&&"object"==typeof e.doc.value&&null!==e.doc.value){var t=Object.keys(e.doc.value).sort(),n=["id","key","value"];if(!(n>t||t>n))return e.doc.value}var r=w.parseIndexableString(e.doc._id);return{key:r[0],id:r[1],value:"value"in e.doc?e.doc.value:null}})})}function r(n){var r;if(r=i?v(e,n,t):{total_rows:o,offset:s,rows:n},t.include_docs){var a=n.map(function(t){var n=t.value,r=n&&"object"==typeof n&&n._id||t.id;return e.sourceDB.get(r).then(function(e){t.doc=e},function(){})});return O.all(a).then(function(){return r})}return r}var o,i=e.reduceFun&&t.reduce!==!1,s=t.skip||0;"undefined"==typeof t.keys||t.keys.length||(t.limit=0,delete t.keys);var a=function(e){return e.reduce(function(e,t){return e.concat(t)})};if("undefined"!=typeof t.keys){var u=t.keys,c=u.map(function(e){var t={startkey:k([e]),endkey:k([e,{}])};return n(t)});return O.all(c).then(a).then(r)}var l={descending:t.descending};if("undefined"!=typeof t.startkey&&(l.startkey=k(t.descending?[t.startkey,{}]:[t.startkey])),"undefined"!=typeof t.endkey){var d=t.inclusive_end!==!1;t.descending&&(d=!d),l.endkey=k(d?[t.endkey,{}]:[t.endkey])}if("undefined"!=typeof t.key){var f=k([t.key]),p=k([t.key,{}]);l.descending?(l.endkey=f,l.startkey=p):(l.startkey=f,l.endkey=p)}return i||("number"==typeof t.limit&&(l.limit=t.limit),l.skip=s),n(l).then(r)}),j=A.sequentialize(L,function(e){return e.get("_local/mrviews").then(function(t){var n={};Object.keys(t.views).forEach(function(e){var t=r(e),o="_design/"+t[0],i=t[1];n[o]=n[o]||{},n[o][i]=!0});var o={keys:Object.keys(n),include_docs:!0};return e.allDocs(o).then(function(r){var o={};r.rows.forEach(function(e){var r=e.key.substring(8);Object.keys(n[e.key]).forEach(function(n){var i=r+"/"+n;t.views[i]||(i=n);var s=Object.keys(t.views[i]),a=e.doc&&e.doc.views&&e.doc.views[n];s.forEach(function(e){o[e]=o[e]||a})})});var i=Object.keys(o).filter(function(e){return!o[e]}),s=i.map(function(t){return e.constructor.destroy(t,{adapter:e.adapter})});return O.all(s).then(function(){return{ok:!0}})})},f({ok:!0}))});n.viewCleanup=A.callbackify(function(){var e=this;return"http"===e.type()?m(e):j(e)}),n.query=function(e,t,n){"function"==typeof t&&(n=t,t={}),t=A.extend(!0,{},t),"function"==typeof e&&(e={map:e});var r=this,o=O.resolve().then(function(){return _(r,e,t)});return A.promisedCallback(o,n),o},A.inherits(y,Error),A.inherits(g,Error)}).call(this,e("/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))},{"./create-view":48,"./evalfunc":49,"./taskqueue":53,"./utils":55,"/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":28,"pouchdb-collate":51}],51:[function(e,t,n){"use strict";function r(e){if(null!==e)switch(typeof e){case"boolean":return e?1:0;case"number":return l(e);case"string":return e.replace(/\u0002/g,"").replace(/\u0001/g,"").replace(/\u0000/g,"");case"object":var t=Array.isArray(e),r=t?e:Object.keys(e),o=-1,i=r.length,s="";if(t)for(;++o<i;)s+=n.toIndexableString(r[o]);else for(;++o<i;){var a=r[o];s+=n.toIndexableString(a)+n.toIndexableString(e[a])}return s}return""}function o(e,t){var n,r=t,o="1"===e[t];if(o)n=0,t++;else{var i="0"===e[t];t++;var s="",a=e.substring(t,t+f),u=parseInt(a,10)+d;for(i&&(u=-u),t+=f;;){var c=e[t];if("\x00"===c)break;s+=c,t++}s=s.split("."),n=1===s.length?parseInt(s,10):parseFloat(s[0]+"."+s[1]),i&&(n-=10),0!==u&&(n=parseFloat(n+"e"+u))}return{num:n,length:t-r}}function i(e,t){var n=e.pop();if(t.length){var r=t[t.length-1];n===r.element&&(t.pop(),r=t[t.length-1]);var o=r.element,i=r.index;if(Array.isArray(o))o.push(n);else if(i===e.length-2){var s=e.pop();o[s]=n}else e.push(n)}}function s(e,t){for(var r=Math.min(e.length,t.length),o=0;r>o;o++){var i=n.collate(e[o],t[o]);if(0!==i)return i}return e.length===t.length?0:e.length>t.length?1:-1}function a(e,t){return e===t?0:e>t?1:-1}function u(e,t){for(var r=Object.keys(e),o=Object.keys(t),i=Math.min(r.length,o.length),s=0;i>s;s++){var a=n.collate(r[s],o[s]);if(0!==a)return a;if(a=n.collate(e[r[s]],t[o[s]]),0!==a)return a}return r.length===o.length?0:r.length>o.length?1:-1}function c(e){var t=["boolean","number","string","object"],n=t.indexOf(typeof e);return~n?null===e?1:Array.isArray(e)?5:3>n?n+2:n+3:Array.isArray(e)?5:void 0}function l(e){if(0===e)return"1";var t=e.toExponential().split(/e\+?/),n=parseInt(t[1],10),r=0>e,o=r?"0":"2",i=(r?-n:n)-d,s=h.padLeft(i.toString(),"0",f);o+=p+s;var a=Math.abs(parseFloat(t[0]));r&&(a=10-a);var u=a.toFixed(20);return u=u.replace(/\.?0+$/,""),o+=p+u}var d=-324,f=3,p="",h=e("./utils");n.collate=function(e,t){if(e===t)return 0;e=n.normalizeKey(e),t=n.normalizeKey(t);var r=c(e),o=c(t);if(r-o!==0)return r-o;if(null===e)return 0;switch(typeof e){case"number":return e-t;case"boolean":return e===t?0:t>e?-1:1;case"string":return a(e,t)}return Array.isArray(e)?s(e,t):u(e,t)},n.normalizeKey=function(e){switch(typeof e){case"undefined":return null;case"number":return 1/0===e||e===-1/0||isNaN(e)?null:e;case"object":var t=e;if(Array.isArray(e)){var r=e.length;e=new Array(r);for(var o=0;r>o;o++)e[o]=n.normalizeKey(t[o])}else{if(e instanceof Date)return e.toJSON();if(null!==e){e={};for(var i in t)if(t.hasOwnProperty(i)){var s=t[i];"undefined"!=typeof s&&(e[i]=n.normalizeKey(s))}}}}return e},n.toIndexableString=function(e){var t="\x00";return e=n.normalizeKey(e),c(e)+p+r(e)+t},n.parseIndexableString=function(e){for(var t=[],n=[],r=0;;){var s=e[r++];if("\x00"!==s)switch(s){case"1":t.push(null);break;case"2":t.push("1"===e[r]),r++;break;case"3":var a=o(e,r);t.push(a.num),r+=a.length;break;case"4":for(var u="";;){var c=e[r];if("\x00"===c)break;u+=c,r++}u=u.replace(/\u0001\u0001/g,"\x00").replace(/\u0001\u0002/g,"").replace(/\u0002\u0002/g,""),t.push(u);break;case"5":var l={element:[],index:t.length};t.push(l.element),n.push(l);break;case"6":var d={element:{},index:t.length};t.push(d.element),n.push(d);break;default:throw new Error("bad collationIndex or unexpectedly reached end of input: "+s)}else{if(1===t.length)return t.pop();i(t,n)}}}},{"./utils":52}],52:[function(e,t,n){"use strict";function r(e,t,n){for(var r="",o=n-e.length;r.length<o;)r+=t;return r}n.padLeft=function(e,t,n){var o=r(e,t,n);return o+e},n.padRight=function(e,t,n){var o=r(e,t,n);return e+o},n.stringLexCompare=function(e,t){var n,r=e.length,o=t.length;for(n=0;r>n;n++){if(n===o)return 1;var i=e.charAt(n),s=t.charAt(n);if(i!==s)return s>i?-1:1}return o>r?-1:0},n.intToDecimalForm=function(e){var t=0>e,n="";do{var r=t?-Math.ceil(e%10):Math.floor(e%10);n=r+n,e=t?Math.ceil(e/10):Math.floor(e/10)}while(e);return t&&"0"!==n&&(n="-"+n),n}},{}],53:[function(e,t){"use strict";function n(){this.promise=new r(function(e){e()})}var r=e("./utils").Promise;n.prototype.add=function(e){return this.promise=this.promise["catch"](function(){}).then(function(){return e()}),this.promise},n.prototype.finish=function(){return this.promise},t.exports=n},{"./utils":55}],54:[function(e,t){"use strict";function n(e,t,n){return new o(function(o,i){return t&&"object"==typeof t&&(t=t._id),"string"!=typeof t?i(new Error("doc id is required")):void e.get(t,function(s,a){if(s)return 404!==s.status?i(s):o(r(e,n({_id:t}),n));var u=n(a);return u?void o(r(e,u,n)):o(a)})})}function r(e,t,r){return e.put(t)["catch"](function(o){if(409!==o.status)throw o;return n(e,t,r)})}var o=e("./utils").Promise;t.exports=n},{"./utils":55}],55:[function(e,t,n){(function(t,r){"use strict";n.Promise="function"==typeof r.Promise?r.Promise:e("lie"),n.uniq=function(e){var t={};return e.forEach(function(e){t[e]=!0}),Object.keys(t)},n.inherits=e("inherits"),n.extend=e("pouchdb-extend");var o=e("argsarray");n.promisedCallback=function(e,n){return n&&e.then(function(e){t.nextTick(function(){n(null,e)})},function(e){t.nextTick(function(){n(e)})}),e},n.callbackify=function(e){return o(function(t){var r=t.pop(),o=e.apply(this,t);return"function"==typeof r&&n.promisedCallback(o,r),o})},n.fin=function(e,t){return e.then(function(e){var n=t();return"function"==typeof n.then?n.then(function(){return e}):e},function(e){var n=t();if("function"==typeof n.then)return n.then(function(){throw e});throw e})},n.sequentialize=function(e,t){return function(){var n=arguments,r=this;return e.add(function(){return t.apply(r,n)})}};var i=e("crypto"),s=e("spark-md5");n.MD5=function(e){return t.browser?s.hash(e):i.createHash("md5").update(e).digest("hex")}}).call(this,e("/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"/Users/nolan/workspace/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":28,argsarray:25,crypto:26,inherits:29,lie:33,"pouchdb-extend":47,"spark-md5":56}],56:[function(e,t,n){!function(e){if("object"==typeof n)t.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var r;try{r=window}catch(o){r=self}r.SparkMD5=e()}}(function(){"use strict";var e=function(e,t){return e+t&4294967295},t=function(t,n,r,o,i,s){return n=e(e(n,t),e(o,s)),e(n<<i|n>>>32-i,r)},n=function(e,n,r,o,i,s,a){return t(n&r|~n&o,e,n,i,s,a)},r=function(e,n,r,o,i,s,a){return t(n&o|r&~o,e,n,i,s,a)},o=function(e,n,r,o,i,s,a){return t(n^r^o,e,n,i,s,a)},i=function(e,n,r,o,i,s,a){return t(r^(n|~o),e,n,i,s,a)},s=function(t,s){var a=t[0],u=t[1],c=t[2],l=t[3];a=n(a,u,c,l,s[0],7,-680876936),l=n(l,a,u,c,s[1],12,-389564586),c=n(c,l,a,u,s[2],17,606105819),u=n(u,c,l,a,s[3],22,-1044525330),a=n(a,u,c,l,s[4],7,-176418897),l=n(l,a,u,c,s[5],12,1200080426),c=n(c,l,a,u,s[6],17,-1473231341),u=n(u,c,l,a,s[7],22,-45705983),a=n(a,u,c,l,s[8],7,1770035416),l=n(l,a,u,c,s[9],12,-1958414417),c=n(c,l,a,u,s[10],17,-42063),u=n(u,c,l,a,s[11],22,-1990404162),a=n(a,u,c,l,s[12],7,1804603682),l=n(l,a,u,c,s[13],12,-40341101),c=n(c,l,a,u,s[14],17,-1502002290),u=n(u,c,l,a,s[15],22,1236535329),a=r(a,u,c,l,s[1],5,-165796510),l=r(l,a,u,c,s[6],9,-1069501632),c=r(c,l,a,u,s[11],14,643717713),u=r(u,c,l,a,s[0],20,-373897302),a=r(a,u,c,l,s[5],5,-701558691),l=r(l,a,u,c,s[10],9,38016083),c=r(c,l,a,u,s[15],14,-660478335),u=r(u,c,l,a,s[4],20,-405537848),a=r(a,u,c,l,s[9],5,568446438),l=r(l,a,u,c,s[14],9,-1019803690),c=r(c,l,a,u,s[3],14,-187363961),u=r(u,c,l,a,s[8],20,1163531501),a=r(a,u,c,l,s[13],5,-1444681467),l=r(l,a,u,c,s[2],9,-51403784),c=r(c,l,a,u,s[7],14,1735328473),u=r(u,c,l,a,s[12],20,-1926607734),a=o(a,u,c,l,s[5],4,-378558),l=o(l,a,u,c,s[8],11,-2022574463),c=o(c,l,a,u,s[11],16,1839030562),u=o(u,c,l,a,s[14],23,-35309556),a=o(a,u,c,l,s[1],4,-1530992060),l=o(l,a,u,c,s[4],11,1272893353),c=o(c,l,a,u,s[7],16,-155497632),u=o(u,c,l,a,s[10],23,-1094730640),a=o(a,u,c,l,s[13],4,681279174),l=o(l,a,u,c,s[0],11,-358537222),c=o(c,l,a,u,s[3],16,-722521979),u=o(u,c,l,a,s[6],23,76029189),a=o(a,u,c,l,s[9],4,-640364487),l=o(l,a,u,c,s[12],11,-421815835),c=o(c,l,a,u,s[15],16,530742520),u=o(u,c,l,a,s[2],23,-995338651),a=i(a,u,c,l,s[0],6,-198630844),l=i(l,a,u,c,s[7],10,1126891415),c=i(c,l,a,u,s[14],15,-1416354905),u=i(u,c,l,a,s[5],21,-57434055),a=i(a,u,c,l,s[12],6,1700485571),l=i(l,a,u,c,s[3],10,-1894986606),c=i(c,l,a,u,s[10],15,-1051523),u=i(u,c,l,a,s[1],21,-2054922799),a=i(a,u,c,l,s[8],6,1873313359),l=i(l,a,u,c,s[15],10,-30611744),c=i(c,l,a,u,s[6],15,-1560198380),u=i(u,c,l,a,s[13],21,1309151649),a=i(a,u,c,l,s[4],6,-145523070),l=i(l,a,u,c,s[11],10,-1120210379),c=i(c,l,a,u,s[2],15,718787259),u=i(u,c,l,a,s[9],21,-343485551),t[0]=e(a,t[0]),t[1]=e(u,t[1]),t[2]=e(c,t[2]),t[3]=e(l,t[3])},a=function(e){var t,n=[];for(t=0;64>t;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n},u=function(e){var t,n=[];for(t=0;64>t;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n},c=function(e){var t,n,r,o,i,u,c=e.length,l=[1732584193,-271733879,-1732584194,271733878];for(t=64;c>=t;t+=64)s(l,a(e.substring(t-64,t)));for(e=e.substring(t-64),n=e.length,r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;n>t;t+=1)r[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(r[t>>2]|=128<<(t%4<<3),t>55)for(s(l,r),t=0;16>t;t+=1)r[t]=0;return o=8*c,o=o.toString(16).match(/(.*?)(.{0,8})$/),i=parseInt(o[2],16),u=parseInt(o[1],16)||0,r[14]=i,r[15]=u,s(l,r),l},l=function(e){var t,n,r,o,i,a,c=e.length,l=[1732584193,-271733879,-1732584194,271733878];for(t=64;c>=t;t+=64)s(l,u(e.subarray(t-64,t)));for(e=c>t-64?e.subarray(t-64):new Uint8Array(0),n=e.length,r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;n>t;t+=1)r[t>>2]|=e[t]<<(t%4<<3);if(r[t>>2]|=128<<(t%4<<3),t>55)for(s(l,r),t=0;16>t;t+=1)r[t]=0;return o=8*c,o=o.toString(16).match(/(.*?)(.{0,8})$/),i=parseInt(o[2],16),a=parseInt(o[1],16)||0,r[14]=i,r[15]=a,s(l,r),l},d=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"],f=function(e){var t,n="";for(t=0;4>t;t+=1)n+=d[e>>8*t+4&15]+d[e>>8*t&15];return n},p=function(e){var t;for(t=0;t<e.length;t+=1)e[t]=f(e[t]);return e.join("")},h=function(e){return p(c(e))},v=function(){this.reset()};return"5d41402abc4b2a76b9719d911017c592"!==h("hello")&&(e=function(e,t){var n=(65535&e)+(65535&t),r=(e>>16)+(t>>16)+(n>>16);return r<<16|65535&n}),v.prototype.append=function(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),this.appendBinary(e),this},v.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var t,n=this._buff.length;for(t=64;n>=t;t+=64)s(this._state,a(this._buff.substring(t-64,t)));return this._buff=this._buff.substr(t-64),this},v.prototype.end=function(e){var t,n,r=this._buff,o=r.length,i=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;o>t;t+=1)i[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(i,o),n=e?this._state:p(this._state),this.reset(),n},v.prototype._finish=function(e,t){var n,r,o,i=t;if(e[i>>2]|=128<<(i%4<<3),i>55)for(s(this._state,e),i=0;16>i;i+=1)e[i]=0;n=8*this._length,n=n.toString(16).match(/(.*?)(.{0,8})$/),r=parseInt(n[2],16),o=parseInt(n[1],16)||0,e[14]=r,e[15]=o,s(this._state,e)},v.prototype.reset=function(){return this._buff="",this._length=0,this._state=[1732584193,-271733879,-1732584194,271733878],this},v.prototype.destroy=function(){delete this._state,delete this._buff,delete this._length},v.hash=function(e,t){/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e)));var n=c(e);return t?n:p(n)},v.hashBinary=function(e,t){var n=c(e);return t?n:p(n)},v.ArrayBuffer=function(){this.reset()},v.ArrayBuffer.prototype.append=function(e){var t,n=this._concatArrayBuffer(this._buff,e),r=n.length;for(this._length+=e.byteLength,t=64;r>=t;t+=64)s(this._state,u(n.subarray(t-64,t)));return this._buff=r>t-64?n.subarray(t-64):new Uint8Array(0),this},v.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,i=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;o>t;t+=1)i[t>>2]|=r[t]<<(t%4<<3);return this._finish(i,o),n=e?this._state:p(this._state),this.reset(),n},v.ArrayBuffer.prototype._finish=v.prototype._finish,v.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._state=[1732584193,-271733879,-1732584194,271733878],this},v.ArrayBuffer.prototype.destroy=v.prototype.destroy,v.ArrayBuffer.prototype._concatArrayBuffer=function(e,t){var n=e.length,r=new Uint8Array(n+t.byteLength);return r.set(e),r.set(new Uint8Array(t),n),r},v.ArrayBuffer.hash=function(e,t){var n=l(new Uint8Array(e));return t?n:p(n)},v})},{}],57:[function(e,t,n){"use strict";function r(e,t,n){var r=n[n.length-1];e===r.element&&(n.pop(),r=n[n.length-1]);var o=r.element,i=r.index;if(Array.isArray(o))o.push(e);else if(i===t.length-2){var s=t.pop();o[s]=e}else t.push(e)}n.stringify=function(e){var t=[];t.push({obj:e});for(var n,r,o,i,s,a,u,c,l,d,f,p="";n=t.pop();)if(r=n.obj,o=n.prefix||"",i=n.val||"",p+=o,i)p+=i;else if("object"!=typeof r)p+="undefined"==typeof r?null:JSON.stringify(r);else if(null===r)p+="null";else if(Array.isArray(r)){for(t.push({val:"]"}),s=r.length-1;s>=0;s--)a=0===s?"":",",t.push({obj:r[s],prefix:a});t.push({val:"["})}else{u=[];for(c in r)r.hasOwnProperty(c)&&u.push(c);for(t.push({val:"}"}),s=u.length-1;s>=0;s--)l=u[s],d=r[l],f=s>0?",":"",f+=JSON.stringify(l)+":",t.push({obj:d,prefix:f});t.push({val:"{"})}return p},n.parse=function(e){for(var t,n,o,i,s,a,u,c,l,d=[],f=[],p=0;;)if(t=e[p++],"}"!==t&&"]"!==t&&"undefined"!=typeof t)switch(t){case" ":case"	":case"\n":case":":case",":break;case"n":p+=3,r(null,d,f);break;case"t":p+=3,r(!0,d,f);break;case"f":p+=4,r(!1,d,f);break;case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case"-":for(n="",p--;;){if(o=e[p++],!/[\d\.\-e\+]/.test(o)){p--;break}n+=o}r(parseFloat(n),d,f);break;case'"':for(i="",s=void 0,a=0;;){if(u=e[p++],'"'===u&&("\\"!==s||a%2!==1))break;i+=u,s=u,"\\"===s?a++:a=0}r(JSON.parse('"'+i+'"'),d,f);break;case"[":c={element:[],index:d.length},d.push(c.element),f.push(c);break;case"{":l={element:{},index:d.length},d.push(l.element),f.push(l);break;default:throw new Error("unexpectedly reached end of input: "+t)}else{if(1===d.length)return d.pop();r(d.pop(),d,f)}}},{}]},{},[17])(17)});;
(function(){var $$=this,$=this.IntelliFactory.Runtime,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D;$.Define($$,{WebSharper:{Samples:{PouchDB:{Client:{AccordionId:$.Field(function(){return"accordion";}),Accordions:$.Field(function(){var E;E=a.ofArray([d.Attr().NewAttr("id",g.AccordionId()),d.Attr().NewAttr("class","panel-group")]);return h.Tags().NewTag("div",E);}),AdderPiglet:$.Field(function(){var F,I,N,R,S,T;F=function(G){return i.iter(function(H){return H.setOption("mode",g.LangMode(G.Language));},g.cm());};N=$.New(n,{$:0});I=k.op_LessMultiplyGreater(k.op_LessMultiplyGreater(l.Return(function(J){return function(K){return m.flip(function(L){return function(M){return g.mkSnippet(L,M);};},J,K);};}),l.Yield("")),N.Bind(l.Yield({$:0}),function(O){return O.$==3?N.ReturnFrom(l.Map(function(P){return{$:3,$0:P.$0};},l.Yield({$:1,$0:""}))):N.ReturnFrom(l.Map(function(Q){return m.cnst(O,Q);},l.Yield({$:0})));}));R=l.Run(F,I);S=l.WithSubmit(R);T=l.Run(function(U){var V;V=o.now();g.db().put(U,p(V)).then(function(){var X;X=g.SnippetToString(U,new o(V));q.iter(function(Y){return r(g.Accordions().Dom).prepend(Y.Dom).ready(function(){return Y.Render();});},a.rev(g.MkPanel($$.String(V),g.AccordionId(),X,g.CodePre(U.Code))));return r(".saved-modal").modal("show");});return;},S);return l.Render(function(_0){return function(_1){return function(_2){var _3,_4,_5,_6,_7,_8,_9,bb,bd;_3=s.CodeMirror(_0);_4=_3[0];_5=_3[1];_6=a.ofArray([h.Tags().text("Code")]);_4.AppendN(h.Tags().NewTag("label",_6).Dom);_7={$:1,$0:_5};g.cm=function(){return _7;};_8=t.Submit(_2);_8["HtmlProvider@33"].AddClass(_8.get_Body(),"btn btn-primary");_9=a.ofArray([d.Attr().NewAttr("class","form-horizontal")]);bb=$.New(v,{$:0});u.OnAfterRender(function(){return _5.setValue("");},_4);bd=$.New(v,{$:0});return u.add(h.Tags().NewTag("div",_9),a.ofArray([_1.Chooser(function(_){return m.FormControl("",t.Select(_,a.map(function(ba){return[ba,g.LangName(ba)];},g.Languages("Other"))));}),t.RenderChoice(_1,function(bc){return s.InputOption(bc);},h.Tags().NewTag("div",bb)),_4,_8,t.ShowResult(_2,function(be){return be.$==1?a.map(function(bf){var bg;bg=bf.get_Message();return h.Tags().text(bg);},be.$0):$.New(v,{$:0});},h.Tags().NewTag("div",bd))]));};};},T);}),CodePre:function(bh){var bi,bj;bj=a.ofArray([d.Attr().NewAttr("class","prettyprint linenums")]);bi=u.add(h.Tags().NewTag("pre",bj),a.ofArray([h.Tags().text(bh)]));u.OnAfterRender(function(){return $$.prettyPrint();},bi);return bi;},Data:$.Field(function(){return function(bl){return function(bm){return d.Attr().NewAttr("data-"+bl,bm);};};}),Defaults:{PopulateDb:function(bn){return m.op_BarMultiplyGreater(w.Delay(function(){return w.Bind(m["Promise`1.ToAsync"](bn.info()),function(bp){return bp.doc_count===0?w.Parallel(a.map(function(bq){return m["Promise`1.ToAsync"](bn.put(g.mkSnippet(bq[0],bq[1]),$$.String(o.now())));},x.codes())):w.Return([]);});}),function(){});},codes:$.Field(function(){return a.ofArray([[{$:0},m["String.StripMargin"]("\n                        |fibs :: [Integer]\n                        |fibs = 0 : scanl (+) 1 fibs\n                        |\n                        |main = print (take 10 fibs)","|")],[{$:1},m["String.StripMargin"]("\n                        |object Main extends App {\n                        |    val fibs: Stream[BigInt] = BigInt(0) #:: fibs.scan(BigInt(1))(_ + _)\n                        |    fibs take 10 foreach println\n                        |}","|")],[{$:2},m["String.StripMargin"]("\n                        #let fibs =\n                        #    let rec helper a b =\n                        #        seq {\n                        #            yield a;\n                        #            yield! helper b (a + b)\n                        #        }\n                        #    helper 0 1\n                        #\n                        #fibs\n                        #|> Seq.take 10\n                        #|> Seq.iter (printfn \"%d\")","#")]]);})},LangMode:function(bs){return bs.$==1?"text/x-scala":bs.$==2?"text/x-ocaml":bs.$==3?bs.$0.toLowerCase():"text/x-haskell";},LangName:function(bt){return bt.$==1?"Scala":bt.$==2?"F#":bt.$==3?bt.$0:"Haskell";},Languages:function(bu){return a.ofArray([{$:0},{$:1},{$:2},{$:3,$0:bu}]);},Main:$.Field(function(){return w.Start(w.Delay(function(){return w.Bind(x.PopulateDb(g.db()),function(){var bx,by;by=a.ofArray([d.Attr().NewAttr("style","margin: 0 auto; width: 50%; min-width: 400px")]);bx=u.add(h.Tags().NewTag("div",by),a.ofArray([g.AdderPiglet(),g.Accordions()]));g.RefreshSnippets(g.Accordions());bx.AppendTo("container");return w.Return(null);});}),{$:0});}),MkPanel:function(bz,bA,bB,bC){var bD,bE,bF,bG,bH,bI;bD=a.ofArray([d.Attr().NewAttr("class","panel-heading")]);bE=a.ofArray([d.Attr().NewAttr("class","panel-title")]);bG="#"+bz;bF=a.ofArray([((g.Data())("toggle"))("collapse"),((g.Data())("parent"))(bA),d.Attr().NewAttr("href",bG)]);bH=a.ofArray([d.Attr().NewAttr("id",bz),d.Attr().NewAttr("class","panel-collapse collapse")]);bI=a.ofArray([d.Attr().NewAttr("class","panel-body")]);return a.ofArray([u.add(h.Tags().NewTag("div",bD),a.ofArray([u.add(h.Tags().NewTag("h4",bE),a.ofArray([u.add(h.Tags().NewTag("a",bF),a.ofArray([h.Tags().text(bB)]))]))])),u.add(h.Tags().NewTag("div",bH),a.ofArray([u.add(h.Tags().NewTag("div",bI),a.ofArray([bC]))]))]);},RefreshSnippets:function(bJ){var bK;bK=function(bL){return bJ.AppendI(bL);};return w.Start(m.op_BarMultiplyGreater(g.RenderSnippets(),function(bM){return q.iter(bK,bM);}),{$:0});},RenderSnippets:$.Field(function(){return w.Delay(function(){return w.Bind(m["Promise`1.ToAsync"](g.db().allDocs({include_docs:true,descending:true})),function(bO){return w.Return(a.concat(a.map(function(bP){var bQ;bQ=g.SnippetToString(bP.doc,new o($$.parseInt(bP.id,10)));return g.MkPanel(bP.id,g.AccordionId(),bQ,g.CodePre(bP.doc.Code));},a.ofArray(bO.rows))));});});}),SnippetToString:function(bR,bS){return g.LangName(bR.Language)+" - "+bS.toLocaleString();},cm:$.Field(function(){return{$:0};}),db:$.Field(function(){return new y("snippetdb");}),mkSnippet:function(bT,bU){return{Language:bT,Code:bU};}},Controls:{CodeMirror:function(bV){var bW,bX,bY,b1;bW=$.New(v,{$:0});bX=h.Tags().NewTag("div",bW);bY=new z(function(bZ){return u.OnAfterRender(function(b0){return b0.AppendN(bZ);},bX);},{lineNumbers:true});b1=bV.get_Latest();if(b1.$==1){}else{bY.setValue(b1.$0);}bV.Subscribe(function(b2){var b3;if(b2.$==1){return null;}else{b3=b2.$0;return bY.getValue()!==b3?bY.setValue(b3):null;}});z.on(bY,"change",function(b4){return bV.Trigger($.New(A,{$:0,$0:b4.getValue()}));});return[bX,bY];},InputOption:function(b5){var b6,b7,b8,b$,cc,cf,cg;b6=$.New(v,{$:0});b7=h.Tags().NewTag("div",b6);b8=function(){return function(b_){return b_;};};b$=B.Map(function(ca){return i.fold(b8,"",ca);},function(cb){return{$:1,$0:cb};},b5);cc=t.input("text",function(cd){return cd;},function(ce){return ce;},b$);cf=m.FormControl("Language",cc);cg=[false];b5.Subscribe(function(ch){if(ch.$==0){if(ch.$0.$==1){if(!cg[0]){b7.AppendN(cf.Dom);cg[0]=true;return;}else{return null;}}else{if(cg[0]){b7["HtmlProvider@33"].Clear(b7.get_Body());cg[0]=false;return;}else{return null;}}}else{return null;}});return b7;}},Utils:{FormControl:function(ci,cj){var ck,cl;cj["HtmlProvider@33"].AddClass(cj.get_Body(),"form-control");ck=a.ofArray([d.Attr().NewAttr("class","form-group")]);cl=a.ofArray([d.Attr().NewAttr("for",cj.get_Id()),h.Tags().text(ci)]);return u.add(h.Tags().NewTag("div",ck),a.ofArray([h.Tags().NewTag("label",cl),cj]));},"Promise`1.ToAsync":function(cm){return w.FromContinuations(function(cn){cm.then(cn[0],cn[1]);});},"String.StripMargin":function(co,cp){return C.concat("\n",D.map(function(cq){var cr;cr=cq.indexOf(cp);return cr>=0?cq.substring(cr+1):cq;},C.SplitChars(co,[13,10],1)));},cnst:function(cs){return cs;},flip:function(cu,cv,cw){return(cu(cw))(cv);},op_BarMultiplyGreater:function(cx,cy){return w.Delay(function(){return w.Bind(cx,function(cA){return w.Return(cy(cA));});});}}}}}});$.OnInit(function(){a=$.Safe($$.WebSharper.List);b=$.Safe($$.WebSharper.Html);c=$.Safe(b.Client);d=$.Safe(c.Attr);e=$.Safe($$.WebSharper.Samples);f=$.Safe(e.PouchDB);g=$.Safe(f.Client);h=$.Safe(c.Tags);i=$.Safe($$.WebSharper.Option);j=$.Safe($$.WebSharper.Piglets);k=$.Safe(j.Pervasives);l=$.Safe(j.Piglet);m=$.Safe(f.Utils);n=$.Safe(l.Builder);o=$.Safe($$.Date);p=$.Safe($$.String);q=$.Safe($$.WebSharper.Seq);r=$.Safe($$.jQuery);s=$.Safe(f.Controls);t=$.Safe(j.Controls);u=$.Safe(c.Operators);v=$.Safe(a.T);w=$.Safe($$.WebSharper.Concurrency);x=$.Safe(g.Defaults);y=$.Safe($$.PouchDB);z=$.Safe($$.CodeMirror);A=$.Safe(j.Result);B=$.Safe(j.Stream);C=$.Safe($$.WebSharper.Strings);return D=$.Safe($$.WebSharper.Arrays);});$.OnLoad(function(){g.db();g.cm();g.RenderSnippets();g.Main();x.codes();g.Data();g.AdderPiglet();g.Accordions();g.AccordionId();return;});}());


if (typeof IntelliFactory !=='undefined')
  IntelliFactory.Runtime.Start();
